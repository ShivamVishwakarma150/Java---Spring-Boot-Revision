# **Java Generics: Comprehensive Guide**

## **1. Introduction to Generics**
Generics in Java allow you to write classes, interfaces, and methods that can work with different data types while providing **type safety** at compile time.

### **Why Generics?**
- **Type Safety**: Prevents runtime errors by catching type mismatches at compile time.
- **No Typecasting Needed**: Eliminates the need for explicit typecasting.
- **Code Reusability**: Write a single generic method/class that works with multiple types.

---

## **2. Generic Classes**
### **Problem Without Generics**
```java
public class Print {
    private Object value;

    public void setPrintValue(Object value) {
        this.value = value;
    }

    public Object getPrintValue() {
        return value;
    }
}
```
- **Issue**:  
  - `Object` can hold any type (`Integer`, `String`, etc.).
  - Requires **typecasting** when retrieving values.
  - No compile-time type checking.

### **Solution: Generic Class**
```java
public class Print<T> {
    private T value;

    public void setPrintValue(T value) {
        this.value = value;
    }

    public T getPrintValue() {
        return value;
    }
}
```
- **Usage**:
  ```java
  Print<Integer> intPrint = new Print<>();
  intPrint.setPrintValue(10);  // Only accepts Integer
  int num = intPrint.getPrintValue(); // No typecasting needed
  ```
- **Key Points**:
  - `T` is a **type parameter** (can be any non-primitive type).
  - Ensures type safety at compile time.

---

## **3. Inheritance with Generic Classes**
### **Case 1: Non-Generic Subclass**
- Must specify the type in the subclass.
```java
public class ColorPrint extends Print<String> {
    // Only works with String
}
```
- **Usage**:
  ```java
  ColorPrint cp = new ColorPrint();
  cp.setPrintValue("Red"); // Only String allowed
  ```

### **Case 2: Generic Subclass**
- The subclass remains generic.
```java
public class ColorPrint<T> extends Print<T> {
    // Works with any type T
}
```
- **Usage**:
  ```java
  ColorPrint<Integer> cp = new ColorPrint<>();
  cp.setPrintValue(10); // Works with Integer
  ```

---

## **4. Multiple Type Parameters**
- A class can have multiple generic types.
```java
public class Pair<K, V> {
    private K key;
    private V value;

    public void put(K key, V value) {
        this.key = key;
        this.value = value;
    }
}
```
- **Usage**:
  ```java
  Pair<String, Integer> pair = new Pair<>();
  pair.put("Age", 25);
  ```

---

## **5. Generic Methods**
- A method can be generic even if the class is not.
```java
public class Test {
    public <T> void printValue(T value) {
        System.out.println(value);
    }
}
```
- **Usage**:
  ```java
  Test test = new Test();
  test.<String>printValue("Hello"); // Explicit type
  test.printValue(10); // Type inference
  ```

### **Key Points**:
- Type parameter `<T>` is declared **before the return type**.
- Scope is limited to the method.

---

## **6. Bounded Generics**
### **Upper Bound (`extends`)**
- Restricts the type to a superclass and its subclasses.
```java
public class Print<T extends Number> {
    private T value;
    // Only accepts Number (Integer, Double, etc.)
}
```
- **Usage**:
  ```java
  Print<Integer> intPrint = new Print<>(); // Valid
  Print<String> strPrint = new Print<>(); // Compile-time error
  ```

### **Multiple Bounds**
- A type can extend **one class and multiple interfaces**.
```java
public class Printer<T extends Number & Serializable & Cloneable> {
    // T must be Number + implement Serializable & Cloneable
}
```

---

## **7. Wildcards (`?`)**
### **Upper Bounded Wildcard (`? extends`)**
- Accepts a type and its subclasses.
```java
public void processList(List<? extends Number> list) {
    // Accepts List<Integer>, List<Double>, etc.
}
```

### **Lower Bounded Wildcard (`? super`)**
- Accepts a type and its superclasses.
```java
public void addNumbers(List<? super Integer> list) {
    // Accepts List<Integer>, List<Number>, List<Object>
}
```

### **Unbounded Wildcard (`?`)**
- Accepts any type (only `Object` methods are safe).
```java
public void printList(List<?> list) {
    for (Object item : list) {
        System.out.println(item);
    }
}
```

---

## **8. Type Erasure**
- At runtime, generic type information is **erased**.
- Replaced with **raw types** (`Object` or the bound type).

### **Example:**
```java
// Source Code
public class Box<T> {
    private T value;
}

// After Erasure (Bytecode)
public class Box {
    private Object value;
}
```
- **Bounded Example** (`T extends Number` → `Number`).

---

## **9. Raw Types (Legacy Compatibility)**
- Using generics without type parameters.
```java
Print rawPrint = new Print(); // Raw type (unsafe)
rawPrint.setPrintValue("Hello"); // Warning
```

---

## **10. When to Use Generics vs. Wildcards**
| **Scenario**                     | **Generics (`<T>`)**               | **Wildcards (`?`)**               |
|----------------------------------|-----------------------------------|-----------------------------------|
| **Single type constraint**       | ✔️ (Enforces same type)           | ❌ (Allows different types)       |
| **Multiple bounds**              | ✔️ (`T extends A & B`)           | ❌ (Only one bound)               |
| **Lower bounds (`super`)**       | ❌ (Not supported)                | ✔️ (`? super Integer`)           |
| **Flexibility in parameters**    | ❌ (Strict type matching)        | ✔️ (Works with any subtype)      |

### **Example:**
```java
// Generic Method (Strict type matching)
public <T> void copy(List<T> src, List<T> dest) { ... }

// Wildcard Method (Flexible)
public void copy(List<? extends Number> src, List<? super Number> dest) { ... }
```

---

## **11. Key Takeaways**
1. **Generics** provide **type safety** and **eliminate typecasting**.
2. **Generic classes** use `<T>` to define type parameters.
3. **Bounded generics** (`extends`, `super`) restrict types.
4. **Wildcards** (`?`) allow flexibility in method parameters.
5. **Type erasure** removes generics at runtime, replacing them with raw types.
6. **Raw types** exist for backward compatibility but are unsafe.

---

## **12. Practical Use Cases**
1. **Collections Framework** (`ArrayList<Integer>`, `HashMap<String, Integer>`).
2. **Custom Generic Classes** (e.g., `Box<T>`, `Pair<K, V>`).
3. **Generic Methods** for reusable algorithms.

---

## **13. Conclusion**
Generics are a powerful feature in Java that:
- Improve **type safety**.
- Reduce **boilerplate code** (no typecasting).
- Enable **reusable and flexible** code.
