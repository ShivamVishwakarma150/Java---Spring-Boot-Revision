# Detailed Explanation of HashMap in Java

I'll provide a comprehensive explanation of HashMap in Java, including its internal workings, with step-by-step code examples.

## 1. HashMap Basics

HashMap is a part of Java's Collections Framework but doesn't implement the Collection interface. It stores data in key-value pairs and provides constant-time performance for basic operations (get and put).

### Key Characteristics:
- Stores key-value pairs
- Doesn't allow duplicate keys
- Allows one null key and multiple null values
- Not thread-safe
- Doesn't maintain insertion order

## 2. Internal Working of HashMap

HashMap internally uses:
- An array of nodes (table/buckets)
- Each node is an instance of a class that implements Map.Entry interface
- Uses hashing to store and retrieve elements

### Node Structure:
```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash; // hashcode of key
    final K key;
    V value;
    Node<K,V> next; // reference to next node
}
```

## 3. Step-by-Step Code Explanation

### 3.1 Creating a HashMap

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapDemo {
    public static void main(String[] args) {
        // Create a HashMap
        Map<Integer, String> studentMap = new HashMap<>();
        
        // Default initial capacity is 16
        // Load factor is 0.75
    }
}
```

### 3.2 Adding Elements (put operation)

```java
// Adding elements to HashMap
studentMap.put(1, "Alice");
studentMap.put(2, "Bob");
studentMap.put(3, "Charlie");
studentMap.put(null, "No Name"); // null key
studentMap.put(4, null); // null value

System.out.println(studentMap); 
// Output might be: {null=No Name, 1=Alice, 2=Bob, 3=Charlie, 4=null}
```

### How put() works internally:
1. Calculate hashcode of the key
2. Calculate index using: `index = hashcode & (n-1)` where n is array size
3. If bucket is empty, create new node and place it there
4. If bucket has nodes:
   - Check if first node's key matches using equals()
   - If matches, replace value
   - If not, traverse linked list/check tree
   - If no match found, add new node at end

### 3.3 Retrieving Elements (get operation)

```java
// Getting values
String student1 = studentMap.get(1); // "Alice"
String studentNull = studentMap.get(null); // "No Name"
String student5 = studentMap.get(5); // null (key doesn't exist)

System.out.println("Student with ID 2: " + studentMap.get(2));
```

### How get() works internally:
1. Calculate hashcode of the key
2. Calculate index using same formula as put()
3. Go to the bucket at calculated index
4. Compare keys using equals() starting from first node
5. Return value if key matches, else return null

### 3.4 Handling Collisions

When two keys have same hashcode (collision), HashMap handles it by:
1. Initially using separate chaining (linked list)
2. If list grows beyond threshold (TREEIFY_THRESHOLD = 8), converts to balanced tree
3. If size reduces (UNTREEIFY_THRESHOLD = 6), converts back to linked list

```java
// Demonstration of collision
Map<String, String> collisionMap = new HashMap<>(4); // Small capacity for demo

// These keys will likely collide in small table
collisionMap.put("Aa", "First");
collisionMap.put("BB", "Second");

System.out.println(collisionMap);
// Both entries will be in same bucket, either as linked list or tree
```

### 3.5 Important Methods

```java
// Check if key exists
boolean hasKey = studentMap.containsKey(2); // true

// Check if value exists
boolean hasValue = studentMap.containsValue("Alice"); // true

// Remove element
String removed = studentMap.remove(3); // removes and returns "Charlie"

// Size and empty check
int size = studentMap.size(); // current size
boolean isEmpty = studentMap.isEmpty(); // false

// Get all keys
Set<Integer> keys = studentMap.keySet();
System.out.println("Keys: " + keys);

// Get all values
Collection<String> values = studentMap.values();
System.out.println("Values: " + values);

// Get all entries
Set<Map.Entry<Integer, String>> entries = studentMap.entrySet();
for (Map.Entry<Integer, String> entry : entries) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
```

### 3.6 Load Factor and Rehashing

```java
// Creating HashMap with custom initial capacity and load factor
Map<Integer, String> customMap = new HashMap<>(32, 0.5f);

// Adding elements until rehashing occurs
for (int i = 0; i < 17; i++) { // 16*0.5 = 8 threshold
    customMap.put(i, "Value" + i);
    // Rehashing will occur when size reaches 8
}
```

### 3.7 putIfAbsent Example

```java
// Only put if key is not present or value is null
studentMap.putIfAbsent(2, "New Bob"); // Won't replace existing
studentMap.putIfAbsent(5, "Eve"); // Will add new entry
studentMap.putIfAbsent(4, "NotNull"); // Will replace null value

System.out.println(studentMap);
```

## 4. Complete Example with All Operations

```java
import java.util.*;

public class CompleteHashMapExample {
    public static void main(String[] args) {
        // 1. Create HashMap
        Map<Integer, String> employeeMap = new HashMap<>();
        
        // 2. Add elements
        employeeMap.put(101, "John");
        employeeMap.put(102, "Alice");
        employeeMap.put(103, "Bob");
        employeeMap.put(null, "No ID");
        employeeMap.put(104, null);
        
        // 3. Display
        System.out.println("Initial Map: " + employeeMap);
        
        // 4. Get elements
        System.out.println("Employee 102: " + employeeMap.get(102));
        System.out.println("Null key: " + employeeMap.get(null));
        
        // 5. Check existence
        System.out.println("Contains key 103? " + employeeMap.containsKey(103));
        System.out.println("Contains value 'John'? " + employeeMap.containsValue("John"));
        
        // 6. Remove elements
        employeeMap.remove(103);
        System.out.println("After removing 103: " + employeeMap);
        
        // 7. Iterate using entrySet
        System.out.println("\nIterating using entrySet():");
        for (Map.Entry<Integer, String> entry : employeeMap.entrySet()) {
            System.out.println("ID: " + entry.getKey() + ", Name: " + entry.getValue());
        }
        
        // 8. Iterate using keySet
        System.out.println("\nIterating using keySet():");
        for (Integer id : employeeMap.keySet()) {
            System.out.println("ID: " + id + ", Name: " + employeeMap.get(id));
        }
        
        // 9. Replace values
        employeeMap.replace(101, "John Doe");
        employeeMap.replace(102, "Alice", "Alice Smith");
        System.out.println("\nAfter replacements: " + employeeMap);
        
        // 10. Compute if absent
        employeeMap.computeIfAbsent(105, k -> "Employee" + k);
        System.out.println("After computeIfAbsent: " + employeeMap);
        
        // 11. Clear map
        employeeMap.clear();
        System.out.println("After clear: " + employeeMap);
    }
}
```

## 5. Performance Considerations

- **Average case time complexity**: O(1) for get() and put()
- **Worst case time complexity**: O(log n) when many collisions occur and tree is used
- **Factors affecting performance**:
  - Initial capacity
  - Load factor
  - Quality of hashCode() implementation

## 6. Best Practices

1. **Initial Capacity**: Set initial capacity if you know approximate size to avoid rehashing
   ```java
   Map<String, String> map = new HashMap<>(100); // Initial capacity 100
   ```

2. **Good hashCode()**: Override hashCode() properly in custom key objects
   - Equal objects must have same hashcode
   - Unequal objects should ideally have different hashcodes

3. **Thread Safety**: Use `ConcurrentHashMap` or `Collections.synchronizedMap()` for thread-safe operations

4. **Iteration**: Use entrySet() for iteration as it's more efficient than keySet() + get()

## 7. HashMap vs HashTable

| Feature        | HashMap | HashTable |
|---------------|---------|-----------|
| Thread-safe   | No      | Yes       |
| Null keys     | Yes     | No        |
| Null values   | Yes     | No        |
| Performance   | Faster  | Slower    |
| Synchronization | Not synchronized | Synchronized |

## 8. Conclusion

HashMap is one of the most commonly used data structures in Java due to its efficiency and flexibility. Understanding its internal workings (hashing, collision resolution, load factor) is crucial for using it effectively and for interview preparation.

Key takeaways:
- Uses array + linked list/balanced tree structure
- Default capacity 16, load factor 0.75
- Rehashes when threshold (capacity * load factor) is reached
- Provides constant time performance for basic operations
- Not thread-safe - use ConcurrentHashMap for concurrent access