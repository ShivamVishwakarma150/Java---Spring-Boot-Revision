# **Comprehensive Explanation of Queue, Comparator, and Comparable in Java**

This explanation will cover:
1. **Queue Interface** and its implementations (PriorityQueue)
2. **Comparator vs. Comparable** for sorting collections
3. Practical code examples for each concept

---

## **1. Queue Interface in Java**
A **Queue** follows the **FIFO (First-In-First-Out)** principle, but some implementations (like `PriorityQueue`) modify this behavior.

### **Queue Methods**
| Method | Behavior |
|--------|----------|
| `add(E e)` | Inserts element, throws exception if fails |
| `offer(E e)` | Inserts element, returns `false` if fails |
| `remove()` | Removes and returns head, throws exception if empty |
| `poll()` | Removes and returns head, returns `null` if empty |
| `element()` | Retrieves head (does not remove), throws exception if empty |
| `peek()` | Retrieves head (does not remove), returns `null` if empty |

### **PriorityQueue: Min-Heap & Max-Heap**
- By default, `PriorityQueue` is a **min-heap** (smallest element has highest priority).
- To make it a **max-heap**, provide a **Comparator** that reverses the order.

#### **Example: Min-Heap (Default)**
```java
import java.util.PriorityQueue;

public class PriorityQueueExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        minHeap.add(5);
        minHeap.add(2);
        minHeap.add(8);
        minHeap.add(1);

        System.out.println("Min-Heap Order:");
        while (!minHeap.isEmpty()) {
            System.out.println(minHeap.poll()); // Output: 1, 2, 5, 8
        }
    }
}
```
**Output:**
```
1
2
5
8
```

#### **Example: Max-Heap (Using Comparator)**
```java
import java.util.PriorityQueue;
import java.util.Collections;

public class PriorityQueueExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        maxHeap.add(5);
        maxHeap.add(2);
        maxHeap.add(8);
        maxHeap.add(1);

        System.out.println("Max-Heap Order:");
        while (!maxHeap.isEmpty()) {
            System.out.println(maxHeap.poll()); // Output: 8, 5, 2, 1
        }
    }
}
```
**Output:**
```
8
5
2
1
```

---

## **2. Comparator vs. Comparable**
Both help in **sorting objects**, but they differ in usage:

| Feature | **Comparable** | **Comparator** |
|---------|---------------|---------------|
| **Interface** | `java.lang.Comparable` | `java.util.Comparator` |
| **Method** | `compareTo(T o)` | `compare(T o1, T o2)` |
| **Usage** | Natural ordering (e.g., `String`, `Integer`) | Custom ordering (e.g., sort by name, age) |
| **Modification** | Must modify the class | No class modification needed |
| **Multiple Sorting** | Only one way | Multiple ways (by name, age, etc.) |

### **(A) Comparable Example**
Used when a class has a **natural ordering** (e.g., `String`, `Integer`).

#### **Example: Sorting Cars by Name (Natural Order)**
```java
class Car implements Comparable<Car> {
    String name;
    String type;

    public Car(String name, String type) {
        this.name = name;
        this.type = type;
    }

    @Override
    public int compareTo(Car other) {
        return this.name.compareTo(other.name); // Ascending order
    }

    @Override
    public String toString() {
        return name + " (" + type + ")";
    }
}

public class ComparableExample {
    public static void main(String[] args) {
        List<Car> cars = new ArrayList<>();
        cars.add(new Car("SUV", "Petrol"));
        cars.add(new Car("Sedan", "Diesel"));
        cars.add(new Car("Hatchback", "CNG"));

        Collections.sort(cars); // Uses compareTo()

        System.out.println("Sorted by Name (Natural Order):");
        cars.forEach(System.out::println);
    }
}
```
**Output:**
```
Hatchback (CNG)
Sedan (Diesel)
SUV (Petrol)
```

### **(B) Comparator Example**
Used for **custom sorting** without modifying the class.

#### **Example: Sorting Cars by Type (Custom Order)**
```java
import java.util.Comparator;

public class ComparatorExample {
    public static void main(String[] args) {
        List<Car> cars = new ArrayList<>();
        cars.add(new Car("SUV", "Petrol"));
        cars.add(new Car("Sedan", "Diesel"));
        cars.add(new Car("Hatchback", "CNG"));

        // Sort by type (Descending order)
        Comparator<Car> typeComparator = (car1, car2) -> car2.type.compareTo(car1.type);
        Collections.sort(cars, typeComparator);

        System.out.println("Sorted by Type (Descending):");
        cars.forEach(System.out::println);
    }
}
```
**Output:**
```
SUV (Petrol)
Sedan (Diesel)
Hatchback (CNG)
```

#### **Example: Multiple Comparators**
```java
// Sort by name (Ascending)
Comparator<Car> nameAsc = Comparator.comparing(car -> car.name);

// Sort by type (Descending)
Comparator<Car> typeDesc = (car1, car2) -> car2.type.compareTo(car1.type);

// Sort by name then type
Comparator<Car> nameThenType = nameAsc.thenComparing(typeDesc);

Collections.sort(cars, nameThenType);
```

---

## **3. Key Takeaways**
1. **Queue** is FIFO, but `PriorityQueue` uses **heap ordering**.
2. **Comparable** defines **natural ordering** (`compareTo`).
3. **Comparator** allows **custom sorting** (`compare`) without modifying the class.
4. **PriorityQueue** defaults to **min-heap**, but a **Comparator** can make it a **max-heap**.

### **When to Use Which?**
- Use **Comparable** if the class has a **single natural ordering**.
- Use **Comparator** for **multiple sorting strategies** or when you **can't modify the class**.

---

## **Final Code Example (Combining All)**
```java
import java.util.*;

class Car implements Comparable<Car> {
    String name;
    String type;

    public Car(String name, String type) {
        this.name = name;
        this.type = type;
    }

    @Override
    public int compareTo(Car other) {
        return this.name.compareTo(other.name); // Natural order (name)
    }

    @Override
    public String toString() {
        return name + " (" + type + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        // PriorityQueue (Min-Heap & Max-Heap)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        minHeap.add(5);
        minHeap.add(2);
        minHeap.add(8);
        minHeap.add(1);

        System.out.println("Min-Heap:");
        while (!minHeap.isEmpty()) System.out.println(minHeap.poll());

        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        maxHeap.add(5);
        maxHeap.add(2);
        maxHeap.add(8);
        maxHeap.add(1);

        System.out.println("\nMax-Heap:");
        while (!maxHeap.isEmpty()) System.out.println(maxHeap.poll());

        // Comparable (Natural Order)
        List<Car> cars = new ArrayList<>();
        cars.add(new Car("SUV", "Petrol"));
        cars.add(new Car("Sedan", "Diesel"));
        cars.add(new Car("Hatchback", "CNG"));

        Collections.sort(cars);
        System.out.println("\nSorted by Name (Natural Order):");
        cars.forEach(System.out::println);

        // Comparator (Custom Order)
        Comparator<Car> typeDesc = (car1, car2) -> car2.type.compareTo(car1.type);
        Collections.sort(cars, typeDesc);
        System.out.println("\nSorted by Type (Descending):");
        cars.forEach(System.out::println);
    }
}
```
**Output:**
```
Min-Heap:
1
2
5
8

Max-Heap:
8
5
2
1

Sorted by Name (Natural Order):
Hatchback (CNG)
Sedan (Diesel)
SUV (Petrol)

Sorted by Type (Descending):
SUV (Petrol)
Sedan (Diesel)
Hatchback (CNG)
```

This covers **Queue, Comparator, and Comparable** in depth with practical examples. ðŸš€