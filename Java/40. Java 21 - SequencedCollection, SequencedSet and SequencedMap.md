# **Topic: New Sequenced Collection Interfaces in Java 21 (SequenceCollection, SequencedSet, SequencedMap)**


### **1. Introduction to Sequenced Collections**
Java 21 introduced three new interfaces to the Collections Framework:  
- `SequencedCollection`  
- `SequencedSet`  
- `SequencedMap`  

These interfaces provide a standardized way to handle collections that maintain a well-defined encounter order (insertion order or sorted order) and support operations at both ends (first and last elements). They address the lack of a common API for such operations across different collection types.

---

### **2. Why Were These Interfaces Added?**
#### **Problem:**
Before Java 21, collections with a defined order (e.g., `List`, `Deque`, `LinkedHashSet`, `SortedSet`, `LinkedHashMap`, `SortedMap`) had their own methods for accessing, adding, or removing elements at the ends. For example:
- `List`: `list.get(0)`, `list.add(0, element)`, `list.remove(0)`
- `Deque`: `deque.getFirst()`, `deque.addFirst(element)`, `deque.removeLast()`
- `SortedSet`: `sortedSet.first()`, `sortedSet.last()`
- `LinkedHashSet`: No direct methods for first/last operations (required manual iteration).

This inconsistency made code harder to write and maintain.

#### **Solution:**
The new sequenced interfaces provide a unified API for:
1. Accessing first and last elements.
2. Adding elements at the first or last position.
3. Removing elements from the first or last position.
4. Reversing the collection (as a view, without modifying the underlying collection).

---

### **3. Criteria for a Collection to Be "Sequenced"**
A collection is considered "sequenced" if it satisfies these conditions:
1. **Predictable Iteration Order**: Elements are always encountered in a consistent order (insertion order or sorted order).
2. **Support for First/Last Operations**: The collection allows access, insertion, and removal at both ends.
3. **Reversible View**: The collection can provide a reversed view of itself (without modifying the underlying data).

---

### **4. Java Collection Hierarchy Changes in Java 21**
The new interfaces fit into the existing hierarchy as follows:

#### **SequencedCollection**
- Extends `Collection`.
- Implemented by:
  - `List` (insertion order, allows duplicates)
  - `Deque` (insertion order, allows duplicates)
- Why not `Queue` or `PriorityQueue`?
  - `Queue`: Supports FIFO but does not allow access to the last element or reversal.
  - `PriorityQueue`: No predictable iteration order (only the head is guaranteed).

#### **SequencedSet**
- Extends `Set` and `SequencedCollection`.
- Implemented by:
  - `LinkedHashSet` (insertion order, no duplicates)
  - `SortedSet` (sorted order, no duplicates)
- Why is `SequencedSet` needed?
  - To handle sets (no duplicates) separately from collections that allow duplicates.

#### **SequencedMap**
- Extends `Map`.
- Implemented by:
  - `LinkedHashMap` (insertion order)
  - `SortedMap` (sorted order)
- Why not `HashMap` or `Hashtable`?
  - They do not maintain any order.

---

### **5. Key Methods in the Sequenced Interfaces**
#### **SequencedCollection**
- `addFirst(E)`, `addLast(E)`: Add elements at the ends.
- `getFirst()`, `getLast()`: Access elements at the ends.
- `removeFirst()`, `removeLast()`: Remove elements from the ends.
- `reversed()`: Returns a reversed view of the collection.

#### **SequencedSet**
- Inherits all methods from `SequencedCollection` but enforces no duplicates.

#### **SequencedMap**
- `putFirst(K, V)`, `putLast(K, V)`: Insert entries at the ends.
- `firstEntry()`, `lastEntry()`: Access entries at the ends.
- `pollFirstEntry()`, `pollLastEntry()`: Remove and return entries from the ends.
- `reversed()`: Returns a reversed view of the map.

---

### **6. Examples of Usage**
#### **List (SequencedCollection)**
```java
List<String> list = new ArrayList<>();
list.add("B"); list.add("C"); list.add("D");
list.addFirst("A"); // [A, B, C, D]
list.addLast("E");  // [A, B, C, D, E]
String first = list.getFirst(); // "A"
String last = list.getLast();   // "E"
list.removeFirst(); // [B, C, D, E]
list.removeLast();  // [B, C, D]
SequencedCollection<String> reversed = list.reversed(); // [D, C, B]
```

#### **LinkedHashSet (SequencedSet)**
```java
SequencedSet<String> set = new LinkedHashSet<>();
set.add("B"); set.add("C"); set.add("D");
set.addFirst("A"); // [A, B, C, D]
set.addLast("E");  // [A, B, C, D, E]
set.addFirst("C"); // Duplicate moved to first: [C, A, B, D, E]
```

#### **LinkedHashMap (SequencedMap)**
```java
SequencedMap<Integer, String> map = new LinkedHashMap<>();
map.put(100, "B"); map.put(200, "C"); map.put(300, "D");
map.putFirst(50, "A");  // {50=A, 100=B, 200=C, 300=D}
map.putLast(400, "E");  // {50=A, 100=B, 200=C, 300=D, 400=E}
Map.Entry<Integer, String> firstEntry = map.firstEntry(); // 50=A
Map.Entry<Integer, String> lastEntry = map.lastEntry();   // 400=E
```

#### **SortedSet (SequencedSet)**
- `addFirst()`/`addLast()` throw `UnsupportedOperationException` because the sort order determines positions.

---

### **7. Benefits of Sequenced Collections**
1. **Consistent API**: Unified methods for first/last operations across all ordered collections.
2. **Ease of Use**: No need to remember type-specific methods (e.g., `get(0)` for `List` vs. `getFirst()` for `Deque`).
3. **Reversal Support**: Easy access to reversed views without copying the collection.
4. **Type Safety**: `SequencedSet` ensures no duplicates, while `SequencedCollection` allows them.

---

### **8. Summary**
- **SequencedCollection**: Base interface for ordered collections with duplicates (e.g., `List`, `Deque`).
- **SequencedSet**: Extends `SequencedCollection` for sets (no duplicates, e.g., `LinkedHashSet`, `SortedSet`).
- **SequencedMap**: For maps with order (e.g., `LinkedHashMap`, `SortedMap`).
- **Excluded Collections**: `Queue`, `PriorityQueue`, `HashSet`, `HashMap`, `Hashtable` (no predictable order or end operations).

These interfaces simplify code and make the Collections Framework more consistent and intuitive.

<br/>
<br/>

```java
import java.util.*;
import java.util.concurrent.LinkedBlockingDeque;

/**
 * Demonstrates the new Sequenced Collection interfaces in Java 21:
 * SequencedCollection, SequencedSet, and SequencedMap.
 * Shows how they provide a unified API for collections with predictable iteration order.
 */
public class SequencedCollectionsDemo {

    public static void main(String[] args) {
        System.out.println("=== SEQUENCED COLLECTIONS IN JAVA 21 ===\n");
        
        demonstrateList();
        demonstrateDeque();
        demonstrateLinkedHashSet();
        demonstrateTreeSet();
        demonstrateLinkedHashMap();
        demonstrateTreeMap();
        
        System.out.println("=== DEMONSTRATION COMPLETE ===");
    }

    /**
     * Demonstrates SequencedCollection operations with an ArrayList.
     * List maintains insertion order and allows duplicates.
     */
    private static void demonstrateList() {
        System.out.println("1. LIST (SequencedCollection):");
        
        // Create a list - maintains insertion order, allows duplicates
        SequencedCollection<String> list = new ArrayList<>();
        list.add("B"); list.add("C"); list.add("D");
        System.out.println("Initial list: " + list);
        
        // Add elements at ends
        list.addFirst("A");
        list.addLast("E");
        System.out.println("After addFirst('A') and addLast('E'): " + list);
        
        // Access elements at ends
        System.out.println("First element: " + list.getFirst());
        System.out.println("Last element: " + list.getLast());
        
        // Remove elements from ends
        list.removeFirst();
        list.removeLast();
        System.out.println("After removeFirst() and removeLast(): " + list);
        
        // Get reversed view (doesn't modify original)
        SequencedCollection<String> reversed = list.reversed();
        System.out.println("Reversed view: " + reversed);
        System.out.println("Original list unchanged: " + list);
        System.out.println();
    }

    /**
     * Demonstrates SequencedCollection operations with a Deque (ArrayDeque).
     * Deque maintains insertion order and allows duplicates.
     */
    private static void demonstrateDeque() {
        System.out.println("2. DEQUE (SequencedCollection):");
        
        // Create a deque - maintains insertion order, allows duplicates
        SequencedCollection<String> deque = new ArrayDeque<>();
        Collections.addAll(deque, "B", "C", "D");
        System.out.println("Initial deque: " + deque);
        
        // Use sequenced operations (same API as List!)
        deque.addFirst("A");
        deque.addLast("E");
        System.out.println("After addFirst('A') and addLast('E'): " + deque);
        
        System.out.println("First element: " + deque.getFirst());
        System.out.println("Last element: " + deque.getLast());
        
        deque.removeFirst();
        deque.removeLast();
        System.out.println("After removeFirst() and removeLast(): " + deque);
        
        System.out.println("Reversed: " + deque.reversed());
        System.out.println();
    }

    /**
     * Demonstrates SequencedSet operations with LinkedHashSet.
     * Maintains insertion order but no duplicates allowed.
     */
    private static void demonstrateLinkedHashSet() {
        System.out.println("3. LINKEDHASHSET (SequencedSet):");
        
        // Create a LinkedHashSet - maintains insertion order, no duplicates
        SequencedSet<String> set = new LinkedHashSet<>();
        Collections.addAll(set, "B", "C", "D");
        System.out.println("Initial set: " + set);
        
        // Add elements at ends
        set.addFirst("A");
        set.addLast("E");
        System.out.println("After addFirst('A') and addLast('E'): " + set);
        
        // Try to add duplicate - moves existing element to first position
        set.addFirst("C");
        System.out.println("After addFirst('C') - duplicate moved to front: " + set);
        
        System.out.println("First element: " + set.getFirst());
        System.out.println("Last element: " + set.getLast());
        
        set.removeFirst();
        set.removeLast();
        System.out.println("After removeFirst() and removeLast(): " + set);
        
        System.out.println("Reversed: " + set.reversed());
        System.out.println();
    }

    /**
     * Demonstrates SequencedSet operations with TreeSet.
     * Maintains sorted order, no duplicates. addFirst/addLast not supported.
     */
    private static void demonstrateTreeSet() {
        System.out.println("4. TREESET (SequencedSet - Sorted):");
        
        // Create a TreeSet - maintains sorted order, no duplicates
        SequencedSet<String> sortedSet = new TreeSet<>();
        Collections.addAll(sortedSet, "Charlie", "Alpha", "Bravo");
        System.out.println("Initial sorted set: " + sortedSet);
        
        // Access elements at ends
        System.out.println("First element (sorted): " + sortedSet.getFirst());
        System.out.println("Last element (sorted): " + sortedSet.getLast());
        
        // addFirst/addLast not supported for sorted collections
        try {
            sortedSet.addFirst("Delta");
        } catch (UnsupportedOperationException e) {
            System.out.println("addFirst() not supported for sorted sets: " + e.getMessage());
        }
        
        // But we can add normally - it goes to its sorted position
        sortedSet.add("Delta");
        System.out.println("After adding 'Delta': " + sortedSet);
        
        System.out.println("Reversed: " + sortedSet.reversed());
        System.out.println();
    }

    /**
     * Demonstrates SequencedMap operations with LinkedHashMap.
     * Maintains insertion order of entries.
     */
    private static void demonstrateLinkedHashMap() {
        System.out.println("5. LINKEDHASHMAP (SequencedMap):");
        
        // Create a LinkedHashMap - maintains insertion order
        SequencedMap<Integer, String> map = new LinkedHashMap<>();
        map.put(100, "B");
        map.put(200, "C");
        map.put(300, "D");
        System.out.println("Initial map: " + map);
        
        // Put entries at ends
        map.putFirst(50, "A");
        map.putLast(400, "E");
        System.out.println("After putFirst(50, 'A') and putLast(400, 'E'): " + map);
        
        // Access entries at ends
        System.out.println("First entry: " + map.firstEntry());
        System.out.println("Last entry: " + map.lastEntry());
        
        // Poll (remove and return) entries from ends
        System.out.println("Poll first entry: " + map.pollFirstEntry());
        System.out.println("Poll last entry: " + map.pollLastEntry());
        System.out.println("After polling ends: " + map);
        
        System.out.println("Reversed: " + map.reversed());
        System.out.println();
    }

    /**
     * Demonstrates SequencedMap operations with TreeMap.
     * Maintains sorted order by keys. putFirst/putLast not supported.
     */
    private static void demonstrateTreeMap() {
        System.out.println("6. TREEMAP (SequencedMap - Sorted):");
        
        // Create a TreeMap - maintains sorted order by keys
        SequencedMap<Integer, String> sortedMap = new TreeMap<>();
        sortedMap.put(300, "Charlie");
        sortedMap.put(100, "Alpha");
        sortedMap.put(200, "Bravo");
        System.out.println("Initial sorted map: " + sortedMap);
        
        // Access entries at ends
        System.out.println("First entry (sorted): " + sortedMap.firstEntry());
        System.out.println("Last entry (sorted): " + sortedMap.lastEntry());
        
        // putFirst/putLast not supported for sorted maps
        try {
            sortedMap.putFirst(50, "Delta");
        } catch (UnsupportedOperationException e) {
            System.out.println("putFirst() not supported for sorted maps: " + e.getMessage());
        }
        
        // But we can put normally - it goes to its sorted position
        sortedMap.put(250, "Delta");
        System.out.println("After putting (250, 'Delta'): " + sortedMap);
        
        System.out.println("Reversed: " + sortedMap.reversed());
        System.out.println();
    }
}
```

### **Key Explanations:**

1. **Unified API**: All sequenced collections now share common methods like `addFirst()`, `addLast()`, `getFirst()`, `getLast()`, `removeFirst()`, `removeLast()`, and `reversed()`.

2. **Order Preservation**:
   - `List`/`Deque`/`LinkedHashSet`/`LinkedHashMap`: Insertion order
   - `TreeSet`/`TreeMap`: Sorted order

3. **Duplicate Handling**:
   - `SequencedCollection`: Allows duplicates
   - `SequencedSet`: No duplicates (moves existing element when adding duplicate at front)

4. **Sorted Collections**:
   - `TreeSet`/`TreeMap`: `addFirst()`/`putFirst()` throw `UnsupportedOperationException` because sort order determines positions
   - But they still support other sequenced operations

5. **Reversed Views**:
   - `reversed()` returns a view, not a copy
   - Changes to original affect the reversed view and vice versa

6. **Why Not Other Collections?**
   - `HashSet`/`HashMap`: No predictable order
   - `Queue`/`PriorityQueue`: No access to last element or reversal support

This demonstrates how Java 21 brings consistency to ordered collections while maintaining backward compatibility!