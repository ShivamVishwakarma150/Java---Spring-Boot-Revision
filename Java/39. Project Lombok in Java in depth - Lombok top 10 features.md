# Project Lombok in Java in depth | Lombok top 10 features

### 1. What is Lombok? (The "Why")

**Problem (Boilerplate Code):** Java is often criticized for requiring a lot of repetitive, non-business logic code (boilerplate). For a simple class to hold data (a POJO), you need:
*   Getters and Setters for each field
*   `equals()`, `hashCode()`, and `toString()` methods
*   Constructors
*   Null checks
*   try-with-resources or finally blocks

This code is tedious to write, error-prone, and clutters your classes, making them harder to read.

**Solution (Lombok):** Project Lombok is a Java library that uses **annotations** to tell the compiler to generate this boilerplate code **during compilation**. Your source code remains clean and concise, but the compiled `.class` file contains all the necessary methods.

---

### 2. Setup & Configuration (The "How")

#### Step 1: Add Lombok Dependency (Maven)
Add the latest version of Lombok to your `pom.xml`.

```xml
<dependencies>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.30</version> <!-- Check for the latest version -->
        <scope>provided</scope> <!-- Important: It's only needed for compilation -->
    </dependency>
</dependencies>
```

#### Step 2: IDE Setup (For IntelliJ IDEA)
Lombok modifies the compiled code, not the source code. Your IDE needs a plugin to understand these modifications and avoid showing false errors.

1.  **Install the Plugin:**
    *   Go to `File -> Settings -> Plugins -> Marketplace`
    *   Search for "Lombok"
    *   Install the plugin and restart IntelliJ.

2.  **Enable Annotation Processing:**
    *   Go to `File -> Settings -> Build, Execution, Deployment -> Compiler -> Annotation Processors`
    *   Check the box `Enable annotation processing`.

Without these steps, IntelliJ will show "Cannot resolve symbol" errors for Lombok-generated methods like `getName()` or `toString()`, even though the code will compile and run correctly.

---

### 3. Top Lombok Annotations with Code Examples (The "What")

Let's go through the annotations you mentioned, one by one.

#### 1. `val` and `var`
*   **Purpose:** Type inference for **local variables**. Lets you declare a variable without explicitly writing its type.
*   **`val`:** Infers the type and makes the variable `final` (immutable).
*   **`var`:** Infers the type but does *not* make it `final` (mutable).
*   **Restriction:** Can *only* be used on local variables. Not for fields or method parameters.

**Code Example:**
```java
import lombok.val;
import lombok.var;
import java.util.ArrayList;

public class ValVarExample {
    public static void main(String[] args) {
        // Lombok infers this is a final String
        val immutableString = "Hello, World!";
        // immutableString = "Change"; // ERROR: Cannot assign a value to final variable

        // Lombok infers this is an ArrayList<String>
        val list = new ArrayList<String>();
        list.add("Item");

        // Lombok infers this is a mutable String
        var mutableString = "Hello";
        mutableString = "Goodbye"; // This is allowed

        System.out.println(immutableString);
        System.out.println(mutableString);
        System.out.println(list);
    }
}
```
**What the compiled code looks like (conceptually):**
```java
public class ValVarExample {
    public static void main(String[] args) {
        final String immutableString = "Hello, World!";
        final ArrayList<String> list = new ArrayList<String>();
        // ... and so on
    }
}
```

---

#### 2. `@NonNull`
*   **Purpose:** Generates a **null-check** for a method or constructor parameter. If the parameter is `null`, a `NullPointerException` is thrown immediately.
*   **Usage:** Placed on a method parameter.

**Code Example:**
```java
import lombok.NonNull;

public class NonNullExample {
    public void printName(@NonNull String name) {
        // Lombok adds a null-check at the start of this method
        System.out.println("Name: " + name);
    }

    public static void main(String[] args) {
        NonNullExample example = new NonNullExample();
        example.printName("Alice"); // Works fine
        example.printName(null);    // Throws NullPointerException
    }
}
```
**What the compiled code looks like:**
```java
public class NonNullExample {
    public void printName(String name) {
        if (name == null) {
            throw new NullPointerException("name is marked non-null but is null");
        }
        System.out.println("Name: " + name);
    }
}
```

---

#### 3. `@Getter` and `@Setter`
*   **Purpose:** Automatically generates getter and setter methods.
*   **Usage:** Can be applied to a **class** (affects all non-static fields) or to individual **fields**.
*   **Default:** Methods are generated with `public` access.
*   **Control:** You can specify the access level (`AccessLevel.PRIVATE`, `PROTECTED`, etc.).
*   **Setter Logic:** `@Setter` is **not generated** for `final` fields (they can't be changed) or `static` fields.

**Code Example (Field Level):**
```java
import lombok.Getter;
import lombok.Setter;
import lombok.AccessLevel;

public class GetterSetterExample {
    // Generates public String getName() / public void setName(String name)
    @Getter @Setter
    private String name;

    // Generates public boolean isCommitteeMember() / public void setCommitteeMember(boolean cm)
    @Getter @Setter
    private boolean committeeMember;

    // Generates a private getter: private int getAge()
    @Getter(AccessLevel.PRIVATE)
    private int age;

    // Generates a protected setter: protected void setAddress(String address)
    @Setter(AccessLevel.PROTECTED)
    private String address;

    // final field -> Only a getter is generated, NO setter.
    @Getter
    private final String id = "123";

    // static field -> Neither getter nor setter is generated by @Getter/@Setter on a field.
    private static String staticField;
}
// Usage in another class:
// GetterSetterExample obj = new GetterSetterExample();
// obj.setName("Bob");
// String n = obj.getName();
```

**Code Example (Class Level):**
```java
import lombok.Getter;
import lombok.Setter;

@Getter // Generates getters for all non-static fields
@Setter // Generates setters for all non-static, non-final fields
public class GetterSetterClassExample {
    private String name;        // getName(), setName()
    private boolean active;     // isActive(), setActive()
    private final int id = 1;   // getId(), NO SETTER

    // To exclude a field from class-level generation
    @Setter(AccessLevel.NONE) // Override: No setter for this field
    private String excludedField; // getExcludedField(), NO SETTER
}
```

---

#### 4. `@ToString`
*   **Purpose:** Generates a `toString()` method.
*   **Default:** Outputs the class name and all non-static fields.
*   **Control:** You can `exclude` specific fields, or use `onlyExplicitlyIncluded = true` to only include fields marked with `@ToString.Include`.

**Code Example:**
```java
import lombok.ToString;

@ToString // Includes all fields: "ToStringExample(name=Alice, committeeMember=true, age=30)"
public class ToStringExample {
    private String name = "Alice";
    private boolean committeeMember = true;
    private int age = 30;

    // Exclude a field from the toString output
    @ToString.Exclude
    private String password = "secret";

    public static void main(String[] args) {
        System.out.println(new ToStringExample());
    }
}
```
```java
// Example with explicit inclusion
@ToString(onlyExplicitlyIncluded = true)
public class ToStringExplicitExample {
    @ToString.Include // Only this field is included
    private String name = "Bob";

    @ToString.Include(name = "isActive") // Rename the field in the output
    private boolean active = true;

    private int age = 25; // This will NOT be included in toString()

    public static void main(String[] args) {
        // Output: ToStringExplicitExample(name=Bob, isActive=true)
        System.out.println(new ToStringExplicitExample());
    }
}
```

---

#### 5. `@NoArgsConstructor`, `@RequiredArgsConstructor`, `@AllArgsConstructor`
*   **`@NoArgsConstructor`:** Generates a constructor with no parameters.
*   **`@AllArgsConstructor`:** Generates a constructor with one parameter for each **non-static** field in the class.
*   **`@RequiredArgsConstructor`:** Generates a constructor with parameters for all **`final`** fields and fields marked with **`@NonNull`**. This is very useful for dependency injection.

**Code Example:**
```java
import lombok.*;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
public class ConstructorExample {
    private String name; // Not final, not @NonNull -> Not in @RequiredArgsConstructor

    @NonNull // This field will be in @RequiredArgsConstructor
    private Integer age;

    private final String id = "DEFAULT_ID"; // Final field -> In @RequiredArgsConstructor

    // The generated constructors will look like:
    // public ConstructorExample() {} // @NoArgsConstructor
    // public ConstructorExample(String name, Integer age) {} // @AllArgsConstructor (includes 'name', 'age', and 'id')
    // public ConstructorExample(Integer age) {} // @RequiredArgsConstructor (only 'age' and 'id')

    public static void main(String[] args) {
        new ConstructorExample(); // No-args
        new ConstructorExample("Alice", 30); // All-args
        new ConstructorExample(30); // Required-args (for @NonNull and final fields)
    }
}
```
**Note on `@NonNull`:** When used on a field, `@NonNull` in a constructor also generates the null-check, just like it does on a method parameter.

---

#### 6. `@EqualsAndHashCode`
*   **Purpose:** Generates `equals()` and `hashCode()` methods following the Java contract.
*   **Default:** Uses all **non-static, non-transient** fields.
*   **Control:** You can `exclude` fields or use `onlyExplicitlyIncluded`.

**Code Example:**
```java
import lombok.EqualsAndHashCode;

@EqualsAndHashCode // Uses all fields: name, committeeMember, age. Excludes password.
public class EqualsHashCodeExample {
    private String name;
    private boolean committeeMember;
    private int age;

    @EqualsAndHashCode.Exclude // Exclude this field from equals/hashCode
    private String password;

    // Two objects are equal only if name, committeeMember, and age are equal.
    // Their password can be different, and they will still be considered equal.
}
```

---

#### 7. `@Data`
*   **Purpose:** A powerful shortcut that combines:
    *   `@Getter` (on all fields)
    *   `@Setter` (on all non-`final` fields)
    *   `@ToString`
    *   `@EqualsAndHashCode`
    *   `@RequiredArgsConstructor`
*   **Use Case:** The perfect annotation for standard **Data Transfer Objects (DTOs)** or **POJOs**.

**Code Example:**
```java
import lombok.Data;
import lombok.NonNull;

@Data // All-in-one annotation!
public class UserDto {
    private Long id;
    private String name;
    @NonNull
    private String email;
    private final String creationDate = "2023-10-27"; // Final -> Getter, but no Setter

    // This one annotation generates:
    // - getId(), setId(), getName(), setName(), getEmail(), setEmail(), getCreationDate()
    // - equals(), hashCode()
    // - toString()
    // - A required-args constructor for the @NonNull 'email' and final 'creationDate' field
}
```

---

#### 8. `@Value`
*   **Purpose:** The immutable variant of `@Data`.
*   **What it does:**
    *   Makes the class itself `final`.
    *   Makes all fields `private final`.
    *   Generates getters, but **NO setters**.
    *   Generates `toString()`, `equals()`, and `hashCode()`.
    *   Generates an all-args constructor.
*   **Use Case:** For creating **immutable value objects**.

**Code Example:**
```java
import lombok.Value;

@Value
// @Value is shorthand for:
// final @Getter @FieldDefaults(makeFinal=true, level=AccessLevel.PRIVATE)
// @AllArgsConstructor @ToString @EqualsAndHashCode
public class ImmutablePoint {
    int x;
    int y;
    String name;

    // This class is now immutable. You can't change x, y, or name after construction.
    // Usage: ImmutablePoint p = new ImmutablePoint(5, 10, "Origin");
    // int xCoord = p.getX();
}
```

---

#### 9. `@Builder`
*   **Purpose:** Implements the **Builder Pattern**, which is excellent for creating objects with many optional fields in a readable way.
*   **How it works:** Creates a static inner builder class. You chain setter calls together and finish with `.build()`.

**Code Example:**
```java
import lombok.Builder;
import lombok.ToString;

@Builder
@ToString
public class Product {
    private final String sku; // Required
    private String name;
    private String description;
    private double price;

    public static void main(String[] args) {
        // Create a Product using the builder. Fields can be set in any order.
        Product laptop = Product.builder()
                .sku("LAPTOP-123")
                .name("Gaming Laptop")
                .price(1299.99)
                // .description(...) // Optional: we skip it
                .build(); // Final call to construct the object

        System.out.println(laptop); // Uses @ToString
        // Output: Product(sku=LAPTOP-123, name=Gaming Laptop, description=null, price=1299.99)
    }
}
```

---

#### 10. `@Cleanup`
*   **Purpose:** Ensures automatic resource cleanup. It's a safer alternative to a try-with-resources statement.
*   **How it works:** Annotate any local variable declaration for a resource (like an `InputStream`). Lombok will generate a `finally` block that calls `.close()` on that resource.

**Code Example:**
```java
import lombok.Cleanup;
import java.io.*;

public class CleanupExample {
    public static void main(String[] args) throws IOException {
        // @Cleanup ensures the InputStream is closed at the end of the scope
        @Cleanup InputStream input = new FileInputStream("input.txt");
        @Cleanup OutputStream output = new FileOutputStream("output.txt");

        byte[] buffer = new byte[1024];
        int length;
        while ((length = input.read(buffer)) != -1) {
            output.write(buffer, 0, length);
        }
        // Lombok adds a finally block here to call input.close() and output.close()
    }
}
```
**What the compiled code looks like:**
```java
public class CleanupExample {
    public static void main(String[] args) throws IOException {
        InputStream input = new FileInputStream("input.txt");
        try {
            OutputStream output = new FileOutputStream("output.txt");
            try {
                // ... copy logic ...
            } finally {
                if (output != null) {
                    output.close();
                }
            }
        } finally {
            if (input != null) {
                input.close();
            }
        }
    }
}
```

By using these annotations, you can dramatically reduce boilerplate, make your code more readable, and minimize human error, making Lombok an indispensable tool for modern Java development.