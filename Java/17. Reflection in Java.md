# **Java Reflection - Comprehensive Guide**

## **1. What is Reflection?**
Reflection in Java is a powerful feature that allows a program to examine or inspect its own structure (classes, methods, fields, interfaces) **at runtime** and even modify their behavior dynamically.

### **Key Capabilities of Reflection:**
1. **Examine** class structure (methods, fields, constructors, modifiers).
2. **Invoke methods** dynamically.
3. **Access and modify fields** (even private ones).
4. **Create objects** (even if constructors are private).
5. **Analyze annotations** at runtime.

### **Why Use Reflection?**
- Used in **frameworks** (Spring, Hibernate, JUnit) for dynamic class loading.
- Useful for **debugging and testing**.
- Used in **serialization/deserialization** (e.g., JSON parsers).

### **Why Avoid Reflection?**
1. **Breaks Encapsulation:** Can access private fields/methods.
2. **Performance Overhead:** Slower than direct method calls.
3. **Security Risks:** Can bypass access controls.

---

## **2. How Reflection Works?**
To perform reflection, we use the **`java.lang.reflect`** package and the **`Class`** class.

### **2.1. The `Class` Object**
- Every class loaded by JVM has a **`Class`** object associated with it.
- This object contains **metadata** about the class (methods, fields, constructors, etc.).
- JVM creates this object automatically when a class is loaded.

### **2.2. Ways to Get a `Class` Object**
There are **3 ways** to obtain a `Class` object:

#### **1. Using `Class.forName()`**
```java
Class<?> eagleClass = Class.forName("Eagle"); // Full class name with package
```

#### **2. Using `.class` Syntax**
```java
Class<Eagle> eagleClass = Eagle.class;
```

#### **3. Using `getClass()` on an Object**
```java
Eagle eagle = new Eagle();
Class<?> eagleClass = eagle.getClass();
```

---

## **3. Reflection Examples**

### **3.1. Reflecting a Class (Getting Metadata)**
```java
import java.lang.reflect.*;

public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        // Get Class object
        Class<?> eagleClass = Eagle.class;

        // Get class name
        System.out.println("Class Name: " + eagleClass.getName());

        // Get modifiers (public, private, etc.)
        int modifiers = eagleClass.getModifiers();
        System.out.println("Modifiers: " + Modifier.toString(modifiers));

        // Get all declared fields (including private)
        Field[] fields = eagleClass.getDeclaredFields();
        System.out.println("\nFields:");
        for (Field field : fields) {
            System.out.println(field.getName() + " (" + field.getType() + ")");
        }

        // Get all declared methods
        Method[] methods = eagleClass.getDeclaredMethods();
        System.out.println("\nMethods:");
        for (Method method : methods) {
            System.out.println(method.getName() + " -> Returns: " + method.getReturnType());
        }
    }
}
```

**Output:**
```
Class Name: Eagle
Modifiers: public

Fields:
breed (String)
canSwim (boolean)

Methods:
fly -> Returns: void
eat -> Returns: void
```

---

### **3.2. Reflecting Methods**
#### **a) Getting Public Methods**
```java
Method[] methods = eagleClass.getMethods(); // Includes inherited methods (e.g., from Object)
```

#### **b) Getting All Methods (Including Private)**
```java
Method[] allMethods = eagleClass.getDeclaredMethods();
```

#### **c) Invoking a Method Dynamically**
```java
Eagle eagle = new Eagle();
Method flyMethod = eagleClass.getDeclaredMethod("fly", int.class, boolean.class, String.class);
flyMethod.invoke(eagle, 1, true, "Hello");
```

---

### **3.3. Reflecting Fields**
#### **a) Getting Public Fields**
```java
Field[] publicFields = eagleClass.getFields(); // Only public fields
```

#### **b) Getting All Fields (Including Private)**
```java
Field[] allFields = eagleClass.getDeclaredFields();
```

#### **c) Modifying Field Values (Even Private)**
```java
Eagle eagle = new Eagle();
Field breedField = eagleClass.getDeclaredField("breed");
breedField.set(eagle, "Eagle Brown"); // Set public field

Field canSwimField = eagleClass.getDeclaredField("canSwim");
canSwimField.setAccessible(true); // Bypass private access
canSwimField.set(eagle, true); // Set private field
```

---

### **3.4. Reflecting Constructors (Breaking Singleton)**
#### **a) Getting Constructors**
```java
Constructor<?>[] constructors = eagleClass.getDeclaredConstructors();
```

#### **b) Creating an Object Using Private Constructor**
```java
Constructor<Eagle> privateConstructor = Eagle.class.getDeclaredConstructor();
privateConstructor.setAccessible(true); // Bypass private access
Eagle newEagle = privateConstructor.newInstance(); // Creates new instance
```

**This breaks Singleton!**  
To prevent this, use **enum-based Singleton** or **throw an exception in the constructor** if an instance already exists.

---

## **4. Performance & Security Concerns**
1. **Reflection is slow** because it resolves types at runtime.
2. **Security risk:** Can bypass `private` access.
3. **Not recommended for general use**—only when necessary (e.g., frameworks).

---

## **5. Summary Table**
| Action | Method |
|--------|--------|
| Get `Class` object | `Class.forName()`, `.class`, `getClass()` |
| Get fields | `getFields()` (public), `getDeclaredFields()` (all) |
| Get methods | `getMethods()` (public), `getDeclaredMethods()` (all) |
| Get constructors | `getConstructors()`, `getDeclaredConstructors()` |
| Invoke method | `method.invoke(obj, args)` |
| Modify field | `field.set(obj, value)` |
| Bypass private access | `setAccessible(true)` |

---

## **6. Conclusion**
- Reflection is powerful but **should be used sparingly**.
- Helps in **dynamic programming** (frameworks, testing).
- **Breaks encapsulation**—avoid unless necessary.
- **Slower** than direct method calls.
