# Java Sealed Classes and Interfaces (Java 17)

I'll create a complete code example demonstrating sealed classes and interfaces with detailed explanations.

## Project Structure
```
src/
└── com/
    └── example/
        ├── Main.java
        ├── shapes/
        │   ├── Shape.java
        │   ├── Circle.java
        │   ├── Polygon.java
        │   ├── Hexagon.java
        │   ├── AbstractShape.java
        │   ├── Rectangle.java
        │   └── Triangle.java
        └── special/
            └── RightTriangle.java
```

## Code Implementation

### 1. Shape.java (Sealed Interface)
```java
package com.example.shapes;

// Sealed interface with permits clause
public sealed interface Shape 
    permits Circle, Polygon, AbstractShape {
    
    double area();
    double perimeter();
}
```

### 2. Circle.java (Final Class)
```java
package com.example.shapes;

// Final implementation - no further inheritance allowed
public final class Circle implements Shape {
    private final double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double perimeter() {
        return 2 * Math.PI * radius;
    }
    
    public double getRadius() {
        return radius;
    }
}
```

### 3. Polygon.java (Non-sealed Interface)
```java
package com.example.shapes;

// Non-sealed interface - open for extension
public non-sealed interface Polygon extends Shape {
    int getSides();
}
```

### 4. Hexagon.java (Final Class implementing Polygon)
```java
package com.example.shapes;

// Final implementation of Polygon
public final class Hexagon implements Polygon {
    private final double sideLength;
    
    public Hexagon(double sideLength) {
        this.sideLength = sideLength;
    }
    
    @Override
    public double area() {
        return (3 * Math.sqrt(3) * sideLength * sideLength) / 2;
    }
    
    @Override
    public double perimeter() {
        return 6 * sideLength;
    }
    
    @Override
    public int getSides() {
        return 6;
    }
    
    public double getSideLength() {
        return sideLength;
    }
}
```

### 5. AbstractShape.java (Sealed Abstract Class)
```java
package com.example.shapes;

// Sealed abstract class with permits clause
public abstract sealed class AbstractShape implements Shape 
    permits Rectangle, Triangle {
    
    protected String color;
    
    public AbstractShape(String color) {
        this.color = color;
    }
    
    public String getColor() {
        return color;
    }
    
    public void setColor(String color) {
        this.color = color;
    }
}
```

### 6. Rectangle.java (Final Class)
```java
package com.example.shapes;

// Final implementation
public final class Rectangle extends AbstractShape {
    private final double width;
    private final double height;
    
    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double area() {
        return width * height;
    }
    
    @Override
    public double perimeter() {
        return 2 * (width + height);
    }
    
    public double getWidth() {
        return width;
    }
    
    public double getHeight() {
        return height;
    }
}
```

### 7. Triangle.java (Non-sealed Class)
```java
package com.example.shapes;

// Non-sealed class - open for extension
public non-sealed class Triangle extends AbstractShape {
    protected final double base;
    protected final double height;
    
    public Triangle(String color, double base, double height) {
        super(color);
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double area() {
        return 0.5 * base * height;
    }
    
    @Override
    public double perimeter() {
        // Simplified for demonstration
        return base + height + Math.sqrt(base * base + height * height);
    }
    
    public double getBase() {
        return base;
    }
    
    public double getHeight() {
        return height;
    }
}
```

### 8. RightTriangle.java (Extended from Triangle)
```java
package com.example.special;

import com.example.shapes.Triangle;

// Can extend Triangle because it's non-sealed
public class RightTriangle extends Triangle {
    
    public RightTriangle(String color, double base, double height) {
        super(color, base, height);
    }
    
    @Override
    public double perimeter() {
        return base + height + Math.sqrt(base * base + height * height);
    }
    
    public double getHypotenuse() {
        return Math.sqrt(base * base + height * height);
    }
}
```

### 9. Main.java (Demo Class)
```java
package com.example;

import com.example.shapes.*;
import com.example.special.RightTriangle;

public class Main {
    public static void main(String[] args) {
        // Create instances of different shapes
        Shape circle = new Circle(5.0);
        Shape hexagon = new Hexagon(4.0);
        Shape rectangle = new Rectangle("Red", 3.0, 4.0);
        Shape triangle = new Triangle("Blue", 3.0, 4.0);
        Shape rightTriangle = new RightTriangle("Green", 3.0, 4.0);
        
        // Process shapes using pattern matching (Java 17 feature)
        processShape(circle);
        processShape(hexagon);
        processShape(rectangle);
        processShape(triangle);
        processShape(rightTriangle);
    }
    
    public static void processShape(Shape shape) {
        // Pattern matching for switch (Java 17 feature)
        switch (shape) {
            case Circle c -> 
                System.out.printf("Circle: radius=%.2f, area=%.2f%n", 
                    c.getRadius(), c.area());
                    
            case Hexagon h -> 
                System.out.printf("Hexagon: sides=%d, area=%.2f%n", 
                    h.getSides(), h.area());
                    
            case Rectangle r -> 
                System.out.printf("Rectangle: %s, area=%.2f%n", 
                    r.getColor(), r.area());
                    
            case Triangle t -> 
                System.out.printf("Triangle: %s, area=%.2f%n", 
                    t.getColor(), t.area());
                    
            // No default needed - we've exhausted all possibilities!
            // This is the power of sealed classes - exhaustive pattern matching
        }
    }
}
```

## Key Benefits Explained

1. **Controlled Inheritance**: The `sealed` keyword with `permits` clause restricts which classes can implement/extend a type.

2. **Exhaustive Pattern Matching**: With sealed hierarchies, the compiler knows all possible subclasses, enabling exhaustive checks in switch statements.

3. **Three Inheritance Modifiers**:
   - `final`: No further inheritance allowed
   - `sealed`: Further inheritance allowed but restricted
   - `non-sealed`: Open for unlimited inheritance

4. **Package Restrictions**: Permitted subclasses must be in the same package or named module as the sealed parent.

## Compilation and Execution

To compile and run this code:

```bash
javac -d out src/com/example/**/*.java src/com/example/*.java
java -cp out com.example.Main
```

## Expected Output

```
Circle: radius=5.00, area=78.54
Hexagon: sides=6, area=41.57
Rectangle: Red, area=12.00
Triangle: Blue, area=6.00
Triangle: Green, area=6.00
```

This example demonstrates how sealed classes and interfaces provide control over inheritance hierarchies while enabling powerful pattern matching capabilities in Java 17.