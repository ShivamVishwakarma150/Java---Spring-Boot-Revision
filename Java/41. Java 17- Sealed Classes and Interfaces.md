# Java Sealed Classes & Interfaces - Complete Theory & Notes

## 1. Introduction to Sealed Classes/Interfaces

### What are Sealed Classes/Interfaces?
Sealed classes and interfaces are a new feature introduced in **Java 17** (JEP 409) that allow developers to control which classes can extend or implement them.

### The Problem They Solve
- **Lack of inheritance control**: Before Java 17, any class could extend any non-final class
- **Unplanned hierarchy growth**: Unexpected subclasses could be added to your hierarchy
- **Fragile code**: Methods using instanceof or switch statements might break when new subclasses are added
- **No exhaustive pattern matching**: Compiler couldn't guarantee all cases were handled

## 2. Key Concepts & Syntax

### Basic Syntax
```java
public sealed interface Shape permits Circle, Rectangle, Triangle {
    // interface methods
}
```

### The Three Inheritance Modifiers

1. **`final`** - No further inheritance allowed
   ```java
   public final class Circle implements Shape { }
   ```

2. **`sealed`** - Further inheritance allowed but restricted
   ```java
   public sealed class AbstractShape permits Rectangle, Triangle { }
   ```

3. **`non-sealed`** - Open for unlimited inheritance
   ```java
   public non-sealed class Triangle extends AbstractShape { }
   ```

## 3. Rules and Constraints

### Mandatory Rules
1. **Permits clause required**: Must explicitly declare permitted subclasses
2. **Direct subclasses only**: Permitted classes must be direct descendants
3. **Modifier requirement**: Every permitted subclass must declare its own modifier
4. **Same package/module**: Permitted classes must be accessible to the sealed type

### Package and Module Restrictions
- Permitted subclasses must be in the **same package** (for unnamed modules)
- Or in the **same named module** (for modular applications)

## 4. Benefits and Advantages

### 1. Controlled Inheritance
```java
// Only these three classes can implement Shape
public sealed interface Shape permits Circle, Rectangle, Triangle { }
```

### 2. Exhaustive Pattern Matching
```java
// Compiler knows all possible Shape implementations
double area = switch(shape) {
    case Circle c -> Math.PI * c.radius() * c.radius();
    case Rectangle r -> r.width() * r.height();
    case Triangle t -> 0.5 * t.base() * t.height();
    // No default needed - all cases covered!
};
```

### 3. Better API Design
- Clearly communicate intended inheritance hierarchy
- Prevent misuse of your classes
- Enable compiler verification of pattern matching

### 4. Enhanced Maintainability
- Know exactly which subclasses exist
- Safe to add new methods to sealed hierarchy
- Easier to reason about code

## 5. Use Cases and Examples

### Mathematical Expressions
```java
public sealed interface Expr 
    permits ConstantExpr, PlusExpr, TimesExpr, NegExpr { }

public final class ConstantExpr implements Expr { }
public final class PlusExpr implements Expr { }
public final class TimesExpr implements Expr { }
public final class NegExpr implements Expr { }
```

### JSON Node Hierarchy
```java
public sealed interface JsonNode 
    permits JsonObject, JsonArray, JsonString, JsonNumber, JsonBoolean, JsonNull { }
```

### UI Component Hierarchy
```java
public sealed class UIControl 
    permits Button, TextField, Checkbox, Slider { }
```

## 6. Comparison with Traditional Inheritance

| Aspect | Traditional Classes | Sealed Classes |
|--------|---------------------|----------------|
| Inheritance | Unlimited | Controlled |
| Pattern Matching | Requires default case | Exhaustive |
| API Stability | Fragile | Robust |
| Intent Communication | Implicit | Explicit |

## 7. Pattern Matching with Sealed Classes

### Before Java 17
```java
if (shape instanceof Circle) {
    // handle circle
} else if (shape instanceof Rectangle) {
    // handle rectangle
} else {
    // default case - might hide bugs!
}
```

### With Sealed Classes (Java 17+)
```java
// Compiler verifies all cases are handled
return switch(shape) {
    case Circle c -> processCircle(c);
    case Rectangle r -> processRectangle(r);
    case Triangle t -> processTriangle(t);
};
```

## 8. Migration Considerations

### Converting Existing Hierarchies
1. Identify the root class/interface to make sealed
2. Determine which subclasses should be permitted
3. Add appropriate modifiers to all subclasses
4. Update pattern matching code to remove default cases

### Compatibility
- Sealed classes are **binary compatible** with existing code
- Existing subclasses outside the permits clause will cause compile errors
- No runtime performance impact

## 9. Best Practices

### 1. Design for Exhaustiveness
```java
// Good design - finite number of subclasses
public sealed interface PaymentMethod 
    permits CreditCard, PayPal, BankTransfer { }
```

### 2. Use Meaningful Names
```java
// Clearly communicate the hierarchy purpose
public sealed interface AstNode 
    permits ClassDecl, MethodDecl, FieldDecl, ExprStmt { }
```

### 3. Prefer Interfaces for Flexibility
```java
// Interface-based sealed hierarchy
public sealed interface Shape permits Circle, Rectangle { }
public non-sealed interface Polygon extends Shape { }
```

### 4. Document Intent
```java
/**
 * Represents mathematical expressions.
 * Only these implementations are allowed:
 * - ConstantExpr: Constant values
 * - PlusExpr: Addition operations
 * - TimesExpr: Multiplication operations
 * - NegExpr: Negation operations
 */
public sealed interface Expr 
    permits ConstantExpr, PlusExpr, TimesExpr, NegExpr { }
```

## 10. Common Pitfalls and Solutions

### Problem: Forgetting Modifiers
```java
// ERROR: Permitted subclass must have modifier
public class Rectangle implements Shape { } // Missing final, sealed, or non-sealed

// SOLUTION: Add appropriate modifier
public final class Rectangle implements Shape { }
```

### Problem: Package Visibility
```java
// ERROR: Permitted class in different package
public sealed interface Shape permits com.other.Circle { }

// SOLUTION: Keep in same package or use modules
```

### Problem: Indirect Inheritance
```java
// ERROR: Triangle is not a direct subclass
public sealed class AbstractShape permits Rectangle { }
public class Triangle extends AbstractShape { } // Not permitted

// SOLUTION: Add to permits clause or make direct
```

## 11. Advanced Topics

### Sealed Interfaces with Records
```java
public sealed interface Shape permits Circle, Rectangle { }

public record Circle(double radius) implements Shape { }
public record Rectangle(double width, double height) implements Shape { }
```

### Sealed Classes with Generic Types
```java
public sealed interface Result<T> permits Success, Failure { }

public final class Success<T> implements Result<T> { }
public final class Failure<T> implements Result<T> { }
```

### Reflective Access
```java
// Check if a class is sealed
if (Shape.class.isSealed()) {
    Class<?>[] permittedSubclasses = Shape.class.getPermittedSubclasses();
}
```

## Summary Table

| Feature | Description | Benefit |
|---------|-------------|---------|
| `sealed` | Restricts inheritance | Control over hierarchy |
| `permits` | Lists allowed subclasses | Explicit intent |
| `final` | No further inheritance | Terminal nodes |
| `non-sealed` | Opens for extension | Flexible branches |
| Exhaustive matching | Compiler verifies all cases | Safer code |

Sealed classes and interfaces represent a significant enhancement to Java's type system, enabling more expressive domain modeling while maintaining type safety and code reliability.

<br/>
<br/>

# Java Sealed Classes and Interfaces (Java 17)

## Project Structure
```
src/
└── com/
    └── example/
        ├── Main.java
        ├── shapes/
        │   ├── Shape.java
        │   ├── Circle.java
        │   ├── Polygon.java
        │   ├── Hexagon.java
        │   ├── AbstractShape.java
        │   ├── Rectangle.java
        │   └── Triangle.java
        └── special/
            └── RightTriangle.java
```

## Code Implementation

### 1. Shape.java (Sealed Interface)
```java
package com.example.shapes;

// Sealed interface with permits clause
public sealed interface Shape 
    permits Circle, Polygon, AbstractShape {
    
    double area();
    double perimeter();
}
```

### 2. Circle.java (Final Class)
```java
package com.example.shapes;

// Final implementation - no further inheritance allowed
public final class Circle implements Shape {
    private final double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double perimeter() {
        return 2 * Math.PI * radius;
    }
    
    public double getRadius() {
        return radius;
    }
}
```

### 3. Polygon.java (Non-sealed Interface)
```java
package com.example.shapes;

// Non-sealed interface - open for extension
public non-sealed interface Polygon extends Shape {
    int getSides();
}
```

### 4. Hexagon.java (Final Class implementing Polygon)
```java
package com.example.shapes;

// Final implementation of Polygon
public final class Hexagon implements Polygon {
    private final double sideLength;
    
    public Hexagon(double sideLength) {
        this.sideLength = sideLength;
    }
    
    @Override
    public double area() {
        return (3 * Math.sqrt(3) * sideLength * sideLength) / 2;
    }
    
    @Override
    public double perimeter() {
        return 6 * sideLength;
    }
    
    @Override
    public int getSides() {
        return 6;
    }
    
    public double getSideLength() {
        return sideLength;
    }
}
```

### 5. AbstractShape.java (Sealed Abstract Class)
```java
package com.example.shapes;

// Sealed abstract class with permits clause
public abstract sealed class AbstractShape implements Shape 
    permits Rectangle, Triangle {
    
    protected String color;
    
    public AbstractShape(String color) {
        this.color = color;
    }
    
    public String getColor() {
        return color;
    }
    
    public void setColor(String color) {
        this.color = color;
    }
}
```

### 6. Rectangle.java (Final Class)
```java
package com.example.shapes;

// Final implementation
public final class Rectangle extends AbstractShape {
    private final double width;
    private final double height;
    
    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double area() {
        return width * height;
    }
    
    @Override
    public double perimeter() {
        return 2 * (width + height);
    }
    
    public double getWidth() {
        return width;
    }
    
    public double getHeight() {
        return height;
    }
}
```

### 7. Triangle.java (Non-sealed Class)
```java
package com.example.shapes;

// Non-sealed class - open for extension
public non-sealed class Triangle extends AbstractShape {
    protected final double base;
    protected final double height;
    
    public Triangle(String color, double base, double height) {
        super(color);
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double area() {
        return 0.5 * base * height;
    }
    
    @Override
    public double perimeter() {
        // Simplified for demonstration
        return base + height + Math.sqrt(base * base + height * height);
    }
    
    public double getBase() {
        return base;
    }
    
    public double getHeight() {
        return height;
    }
}
```

### 8. RightTriangle.java (Extended from Triangle)
```java
package com.example.special;

import com.example.shapes.Triangle;

// Can extend Triangle because it's non-sealed
public class RightTriangle extends Triangle {
    
    public RightTriangle(String color, double base, double height) {
        super(color, base, height);
    }
    
    @Override
    public double perimeter() {
        return base + height + Math.sqrt(base * base + height * height);
    }
    
    public double getHypotenuse() {
        return Math.sqrt(base * base + height * height);
    }
}
```

### 9. Main.java (Demo Class)
```java
package com.example;

import com.example.shapes.*;
import com.example.special.RightTriangle;

public class Main {
    public static void main(String[] args) {
        // Create instances of different shapes
        Shape circle = new Circle(5.0);
        Shape hexagon = new Hexagon(4.0);
        Shape rectangle = new Rectangle("Red", 3.0, 4.0);
        Shape triangle = new Triangle("Blue", 3.0, 4.0);
        Shape rightTriangle = new RightTriangle("Green", 3.0, 4.0);
        
        // Process shapes using pattern matching (Java 17 feature)
        processShape(circle);
        processShape(hexagon);
        processShape(rectangle);
        processShape(triangle);
        processShape(rightTriangle);
    }
    
    public static void processShape(Shape shape) {
        // Pattern matching for switch (Java 17 feature)
        switch (shape) {
            case Circle c -> 
                System.out.printf("Circle: radius=%.2f, area=%.2f%n", 
                    c.getRadius(), c.area());
                    
            case Hexagon h -> 
                System.out.printf("Hexagon: sides=%d, area=%.2f%n", 
                    h.getSides(), h.area());
                    
            case Rectangle r -> 
                System.out.printf("Rectangle: %s, area=%.2f%n", 
                    r.getColor(), r.area());
                    
            case Triangle t -> 
                System.out.printf("Triangle: %s, area=%.2f%n", 
                    t.getColor(), t.area());
                    
            // No default needed - we've exhausted all possibilities!
            // This is the power of sealed classes - exhaustive pattern matching
        }
    }
}
```

## Key Benefits Explained

1. **Controlled Inheritance**: The `sealed` keyword with `permits` clause restricts which classes can implement/extend a type.

2. **Exhaustive Pattern Matching**: With sealed hierarchies, the compiler knows all possible subclasses, enabling exhaustive checks in switch statements.

3. **Three Inheritance Modifiers**:
   - `final`: No further inheritance allowed
   - `sealed`: Further inheritance allowed but restricted
   - `non-sealed`: Open for unlimited inheritance

4. **Package Restrictions**: Permitted subclasses must be in the same package or named module as the sealed parent.

## Compilation and Execution

To compile and run this code:

```bash
javac -d out src/com/example/**/*.java src/com/example/*.java
java -cp out com.example.Main
```

## Expected Output

```
Circle: radius=5.00, area=78.54
Hexagon: sides=6, area=41.57
Rectangle: Red, area=12.00
Triangle: Blue, area=6.00
Triangle: Green, area=6.00
```

This example demonstrates how sealed classes and interfaces provide control over inheritance hierarchies while enabling powerful pattern matching capabilities in Java 17.