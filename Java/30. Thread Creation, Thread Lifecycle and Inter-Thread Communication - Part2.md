# **Multithreading in Java - Part 2: Thread Creation, Synchronization, and Inter-Thread Communication**

In this guide, we'll cover:
1. **Two Ways to Create a Thread**  
   - Extending `Thread` class  
   - Implementing `Runnable` interface  
2. **Thread Lifecycle**  
3. **Synchronization (Monitor Locks)**  
4. **Inter-Thread Communication (`wait`, `notify`, `notifyAll`)**  
5. **Producer-Consumer Problem (Assignment & Solution)**  

---

## **1. Two Ways to Create a Thread**
### **1.1 Extending `Thread` Class**
```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread executed: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // Starts the thread (calls run())
    }
}
```
**Why not preferred?**  
- Java doesnâ€™t support multiple inheritance.  
- If your class already extends another class, you canâ€™t extend `Thread`.  

---

### **1.2 Implementing `Runnable` (Preferred)**
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread executed: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start();
    }
}
```
**Why preferred?**  
- Allows extending another class.  
- More flexible (Lambda can be used).  

---

## **2. Thread Lifecycle**
1. **New**: `Thread t = new Thread();`  
2. **Runnable**: `t.start()` â†’ Thread is ready to run.  
3. **Running**: Executing `run()`.  
4. **Blocked/Waiting**:  
   - `wait()` â†’ Releases lock, waits for `notify()`.  
   - `sleep(ms)` â†’ Doesnâ€™t release lock.  
5. **Terminated**: `run()` completes.  

---

## **3. Synchronization (Monitor Locks)**
- Every Java object has a **monitor lock**.  
- `synchronized` ensures only one thread accesses a block/method at a time.  

### **Example: Synchronized Block**
```java
class SharedResource {
    synchronized void task1() {
        System.out.println("Task 1 started");
        try { Thread.sleep(2000); } catch (Exception e) {}
        System.out.println("Task 1 completed");
    }

    void task2() {
        System.out.println("Task 2 (before sync)");
        synchronized (this) {
            System.out.println("Task 2 (inside sync)");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource obj = new SharedResource();
        
        Thread t1 = new Thread(() -> obj.task1());
        Thread t2 = new Thread(() -> obj.task2());
        
        t1.start();
        t2.start();
    }
}
```
**Output:**  
```
Task 1 started  
Task 2 (before sync)  
Task 1 completed  
Task 2 (inside sync)  
```
- `t1` locks `obj` â†’ `t2` waits for lock.  

---

## **4. Inter-Thread Communication (`wait`, `notify`)**
### **Example: Producer-Consumer**
```java
class SharedResource {
    boolean itemAvailable = false;

    synchronized void produce() {
        itemAvailable = true;
        System.out.println("Producer produced item.");
        notify(); // Wakes up waiting thread
    }

    synchronized void consume() {
        while (!itemAvailable) {
            try {
                wait(); // Releases lock, waits for notify()
            } catch (Exception e) {}
        }
        itemAvailable = false;
        System.out.println("Consumer consumed item.");
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Thread producer = new Thread(() -> {
            try { Thread.sleep(1000); } catch (Exception e) {}
            resource.produce();
        });

        Thread consumer = new Thread(() -> resource.consume());

        producer.start();
        consumer.start();
    }
}
```
**Output:**  
```
Producer produced item.  
Consumer consumed item.  
```
- **`wait()`**: Releases lock, waits for `notify()`.  
- **`notify()`**: Wakes up one waiting thread.  
- **`notifyAll()`**: Wakes up all waiting threads.  

---

## **5. Producer-Consumer Problem (Assignment Solution)**
### **Problem:**  
- Producer adds items to a **fixed-size queue**.  
- Consumer removes items.  
- Producer **waits** if queue is full.  
- Consumer **waits** if queue is empty.  

### **Solution:**
```java
import java.util.LinkedList;
import java.util.Queue;

class SharedBuffer {
    private Queue<Integer> queue = new LinkedList<>();
    private final int CAPACITY = 5;

    synchronized void produce(int item) throws InterruptedException {
        while (queue.size() == CAPACITY) {
            wait(); // Wait if queue is full
        }
        queue.add(item);
        System.out.println("Produced: " + item);
        notify(); // Notify consumer
    }

    synchronized void consume() throws InterruptedException {
        while (queue.isEmpty()) {
            wait(); // Wait if queue is empty
        }
        int item = queue.poll();
        System.out.println("Consumed: " + item);
        notify(); // Notify producer
    }
}

public class Main {
    public static void main(String[] args) {
        SharedBuffer buffer = new SharedBuffer();

        Thread producer = new Thread(() -> {
            int i = 0;
            while (true) {
                try {
                    buffer.produce(i++);
                    Thread.sleep(1000);
                } catch (Exception e) {}
            }
        });

        Thread consumer = new Thread(() -> {
            while (true) {
                try {
                    buffer.consume();
                    Thread.sleep(2000);
                } catch (Exception e) {}
            }
        });

        producer.start();
        consumer.start();
    }
}
```
**Key Points:**  
- `while` loop checks queue status (avoid **spurious wakeups**).  
- `wait()` releases lock.  
- `notify()` signals the other thread.  

---

## **6. Stopping a Thread (Deprecated `stop()`)**
### **Safe Way to Stop a Thread**
```java
class MyThread extends Thread {
    private volatile boolean running = true;

    public void stopThread() {
        running = false;
    }

    @Override
    public void run() {
        while (running) {
            System.out.println("Running...");
            try { Thread.sleep(1000); } catch (Exception e) {}
        }
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        MyThread thread = new MyThread();
        thread.start();
        Thread.sleep(5000);
        thread.stopThread(); // Gracefully stops
    }
}
```
- **`volatile`** ensures visibility across threads.  
- **`stopThread()`** safely terminates the loop.  

---

## **Conclusion**
âœ… **Thread Creation**: Prefer `Runnable` over `Thread`.  
âœ… **Synchronization**: Use `synchronized` blocks/methods.  
âœ… **Inter-Thread Communication**: `wait()`, `notify()`, `notifyAll()`.  
âœ… **Producer-Consumer**: Fixed-size buffer with `wait/notify`.  
âœ… **Stopping Threads**: Avoid `stop()`, use a flag instead.  

Try implementing the **Producer-Consumer Problem** before checking the solution! ðŸš€