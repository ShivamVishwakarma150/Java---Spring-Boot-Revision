# **Comprehensive Explanation of Deque, List, and Their Implementations in Java**

This guide covers:
1. **Deque (Double-Ended Queue)**
2. **List Interface & Implementations (ArrayList, LinkedList)**
3. **Thread-Safe Alternatives (Vector, Stack, CopyOnWriteArrayList)**
4. **Performance & Use Cases**

---

## **1. Deque (Double-Ended Queue)**
A **Deque** allows insertion and removal from **both ends** (front and rear). It extends the `Queue` interface.

### **Key Methods in Deque**
| Method | Behavior |
|--------|----------|
| `addFirst(E e)` | Inserts at front, throws exception if fails |
| `offerFirst(E e)` | Inserts at front, returns `false` if fails |
| `addLast(E e)` | Inserts at rear, throws exception if fails |
| `offerLast(E e)` | Inserts at rear, returns `false` if fails |
| `removeFirst()` | Removes from front, throws exception if empty |
| `pollFirst()` | Removes from front, returns `null` if empty |
| `removeLast()` | Removes from rear, throws exception if empty |
| `pollLast()` | Removes from rear, returns `null` if empty |
| `getFirst()` | Retrieves front element, throws exception if empty |
| `peekFirst()` | Retrieves front element, returns `null` if empty |
| `getLast()` | Retrieves rear element, throws exception if empty |
| `peekLast()` | Retrieves rear element, returns `null` if empty |

### **Implementations**
1. **ArrayDeque** (Resizable array-based)
2. **LinkedList** (Doubly-linked list-based)

#### **Example: ArrayDeque as Queue & Stack**
```java
import java.util.ArrayDeque;
import java.util.Deque;

public class DequeExample {
    public static void main(String[] args) {
        // Using as a Queue (FIFO)
        Deque<Integer> queue = new ArrayDeque<>();
        queue.addLast(1);  // Add to rear
        queue.addLast(2);
        queue.addLast(3);
        System.out.println("Queue (FIFO):");
        while (!queue.isEmpty()) {
            System.out.println(queue.removeFirst()); // Remove from front
        }

        // Using as a Stack (LIFO)
        Deque<Integer> stack = new ArrayDeque<>();
        stack.addFirst(1); // Push to front
        stack.addFirst(2);
        stack.addFirst(3);
        System.out.println("Stack (LIFO):");
        while (!stack.isEmpty()) {
            System.out.println(stack.removeFirst()); // Pop from front
        }
    }
}
```
**Output:**
```
Queue (FIFO):
1
2
3
Stack (LIFO):
3
2
1
```

### **Time Complexity**
| Operation | ArrayDeque | LinkedList |
|-----------|-----------|------------|
| Insert at Front/Back | O(1) (Amortized) | O(1) |
| Remove from Front/Back | O(1) (Amortized) | O(1) |
| Random Access | O(N) | O(N) |

---

## **2. List Interface**
A **List** is an **ordered collection** that allows **duplicates** and **index-based access**.

### **Key Methods in List**
| Method | Behavior |
|--------|----------|
| `add(int index, E e)` | Inserts at index, shifts elements right |
| `addAll(int index, Collection c)` | Inserts collection at index |
| `get(int index)` | Returns element at index |
| `set(int index, E e)` | Replaces element at index |
| `remove(int index)` | Removes element at index, shifts left |
| `indexOf(Object o)` | Returns first occurrence index |
| `lastIndexOf(Object o)` | Returns last occurrence index |
| `listIterator()` | Bidirectional traversal |

### **Implementations**
1. **ArrayList** (Resizable array)
2. **LinkedList** (Doubly-linked list)
3. **Vector** (Thread-safe ArrayList)
4. **Stack** (Thread-safe LIFO structure)

---

## **3. ArrayList vs LinkedList**
### **ArrayList**
- **Backed by an array**.
- **Fast random access** (`O(1)`).
- **Slow insertions/deletions** (`O(N)` due to shifting).

#### **Example: ArrayList**
```java
import java.util.ArrayList;
import java.util.List;

public class ArrayListExample {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(10);
        list.add(20);
        list.add(1, 15); // Insert at index 1
        System.out.println(list); // [10, 15, 20]
        list.remove(1); // Remove at index 1
        System.out.println(list); // [10, 20]
    }
}
```

### **LinkedList**
- **Backed by a doubly-linked list**.
- **Slow random access** (`O(N)`).
- **Fast insertions/deletions** (`O(1)` at ends).

#### **Example: LinkedList as List & Deque**
```java
import java.util.LinkedList;
import java.util.List;

public class LinkedListExample {
    public static void main(String[] args) {
        // As a List
        List<Integer> list = new LinkedList<>();
        list.add(10);
        list.add(20);
        list.add(1, 15); // Insert at index 1
        System.out.println(list); // [10, 15, 20]

        // As a Deque
        LinkedList<Integer> deque = new LinkedList<>();
        deque.addFirst(5); // Insert at front
        deque.addLast(25); // Insert at rear
        System.out.println(deque); // [5, 25]
    }
}
```

---

## **4. Thread-Safe Alternatives**
### **(A) Vector**
- **Synchronized version of ArrayList**.
- **Slower due to locking**.

```java
import java.util.Vector;

public class VectorExample {
    public static void main(String[] args) {
        Vector<Integer> vector = new Vector<>();
        vector.add(10);
        vector.add(20);
        System.out.println(vector); // [10, 20]
    }
}
```

### **(B) Stack (LIFO)**
- **Extends Vector**.
- **Thread-safe but slow**.

```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        stack.push(10); // Insert
        stack.push(20);
        System.out.println(stack.pop()); // 20 (LIFO)
    }
}
```

### **(C) CopyOnWriteArrayList**
- **Thread-safe without locking** (creates new copy on modification).
- **Best for read-heavy scenarios**.

```java
import java.util.concurrent.CopyOnWriteArrayList;

public class CopyOnWriteExample {
    public static void main(String[] args) {
        CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();
        list.add(10);
        list.add(20);
        System.out.println(list); // [10, 20]
    }
}
```

---

## **5. Performance Comparison**
| Operation | ArrayList | LinkedList | Vector | Stack |
|-----------|-----------|------------|--------|-------|
| **Random Access** | O(1) | O(N) | O(1) | O(1) |
| **Insert at End** | O(1) (Amortized) | O(1) | O(1) | O(1) |
| **Insert at Middle** | O(N) | O(N) | O(N) | O(N) |
| **Delete from Middle** | O(N) | O(N) | O(N) | O(N) |
| **Thread Safety** | No | No | Yes | Yes |

---

## **6. When to Use Which?**
1. **Use `ArrayList`** for **frequent reads** and **random access**.
2. **Use `LinkedList`** for **frequent insertions/deletions** (especially at ends).
3. **Use `ArrayDeque`** for **stack/queue operations** (faster than `Stack`/`LinkedList`).
4. **Use `Vector`/`Stack`** only for **legacy thread-safe** needs.
5. **Use `CopyOnWriteArrayList`** for **concurrent read-heavy** scenarios.

---

## **Final Thoughts**
- **Deque (`ArrayDeque`/`LinkedList`)** is versatile (queue + stack).
- **ArrayList** is best for **index-based access**.
- **LinkedList** is best for **frequent modifications**.
- **Thread-safe options (`Vector`, `Stack`, `CopyOnWriteArrayList`)** have trade-offs.

This covers **Deque, List, and their implementations** in depth. ðŸš€