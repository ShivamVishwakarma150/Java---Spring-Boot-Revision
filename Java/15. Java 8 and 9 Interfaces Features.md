# Java 8 and 9 Interface Features Explained

Let me explain the Java 8 and 9 interface features in detail with proper code examples.

## Java 8 Interface Features

### 1. Default Methods

Before Java 8, interfaces could only have abstract methods. Default methods were introduced to allow interfaces to have method implementations.

**Why Default Methods?**
- To add new functionality to existing interfaces without breaking existing implementations
- Particularly useful when Java 8 added the `stream()` method to the `Collection` interface

**Example:**

```java
// Before Java 8 - only abstract methods
interface Bird {
    void canFly(); // abstract method
}

class Eagle implements Bird {
    @Override
    public void canFly() {
        System.out.println("Eagle can fly high");
    }
}

// Java 8 - with default method
interface Bird {
    void canFly(); // abstract method
    
    // Default method with implementation
    default int getMinimumFlyHeight() {
        return 100; // default implementation
    }
}

class Sparrow implements Bird {
    @Override
    public void canFly() {
        System.out.println("Sparrow can fly");
    }
    // No need to implement getMinimumFlyHeight()
}

public class Main {
    public static void main(String[] args) {
        Sparrow sparrow = new Sparrow();
        sparrow.canFly();
        System.out.println("Minimum height: " + sparrow.getMinimumFlyHeight());
    }
}
```

**Multiple Inheritance Problem:**

```java
interface LivingThing {
    default void canBreathe() {
        System.out.println("Living thing can breathe");
    }
}

interface Bird {
    default void canBreathe() {
        System.out.println("Bird can breathe");
    }
}

// Compilation error - must override canBreathe()
class Eagle implements LivingThing, Bird {
    @Override
    public void canBreathe() {
        // Option 1: Use one of the parent implementations
        LivingThing.super.canBreathe();
        
        // Option 2: Provide new implementation
        System.out.println("Eagle can breathe");
    }
}
```

### 2. Static Methods

Java 8 also introduced static methods in interfaces.

**Key Points:**
- Cannot be overridden by implementing classes
- Accessed using interface name only
- Useful for utility methods related to the interface

**Example:**

```java
interface Bird {
    static boolean canFlyHigh(int height) {
        return height > 1000;
    }
    
    default void checkFlightHeight(int height) {
        if (Bird.canFlyHigh(height)) {
            System.out.println("This bird can fly high");
        }
    }
}

class Eagle implements Bird {
    // Cannot override static method
}

public class Main {
    public static void main(String[] args) {
        // Call static method using interface name
        System.out.println(Bird.canFlyHigh(1500)); // true
        
        Eagle eagle = new Eagle();
        eagle.checkFlightHeight(1500); // This bird can fly high
    }
}
```

## Java 9 Interface Features

### 1. Private Methods

Java 9 introduced private methods in interfaces to allow code reuse between default methods.

**Key Points:**
- Can be static or non-static
- Can only be used within the interface
- Improve code reusability and encapsulation

**Example:**

```java
interface Bird {
    // Abstract method
    void canFly();
    
    // Default method
    default void flyInfo() {
        System.out.println(getFlyDetails());
    }
    
    // Private method - reusable code
    private String getFlyDetails() {
        return "Flight details: speed=50km/h, altitude=100m";
    }
    
    // Static method
    static boolean isFlyingAnimal(String name) {
        return checkFlightAbility(name);
    }
    
    // Private static method
    private static boolean checkFlightAbility(String name) {
        return name.equals("Eagle") || name.equals("Sparrow");
    }
}

class Eagle implements Bird {
    @Override
    public void canFly() {
        System.out.println("Eagle can fly");
    }
}

public class Main {
    public static void main(String[] args) {
        Eagle eagle = new Eagle();
        eagle.canFly();
        eagle.flyInfo();
        
        System.out.println(Bird.isFlyingAnimal("Eagle")); // true
        System.out.println(Bird.isFlyingAnimal("Dog"));   // false
    }
}
```

## Complete Example Combining All Features

```java
public class InterfaceFeaturesDemo {
    public static void main(String[] args) {
        Parrot parrot = new Parrot();
        parrot.fly();               // From abstract method
        parrot.defaultFly();        // From default method
        FlyingCreature.staticFly();  // From static method
    }
}

interface FlyingCreature {
    // Abstract method (implicitly public)
    void fly();
    
    // Default method
    default void defaultFly() {
        System.out.println("Default flying implementation");
        privateMethod();
        privateStaticMethod();
    }
    
    // Static method
    static void staticFly() {
        System.out.println("Static flying implementation");
        privateStaticMethod();
        // privateMethod(); // Error - cannot call non-static from static
    }
    
    // Private method
    private void privateMethod() {
        System.out.println("Private method called");
    }
    
    // Private static method
    private static void privateStaticMethod() {
        System.out.println("Private static method called");
    }
}

class Parrot implements FlyingCreature {
    @Override
    public void fly() {
        System.out.println("Parrot flying");
    }
    
    // Can override default method (optional)
    @Override
    public void defaultFly() {
        System.out.println("Parrot's custom default fly");
        FlyingCreature.super.defaultFly(); // Call parent default method
    }
    
    // Cannot override static method
}
```

## Key Takeaways

1. **Default Methods (Java 8):**
   - Allow interfaces to have method implementations
   - Can be overridden by implementing classes
   - Useful for backward compatibility

2. **Static Methods (Java 8):**
   - Cannot be overridden
   - Called using interface name
   - Useful for utility methods

3. **Private Methods (Java 9):**
   - Improve code reusability within interface
   - Can be static or non-static
   - Enhance encapsulation

4. **Rules:**
   - Static methods can only call other static members
   - Non-static methods can call both static and non-static members
   - Private methods cannot be abstract
   - Abstract methods must be public (cannot be private)

These features make interfaces more powerful and flexible while maintaining backward compatibility with existing code.

<br/>
<br/>

# Three Ways to Handle Default Methods in Interfaces

Let me explain the three ways to handle default methods when one interface extends another, as mentioned in the notes. This is particularly important when dealing with inheritance in interfaces.

## Scenario Setup

We have a parent interface with a default method, and a child interface that extends it. The child interface can handle the inherited default method in three different ways.

### 1. Parent Interface

```java
interface LivingThing {
    // Default method in parent interface
    default void canBreathe() {
        System.out.println("Living thing can breathe");
    }
}
```

## Three Ways to Handle Default Method

### Way 1: Do Not Touch (Inherit As-Is)

**Child interface does nothing** - it inherits the default method as-is from the parent.

```java
interface Bird extends LivingThing {
    // No mention of canBreathe()
    // Inherits the default method as-is
}

class Eagle implements Bird {
    // No need to implement canBreathe()
}

public class Main {
    public static void main(String[] args) {
        Eagle eagle = new Eagle();
        eagle.canBreathe(); // Calls parent's default implementation
    }
}
```

**Output:**
```
Living thing can breathe
```

**Key Points:**
- Child interface inherits the default method unchanged
- Implementing classes can use the parent's implementation
- Most straightforward approach when you want to keep the default behavior

### Way 2: Make It Abstract (Force Implementation)

**Child interface redeclares the method as abstract**, forcing implementing classes to provide their own implementation.

```java
interface Bird extends LivingThing {
    // Redeclare as abstract - no implementation
    @Override
    void canBreathe();
}

class Eagle implements Bird {
    // Must implement canBreathe() because it's now abstract
    @Override
    public void canBreathe() {
        System.out.println("Eagle breathes differently");
    }
}

public class Main {
    public static void main(String[] args) {
        Eagle eagle = new Eagle();
        eagle.canBreathe(); // Calls Eagle's implementation
    }
}
```

**Output:**
```
Eagle breathes differently
```

**Key Points:**
- Child interface makes the method abstract
- Implementing classes must provide their own implementation
- Useful when the default implementation isn't appropriate for the child interface

### Way 3: Override with New Default Implementation

**Child interface provides its own default implementation**, which can:
1. Completely replace the parent implementation
2. Extend the parent implementation by calling it

```java
interface Bird extends LivingThing {
    // Override with new default implementation
    @Override
    default void canBreathe() {
        // Option 1: Completely new implementation
        System.out.println("Bird breathes through lungs and air sacs");
        
        // Option 2: Call parent's implementation and add more
        LivingThing.super.canBreathe(); // Call parent's default method
        System.out.println("Additionally, birds have air sacs");
    }
}

class Eagle implements Bird {
    // Can use Bird's default implementation
    // Or optionally override it
}

public class Main {
    public static void main(String[] args) {
        Eagle eagle = new Eagle();
        eagle.canBreathe();
    }
}
```

**Output (Option 1):**
```
Bird breathes through lungs and air sacs
```

**Output (Option 2):**
```
Living thing can breathe
Additionally, birds have air sacs
```

**Key Points:**
- Child interface provides its own default implementation
- Can completely replace or extend parent's implementation
- Uses special syntax `ParentInterface.super.methodName()` to call parent's default method
- Implementing classes can still override this if needed

## Summary Table

| Way | Approach | Syntax | Effect | When to Use |
|-----|----------|--------|--------|-------------|
| 1 | Inherit as-is | No declaration in child interface | Keeps parent's implementation | When default behavior is acceptable |
| 2 | Make abstract | `void canBreathe();` in child interface | Forces implementing classes to provide implementation | When default behavior is inappropriate |
| 3 | Override default | `default void canBreathe() { ... }` in child interface | Provides specialized implementation | When you need modified default behavior |

## Practical Example

```java
interface Vehicle {
    default void startEngine() {
        System.out.println("Starting generic vehicle engine");
    }
}

// Way 1: Inherit as-is
interface Car extends Vehicle {
    // Inherits startEngine() default
}

// Way 2: Make abstract
interface Truck extends Vehicle {
    @Override
    void startEngine(); // Force implementation
}

// Way 3: Override default
interface ElectricVehicle extends Vehicle {
    @Override
    default void startEngine() {
        System.out.println("Starting electric motor");
        Vehicle.super.startEngine(); // Call parent if needed
    }
}

class Sedan implements Car {
    // Uses Vehicle's default startEngine()
}

class Pickup implements Truck {
    @Override
    public void startEngine() {
        System.out.println("Starting diesel engine");
    }
}

class Tesla implements ElectricVehicle {
    // Uses ElectricVehicle's default startEngine()
    // Could optionally override
}

public class Main {
    public static void main(String[] args) {
        new Sedan().startEngine();    // Generic vehicle
        new Pickup().startEngine();  // Diesel engine
        new Tesla().startEngine();    // Electric motor + generic
    }
}
```

**Output:**
```
Starting generic vehicle engine
Starting diesel engine
Starting electric motor
Starting generic vehicle engine
```

This demonstrates how flexible default methods can be in interface hierarchies, allowing you to choose exactly how behavior should be inherited or modified at each level.

<br/>
<br/>

# Static Methods in Interfaces (Java 8+)

Static methods in interfaces were introduced in Java 8 to provide utility methods that belong to the interface itself rather than to instances of the interface. Let me explain this feature in detail with comprehensive examples.

## Key Characteristics of Static Methods in Interfaces

1. **Belong to the Interface, Not Instances**
   - Called using the interface name (e.g., `InterfaceName.staticMethod()`)
   - Cannot be called using interface instances

2. **Cannot Be Overridden**
   - Implementing classes cannot override static methods
   - Not subject to polymorphism

3. **Access Rules**
   - Can only access other static members of the interface
   - Cannot access instance members (default methods or variables)

4. **Visibility**
   - By default public (can explicitly declare public)
   - Cannot be private (until Java 9 introduced private static methods)

## Basic Example

```java
interface Vehicle {
    // Regular abstract method
    void start();
    
    // Static method
    static boolean isRoadworthy(String vehicleType) {
        return vehicleType.equals("Car") || vehicleType.equals("Truck");
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting");
    }
    
    // This is NOT overriding - it's a class static method
    static boolean isRoadworthy(String vehicleType) {
        return false; // Different implementation
    }
}

public class Main {
    public static void main(String[] args) {
        // Calling interface static method
        System.out.println(Vehicle.isRoadworthy("Car")); // true
        System.out.println(Vehicle.isRoadworthy("Bike")); // false
        
        // Cannot call static method through instance
        Car car = new Car();
        // car.isRoadworthy("Car"); // Compile error
        
        // Calls class static method, not interface method
        System.out.println(Car.isRoadworthy("Car")); // false
    }
}
```

## Important Rules and Behaviors

### 1. No Inheritance of Static Methods

```java
interface Animal {
    static void breathe() {
        System.out.println("Animal breathing");
    }
}

interface Mammal extends Animal {
    // Does NOT inherit breathe() static method
}

public class Main {
    public static void main(String[] args) {
        Animal.breathe(); // OK
        // Mammal.breathe(); // Compile error - not inherited
    }
}
```

### 2. Cannot Override in Implementing Classes

```java
interface Logger {
    static void log(String message) {
        System.out.println("LOG: " + message);
    }
}

class FileLogger implements Logger {
    // This is NOT overriding - it's a separate method
    static void log(String message) {
        System.out.println("FILE LOG: " + message);
    }
}

public class Main {
    public static void main(String[] args) {
        Logger.log("Interface message"); // LOG: Interface message
        FileLogger.log("Class message"); // FILE LOG: Class message
        
        Logger logger = new FileLogger();
        // logger.log("Test"); // Compile error - can't call static via instance
    }
}
```

### 3. Accessing Other Static Members

```java
interface MathOperations {
    // Static variable
    double PI = 3.14159;
    
    // Static method 1
    static double circleArea(double radius) {
        return PI * radius * radius; // Can access other static members
    }
    
    // Static method 2
    static double circleCircumference(double radius) {
        return 2 * PI * radius;
    }
    
    // Default method CANNOT access static methods directly
    default void printPi() {
        System.out.println("PI is: " + PI);
        // System.out.println("Area: " + circleArea(1.0)); // Compile error
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println(MathOperations.circleArea(2.0)); // ~12.566
        System.out.println(MathOperations.circleCircumference(2.0)); // ~12.566
        
        // Default method can be called on instances
        new MathOperations() {}.printPi(); // Anonymous class
    }
}
```

## Java 9 Enhancement: Private Static Methods

Java 9 introduced private static methods to improve code organization within interfaces.

```java
interface Database {
    // Public static method
    static Connection getConnection() {
        String url = getDbUrl();
        String user = getDbUser();
        return createConnection(url, user);
    }
    
    // Private static helper methods
    private static String getDbUrl() {
        return "jdbc:mysql://localhost:3306/mydb";
    }
    
    private static String getDbUser() {
        return "admin";
    }
    
    private static Connection createConnection(String url, String user) {
        // Actual connection logic
        return null; // Simplified
    }
}

public class Main {
    public static void main(String[] args) {
        Connection conn = Database.getConnection();
        // Database.getDbUrl(); // Compile error - private
    }
}
```

## Practical Use Cases

1. **Utility Methods**
   ```java
   interface StringUtils {
       static boolean isBlank(String str) {
           return str == null || str.trim().isEmpty();
       }
       
       static String capitalize(String str) {
           if (isBlank(str)) return str;
           return str.substring(0, 1).toUpperCase() + str.substring(1);
       }
   }
   ```

2. **Factory Methods**
   ```java
   interface Shape {
       double area();
       
       static Shape createCircle(double radius) {
           return new Circle(radius);
       }
       
       static Shape createRectangle(double width, double height) {
           return new Rectangle(width, height);
       }
   }
   ```

3. **Constants with Behavior**
   ```java
   interface PhysicalConstants {
       double AVOGADRO = 6.022_140_76e23;
       double BOLTZMANN = 1.380_649e-23;
       
       static double particlesFromMoles(double moles) {
           return moles * AVOGADRO;
       }
   }
   ```

## Comparison with Default Methods

| Feature        | Static Methods | Default Methods |
|---------------|---------------|----------------|
| Called via    | Interface name | Instance        |
| Overridable   | No            | Yes            |
| Access to     | Only static members | Both static and instance |
| Purpose       | Utility methods | Backward compatibility |
| Inheritance  | Not inherited | Inherited       |

## Key Takeaways

1. Static methods belong to the interface itself, not instances
2. Called using `InterfaceName.method()`, not through object references
3. Cannot be overridden (though implementing classes can declare same-name methods)
4. Can only access other static members of the interface
5. Java 9 added private static methods for better encapsulation
6. Useful for utility methods, factory methods, and constants with behavior
7. Different from default methods which are instance methods with implementation

Static methods in interfaces help organize related utility methods logically with the interface they belong to, rather than creating separate utility classes.