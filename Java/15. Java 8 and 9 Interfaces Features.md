# Java 8 and 9 Interface Features Explained

Let me explain the Java 8 and 9 interface features in detail with proper code examples.

## Java 8 Interface Features

### 1. Default Methods

Before Java 8, interfaces could only have abstract methods. Default methods were introduced to allow interfaces to have method implementations.

**Why Default Methods?**
- To add new functionality to existing interfaces without breaking existing implementations
- Particularly useful when Java 8 added the `stream()` method to the `Collection` interface

**Example:**

```java
// Before Java 8 - only abstract methods
interface Bird {
    void canFly(); // abstract method
}

class Eagle implements Bird {
    @Override
    public void canFly() {
        System.out.println("Eagle can fly high");
    }
}

// Java 8 - with default method
interface Bird {
    void canFly(); // abstract method
    
    // Default method with implementation
    default int getMinimumFlyHeight() {
        return 100; // default implementation
    }
}

class Sparrow implements Bird {
    @Override
    public void canFly() {
        System.out.println("Sparrow can fly");
    }
    // No need to implement getMinimumFlyHeight()
}

public class Main {
    public static void main(String[] args) {
        Sparrow sparrow = new Sparrow();
        sparrow.canFly();
        System.out.println("Minimum height: " + sparrow.getMinimumFlyHeight());
    }
}
```

**Multiple Inheritance Problem:**

```java
interface LivingThing {
    default void canBreathe() {
        System.out.println("Living thing can breathe");
    }
}

interface Bird {
    default void canBreathe() {
        System.out.println("Bird can breathe");
    }
}

// Compilation error - must override canBreathe()
class Eagle implements LivingThing, Bird {
    @Override
    public void canBreathe() {
        // Option 1: Use one of the parent implementations
        LivingThing.super.canBreathe();
        
        // Option 2: Provide new implementation
        System.out.println("Eagle can breathe");
    }
}
```

### 2. Static Methods

Java 8 also introduced static methods in interfaces.

**Key Points:**
- Cannot be overridden by implementing classes
- Accessed using interface name only
- Useful for utility methods related to the interface

**Example:**

```java
interface Bird {
    static boolean canFlyHigh(int height) {
        return height > 1000;
    }
    
    default void checkFlightHeight(int height) {
        if (Bird.canFlyHigh(height)) {
            System.out.println("This bird can fly high");
        }
    }
}

class Eagle implements Bird {
    // Cannot override static method
}

public class Main {
    public static void main(String[] args) {
        // Call static method using interface name
        System.out.println(Bird.canFlyHigh(1500)); // true
        
        Eagle eagle = new Eagle();
        eagle.checkFlightHeight(1500); // This bird can fly high
    }
}
```

## Java 9 Interface Features

### 1. Private Methods

Java 9 introduced private methods in interfaces to allow code reuse between default methods.

**Key Points:**
- Can be static or non-static
- Can only be used within the interface
- Improve code reusability and encapsulation

**Example:**

```java
interface Bird {
    // Abstract method
    void canFly();
    
    // Default method
    default void flyInfo() {
        System.out.println(getFlyDetails());
    }
    
    // Private method - reusable code
    private String getFlyDetails() {
        return "Flight details: speed=50km/h, altitude=100m";
    }
    
    // Static method
    static boolean isFlyingAnimal(String name) {
        return checkFlightAbility(name);
    }
    
    // Private static method
    private static boolean checkFlightAbility(String name) {
        return name.equals("Eagle") || name.equals("Sparrow");
    }
}

class Eagle implements Bird {
    @Override
    public void canFly() {
        System.out.println("Eagle can fly");
    }
}

public class Main {
    public static void main(String[] args) {
        Eagle eagle = new Eagle();
        eagle.canFly();
        eagle.flyInfo();
        
        System.out.println(Bird.isFlyingAnimal("Eagle")); // true
        System.out.println(Bird.isFlyingAnimal("Dog"));   // false
    }
}
```

## Complete Example Combining All Features

```java
public class InterfaceFeaturesDemo {
    public static void main(String[] args) {
        Parrot parrot = new Parrot();
        parrot.fly();               // From abstract method
        parrot.defaultFly();        // From default method
        FlyingCreature.staticFly();  // From static method
    }
}

interface FlyingCreature {
    // Abstract method (implicitly public)
    void fly();
    
    // Default method
    default void defaultFly() {
        System.out.println("Default flying implementation");
        privateMethod();
        privateStaticMethod();
    }
    
    // Static method
    static void staticFly() {
        System.out.println("Static flying implementation");
        privateStaticMethod();
        // privateMethod(); // Error - cannot call non-static from static
    }
    
    // Private method
    private void privateMethod() {
        System.out.println("Private method called");
    }
    
    // Private static method
    private static void privateStaticMethod() {
        System.out.println("Private static method called");
    }
}

class Parrot implements FlyingCreature {
    @Override
    public void fly() {
        System.out.println("Parrot flying");
    }
    
    // Can override default method (optional)
    @Override
    public void defaultFly() {
        System.out.println("Parrot's custom default fly");
        FlyingCreature.super.defaultFly(); // Call parent default method
    }
    
    // Cannot override static method
}
```

## Key Takeaways

1. **Default Methods (Java 8):**
   - Allow interfaces to have method implementations
   - Can be overridden by implementing classes
   - Useful for backward compatibility

2. **Static Methods (Java 8):**
   - Cannot be overridden
   - Called using interface name
   - Useful for utility methods

3. **Private Methods (Java 9):**
   - Improve code reusability within interface
   - Can be static or non-static
   - Enhance encapsulation

4. **Rules:**
   - Static methods can only call other static members
   - Non-static methods can call both static and non-static members
   - Private methods cannot be abstract
   - Abstract methods must be public (cannot be private)

These features make interfaces more powerful and flexible while maintaining backward compatibility with existing code.