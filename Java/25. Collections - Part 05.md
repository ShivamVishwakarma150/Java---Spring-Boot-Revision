# LinkedHashMap and TreeMap in Java - Summary

## LinkedHashMap

### Key Features:
- Maintains insertion order by default (differs from HashMap)
- Can also maintain access order (least recently used to most recently used)
- Uses doubly linked list internally to maintain order
- Performance is similar to HashMap (average O(1) operations)
- Not thread-safe (must use Collections.synchronizedMap() for thread safety)

### Internal Structure:
- Extends HashMap and maintains all its functionality
- Adds two extra pointers (before/after) to nodes to form doubly linked list
- When accessOrder=true, accessed elements move to end of list
- Iteration follows the linked list order rather than bucket order

### Use Cases:
- When you need predictable iteration order
- Can be used as a simple LRU (Least Recently Used) cache

## TreeMap

### Key Features:
- Implements NavigableMap and SortedMap interfaces
- Maintains elements in sorted order (natural ordering or custom Comparator)
- Uses Red-Black tree (self-balancing BST) internally
- Operations have O(log n) time complexity
- Provides additional navigation methods (lowerKey, floorEntry, etc.)

### Internal Structure:
- Each node contains key, value, parent, left, and right pointers
- Maintains binary search tree properties (left < parent < right)
- Automatically balances the tree (Red-Black tree properties)

### Navigation Methods:
- lowerKey(k) - greatest key strictly less than k
- floorKey(k) - greatest key less than or equal to k
- higherKey(k) - least key strictly greater than k
- ceilingKey(k) - least key greater than or equal to k
- firstKey()/lastKey() - smallest/largest keys
- headMap()/tailMap() - view portions of the map
- descendingMap() - reversed order view

### Use Cases:
- When you need sorted key-value pairs
- When you need range queries or nearest-key lookups
- When you need to frequently access min/max elements

## Comparison

| Feature        | HashMap | LinkedHashMap | TreeMap |
|---------------|---------|--------------|---------|
| Ordering       | None    | Insertion/Access | Sorted  |
| Implementation | Hash table | Hash table + linked list | Red-Black tree |
| get/put/remove | O(1)    | O(1)         | O(log n) |
| Null keys      | Allowed | Allowed      | Only if Comparator allows |
| Thread-safe    | No      | No           | No      |
| Best for       | General use | Predictable iteration | Sorted operations |

The video provides detailed code examples showing how to use both LinkedHashMap (with insertion and access order) and TreeMap (with natural and custom ordering), along with explanations of their internal implementations.

<br/>
<br/>

# **LinkedHashMap & TreeMap Code Examples Explained in Detail**

Let's break down the code examples for **LinkedHashMap** (insertion/access order) and **TreeMap** (natural/custom sorting) with detailed explanations.

---

## **1. LinkedHashMap Examples**
### **1.1 Maintaining Insertion Order (Default Behavior)**
```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample {
    public static void main(String[] args) {
        // Default: maintains insertion order
        Map<Integer, String> insertionOrderMap = new LinkedHashMap<>();
        
        insertionOrderMap.put(1, "A");
        insertionOrderMap.put(21, "B");
        insertionOrderMap.put(23, "C");
        insertionOrderMap.put(141, "D");
        insertionOrderMap.put(25, "E");

        System.out.println("Insertion Order:");
        insertionOrderMap.forEach((k, v) -> System.out.println(k + " : " + v));
    }
}
```
**Output:**
```
Insertion Order:
1 : A
21 : B
23 : C
141 : D
25 : E
```
**Explanation:**
- **LinkedHashMap** maintains the order in which elements were inserted.
- When iterating, it follows the **doubly-linked list** structure (not hash bucket order like `HashMap`).
- Useful when you need predictable iteration order (e.g., caching, ordered logging).

---

### **1.2 Maintaining Access Order (LRU Cache Behavior)**
```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapAccessOrder {
    public static void main(String[] args) {
        // Set accessOrder=true (LRU behavior)
        Map<Integer, String> accessOrderMap = new LinkedHashMap<>(16, 0.75f, true);
        
        accessOrderMap.put(1, "A");
        accessOrderMap.put(21, "B");
        accessOrderMap.put(23, "C");
        accessOrderMap.put(141, "D");
        accessOrderMap.put(25, "E");

        System.out.println("Initial Order:");
        accessOrderMap.forEach((k, v) -> System.out.println(k + " : " + v));

        // Access some elements (moves them to the end)
        accessOrderMap.get(23); // Moves 23 to the end
        accessOrderMap.get(21); // Moves 21 to the end

        System.out.println("\nAfter Accessing 23 and 21:");
        accessOrderMap.forEach((k, v) -> System.out.println(k + " : " + v));
    }
}
```
**Output:**
```
Initial Order:
1 : A
21 : B
23 : C
141 : D
25 : E

After Accessing 23 and 21:
1 : A
141 : D
25 : E
23 : C
21 : B
```
**Explanation:**
- When `accessOrder=true`, **LinkedHashMap** moves accessed elements to the **end** (most recently used).
- Useful for **LRU (Least Recently Used) Cache** implementations.
- The least recently used elements stay at the **front** (can be evicted first).

---

## **2. TreeMap Examples**
### **2.1 Natural Ordering (Ascending by Default)**
```java
import java.util.Map;
import java.util.TreeMap;

public class TreeMapNaturalOrder {
    public static void main(String[] args) {
        // Default: sorts keys in natural order (ascending)
        Map<Integer, String> treeMap = new TreeMap<>();
        
        treeMap.put(21, "B");
        treeMap.put(1, "A");
        treeMap.put(141, "D");
        treeMap.put(23, "C");
        treeMap.put(25, "E");

        System.out.println("Natural Order (Ascending):");
        treeMap.forEach((k, v) -> System.out.println(k + " : " + v));
    }
}
```
**Output:**
```
Natural Order (Ascending):
1 : A
21 : B
23 : C
25 : E
141 : D
```
**Explanation:**
- **TreeMap** sorts keys in **natural order** (ascending for numbers, alphabetical for strings).
- Internally uses a **Red-Black Tree** (self-balancing BST).
- Guarantees **O(log n)** time for `put()`, `get()`, `remove()`.

---

### **2.2 Custom Ordering (Using Comparator)**
```java
import java.util.Comparator;
import java.util.Map;
import java.util.TreeMap;

public class TreeMapCustomOrder {
    public static void main(String[] args) {
        // Custom sorting (descending order)
        Map<Integer, String> treeMap = new TreeMap<>(Comparator.reverseOrder());
        
        treeMap.put(21, "B");
        treeMap.put(1, "A");
        treeMap.put(141, "D");
        treeMap.put(23, "C");
        treeMap.put(25, "E");

        System.out.println("Custom Order (Descending):");
        treeMap.forEach((k, v) -> System.out.println(k + " : " + v));
    }
}
```
**Output:**
```
Custom Order (Descending):
141 : D
25 : E
23 : C
21 : B
1 : A
```
**Explanation:**
- We can pass a **Comparator** to define custom sorting (`Comparator.reverseOrder()` for descending).
- Useful when you need **non-default sorting** (e.g., reverse order, custom object sorting).

---

### **2.3 TreeMap Navigation Methods**
```java
import java.util.Map;
import java.util.TreeMap;

public class TreeMapNavigation {
    public static void main(String[] args) {
        Map<Integer, String> treeMap = new TreeMap<>();
        treeMap.put(1, "A");
        treeMap.put(21, "B");
        treeMap.put(23, "C");
        treeMap.put(141, "D");
        treeMap.put(25, "E");

        System.out.println("First Key: " + treeMap.firstKey());
        System.out.println("Last Key: " + treeMap.lastKey());
        
        System.out.println("\nLower than 23: " + treeMap.lowerKey(23)); // Strictly <
        System.out.println("Floor of 24: " + treeMap.floorKey(24));    // <=
        
        System.out.println("\nHigher than 23: " + treeMap.higherKey(23)); // Strictly >
        System.out.println("Ceiling of 24: " + treeMap.ceilingKey(24));   // >=
        
        System.out.println("\nHeadMap (keys < 23): " + treeMap.headMap(23));
        System.out.println("TailMap (keys >= 23): " + treeMap.tailMap(23));
    }
}
```
**Output:**
```
First Key: 1
Last Key: 141

Lower than 23: 21
Floor of 24: 23

Higher than 23: 25
Ceiling of 24: 25

HeadMap (keys < 23): {1=A, 21=B}
TailMap (keys >= 23): {23=C, 25=E, 141=D}
```
**Explanation:**
- **`firstKey()` / `lastKey()`** → Smallest/largest key.
- **`lowerKey(k)`** → Greatest key **strictly less than k**.
- **`floorKey(k)`** → Greatest key **less than or equal to k**.
- **`higherKey(k)`** → Smallest key **strictly greater than k**.
- **`ceilingKey(k)`** → Smallest key **greater than or equal to k**.
- **`headMap(k)`** → Returns a submap with keys **less than k**.
- **`tailMap(k)`** → Returns a submap with keys **greater than or equal to k**.

---

## **Summary Table**
| Feature            | LinkedHashMap | TreeMap |
|--------------------|--------------|---------|
| **Order**          | Insertion/Access | Sorted (Natural/Custom) |
| **Internal Structure** | Hash Table + Doubly-Linked List | Red-Black Tree |
| **Time Complexity** | O(1) avg. | O(log n) |
| **Thread-Safe?** | No (Use `Collections.synchronizedMap()`) | No |
| **Best Use Case** | LRU Cache, Ordered Iteration | Sorted Maps, Range Queries |

### **When to Use Which?**
✔ **LinkedHashMap** → When you need **insertion/access order** (e.g., caching).  
✔ **TreeMap** → When you need **sorted keys** (e.g., leaderboards, range queries).  
✔ **HashMap** → When **order doesn’t matter** (general-purpose key-value storage).

---

### **Final Notes**
- **LinkedHashMap** is **faster** (O(1)) but maintains order.
- **TreeMap** is **slower** (O(log n)) but provides **sorted operations**.
- Both are **not thread-safe** (use `ConcurrentHashMap` or `Collections.synchronizedMap()` for thread safety).

