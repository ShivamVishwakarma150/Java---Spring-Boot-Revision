# **Java Concurrency: Future, Callable & CompletableFuture**

## **1. Future Interface**

### **Theory:**
- **Purpose**: Represents the result of an asynchronous computation
- **Key Characteristics**:
  - Provides methods to check if computation is complete
  - Allows retrieving the result once available
  - Supports cancellation of the computation
  - Handles exceptions thrown during computation

### **Key Methods:**
```java
boolean cancel(boolean mayInterruptIfRunning)
boolean isCancelled()
boolean isDone()
V get() throws InterruptedException, ExecutionException
V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
```

### **Code Example:**
```java
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<String> future = executor.submit(() -> {
    Thread.sleep(2000);
    return "Result from Future";
});

// Non-blocking check
if (future.isDone()) {
    String result = future.get();
    System.out.println(result);
}

executor.shutdown();
```

---

## **2. Callable Interface**

### **Theory:**
- **Purpose**: Similar to Runnable but can return a result and throw checked exceptions
- **Key Difference from Runnable**:
  - Returns a value (`V call()` vs `void run()`)
  - Can throw checked exceptions
  - Used with ExecutorService.submit()

### **Code Example:**
```java
Callable<Integer> callableTask = () -> {
    int sum = 0;
    for (int i = 1; i <= 100; i++) {
        sum += i;
    }
    return sum;
};

ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(callableTask);

Integer result = future.get(); // 5050
```

---

## **3. CompletableFuture (Java 8+)**

### **Theory:**
- **Purpose**: Enhanced Future with async programming capabilities
- **Key Features**:
  - **Non-blocking** operations
  - **Functional programming** style
  - **Chaining** and **combining** async operations
  - **Exception handling** built-in
  - **Manual completion** capability

### **3.1 Creating CompletableFuture**

#### **Methods:**
```java
// Create already completed
CompletableFuture.completedFuture(value)

// Run async (no return)
CompletableFuture.runAsync(Runnable)

// Supply async (with return)
CompletableFuture.supplyAsync(Supplier)
```

#### **Code:**
```java
// Already completed
CompletableFuture<String> completed = CompletableFuture.completedFuture("Hello");

// Run async task
CompletableFuture<Void> runAsync = CompletableFuture.runAsync(() -> {
    System.out.println("Running async");
});

// Supply async result
CompletableFuture<String> supplyAsync = CompletableFuture.supplyAsync(() -> {
    return "Result from async";
});
```

### **3.2 Chaining Operations**

#### **Theory:**
- **thenApply()**: Transform result (sync)
- **thenApplyAsync()**: Transform result (async)
- **thenAccept()**: Consume result (sync)
- **thenRun()**: Run after completion (no result access)

#### **Code:**
```java
CompletableFuture.supplyAsync(() -> "Hello")
    .thenApply(s -> s + " World")           // Transform
    .thenApply(String::toUpperCase)         // Transform
    .thenAccept(System.out::println)        // Consume
    .thenRun(() -> System.out.println("Done")); // Run
```

### **3.3 Combining Futures**

#### **Theory:**
- **thenCombine()**: Combine two independent futures
- **thenCompose()**: Chain dependent futures (flatMap)
- **allOf()**: Wait for all futures
- **anyOf()**: Wait for any future

#### **Code:**
```java
// Combine two futures
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "World");

future1.thenCombine(future2, (s1, s2) -> s1 + " " + s2)
       .thenAccept(System.out::println);

// Compose (flatMap)
future1.thenCompose(s -> CompletableFuture.supplyAsync(() -> s + "!"));

// Wait for all
CompletableFuture.allOf(future1, future2)
                 .thenRun(() -> System.out.println("All done"));

// Wait for any
CompletableFuture.anyOf(future1, future2)
                 .thenAccept(System.out::println);
```

### **3.4 Exception Handling**

#### **Theory:**
- **exceptionally()**: Provide fallback on exception
- **handle()**: Handle both success and failure
- **whenComplete()**: Execute regardless of outcome

#### **Code:**
```java
CompletableFuture.supplyAsync(() -> {
        if (new Random().nextBoolean()) {
            throw new RuntimeException("Error");
        }
        return "Success";
    })
    .exceptionally(ex -> "Fallback: " + ex.getMessage()) // On error
    .handle((result, ex) -> { // Always executed
        if (ex != null) {
            return "Handled error: " + ex.getMessage();
        }
        return "Result: " + result;
    })
    .whenComplete((result, ex) -> { // Side effect
        System.out.println("Completed: " + result);
    });
```

### **3.5 Timeout and Completion Control**

#### **Code:**
```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(5000); } catch (InterruptedException e) {}
    return "Result";
});

// Complete manually
future.complete("Manual result");

// Complete exceptionally
future.completeExceptionally(new RuntimeException("Forced error"));

// Timeout
future.orTimeout(2, TimeUnit.SECONDS)
      .exceptionally(ex -> "Timeout handled: " + ex.getMessage());
```

---

## **4. Advanced CompletableFuture**

### **4.1 Custom Executors**

#### **Code:**
```java
ExecutorService customExecutor = Executors.newFixedThreadPool(3, r -> {
    Thread t = new Thread(r);
    t.setName("CustomThread-" + UUID.randomUUID());
    t.setDaemon(true);
    return t;
});

CompletableFuture.supplyAsync(() -> {
    System.out.println("Running in: " + Thread.currentThread().getName());
    return "Result";
}, customExecutor);
```

### **4.2 Concurrent Operations Pattern**

#### **Code:**
```java
List<CompletableFuture<String>> futures = Arrays.asList(
    CompletableFuture.supplyAsync(() -> fetchDataFromSource1()),
    CompletableFuture.supplyAsync(() -> fetchDataFromSource2()),
    CompletableFuture.supplyAsync(() -> fetchDataFromSource3())
);

// Wait for all and collect results
CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
    .thenApply(v -> futures.stream()
        .map(CompletableFuture::join)
        .collect(Collectors.toList()))
    .thenAccept(results -> processAllResults(results));
```

### **4.3 Retry Mechanism**

#### **Code:**
```java
public CompletableFuture<String> fetchWithRetry(String url, int maxRetries) {
    return CompletableFuture.supplyAsync(() -> fetchData(url))
        .exceptionallyCompose(ex -> {
            if (maxRetries > 0) {
                return fetchWithRetry(url, maxRetries - 1);
            }
            throw new CompletionException(ex);
        });
}
```

---

## **5. Best Practices**

### **5.1 Always Use Timeouts**
```java
future.get(5, TimeUnit.SECONDS); // Always specify timeout
```

### **5.2 Proper Resource Cleanup**
```java
try (ExecutorService executor = Executors.newFixedThreadPool(3)) {
    CompletableFuture.runAsync(() -> task(), executor);
} // Auto shutdown
```

### **5.3 Avoid Blocking in Async Operations**
```java
// ❌ Bad - blocks async thread
CompletableFuture.supplyAsync(() -> {
    return blockingDBCall(); // Blocks thread
});

// ✅ Good - use async wrapper
CompletableFuture.supplyAsync(() -> {
    return CompletableFuture.supplyAsync(() -> blockingDBCall()).join();
});
```

### **5.4 Use Descriptive Thread Names**
```java
ExecutorService executor = Executors.newFixedThreadPool(3, 
    new ThreadFactory() {
        private AtomicInteger count = new AtomicInteger(1);
        public Thread newThread(Runnable r) {
            return new Thread(r, "AsyncWorker-" + count.getAndIncrement());
        }
    });
```

---

## **6. Common Patterns**

### **6.1 Fallback Pattern**
```java
CompletableFuture<String> primary = fetchPrimaryData();
CompletableFuture<String> fallback = fetchFallbackData();

primary.exceptionallyCompose(ex -> fallback)
       .thenAccept(this::processData);
```

### **6.2 Circuit Breaker Pattern**
```java
class CircuitBreaker {
    private boolean open = false;
    
    public CompletableFuture<String> execute(Supplier<String> operation) {
        if (open) {
            return CompletableFuture.failedFuture(new RuntimeException("Circuit open"));
        }
        
        return CompletableFuture.supplyAsync(operation)
            .exceptionally(ex -> {
                open = true;
                throw new CompletionException(ex);
            });
    }
}
```

### **6.3 Bulkhead Pattern**
```java
// Different executors for different resource types
ExecutorService dbExecutor = Executors.newFixedThreadPool(5); // DB calls
ExecutorService apiExecutor = Executors.newFixedThreadPool(3); // API calls
ExecutorService cpuExecutor = Executors.newWorkStealingPool(); // CPU intensive
```

---

## **7. Performance Considerations**

### **7.1 Thread Pool Sizing**
```java
// CPU-bound tasks
int cpuCores = Runtime.getRuntime().availableProcessors();
ExecutorService cpuExecutor = Executors.newFixedThreadPool(cpuCores);

// I/O-bound tasks
ExecutorService ioExecutor = Executors.newCachedThreadPool();
```

### **7.2 Avoid Deep Chains**
```java
// ❌ Deep nesting - hard to read and debug
future.thenApply().thenApply().thenCompose().thenAccept();

// ✅ Flat structure - better readability
future.thenApply(step1)
      .thenApply(step2)
      .thenCompose(step3)
      .thenAccept(step4);
```

### **7.3 Monitor Async Operations**
```java
// Add logging to track async operations
CompletableFuture.supplyAsync(() -> {
    long start = System.currentTimeMillis();
    String result = performOperation();
    long duration = System.currentTimeMillis() - start;
    log.debug("Operation completed in {} ms", duration);
    return result;
});
```

---

## **8. Error Handling Strategies**

### **8.1 Global Exception Handler**
```java
CompletableFuture.supplyAsync(() -> operation())
    .exceptionally(ex -> {
        log.error("Async operation failed", ex);
        return fallbackValue();
    });
```

### **8.2 Retry with Backoff**
```java
public CompletableFuture<String> retryWithBackoff(Supplier<String> operation, 
                                                 int maxRetries, 
                                                 long initialDelay) {
    return CompletableFuture.supplyAsync(operation)
        .exceptionallyCompose(ex -> {
            if (maxRetries > 0) {
                return CompletableFuture.supplyAsync(() -> {
                    try { Thread.sleep(initialDelay); } catch (InterruptedException e) {}
                    return null;
                }).thenCompose(v -> retryWithBackoff(operation, maxRetries - 1, initialDelay * 2));
            }
            throw new CompletionException(ex);
        });
}
```

This comprehensive guide covers all essential aspects of Java's concurrency utilities with practical examples and best practices.