# Comprehensive Guide to Java Locks in Multithreading

This guide covers the different types of locks available in Java for multithreading, including synchronized blocks, ReentrantLock, ReadWriteLock, StampedLock, and Semaphore, along with thread communication using Condition objects.

## 1. Synchronized Blocks (Monitor Locks)

The most basic form of locking in Java using the `synchronized` keyword.

```java
class SharedResource {
    public synchronized void producer() {
        System.out.println("Lock acquired by " + Thread.currentThread().getName());
        try {
            Thread.sleep(4000); // Simulate work
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Lock released by " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource1 = new SharedResource();
        SharedResource resource2 = new SharedResource();
        
        Thread thread1 = new Thread(() -> resource1.producer());
        Thread thread2 = new Thread(() -> resource2.producer());
        
        thread1.start();
        thread2.start();
    }
}
```

**Key Points:**
- Synchronized locks are object-based (monitor locks)
- If different threads use different objects, they can enter the synchronized block simultaneously
- Simple to use but limited in functionality

## 2. ReentrantLock

A more flexible alternative to synchronized blocks that isn't tied to object instances.

```java
import java.util.concurrent.locks.ReentrantLock;

class SharedResource {
    private ReentrantLock lock = new ReentrantLock();
    
    public void producer() {
        lock.lock(); // Acquire the lock
        try {
            System.out.println("Lock acquired by " + Thread.currentThread().getName());
            Thread.sleep(4000); // Simulate work
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("Lock released by " + Thread.currentThread().getName());
            lock.unlock(); // Always release in finally
        }
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        
        Thread thread1 = new Thread(() -> resource.producer());
        Thread thread2 = new Thread(() -> resource.producer());
        
        thread1.start();
        thread2.start();
    }
}
```

**Key Points:**
- Not tied to object instances - works across different objects if they share the same lock
- Must explicitly lock and unlock (unlike synchronized)
- More flexible than synchronized blocks (can try to acquire lock, timeout, etc.)
- Reentrant (same thread can acquire lock multiple times)

## 3. ReadWriteLock

Allows multiple readers or a single writer at any time, improving performance for read-heavy workloads.

```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class SharedResource {
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public void producer() { // Read operation
        lock.readLock().lock();
        try {
            System.out.println("Read lock acquired by " + Thread.currentThread().getName());
            Thread.sleep(4000); // Simulate read
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("Read lock released by " + Thread.currentThread().getName());
            lock.readLock().unlock();
        }
    }
    
    public void consume() { // Write operation
        lock.writeLock().lock();
        try {
            System.out.println("Write lock acquired by " + Thread.currentThread().getName());
            Thread.sleep(4000); // Simulate write
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("Write lock released by " + Thread.currentThread().getName());
            lock.writeLock().unlock();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        
        // Multiple readers can access simultaneously
        Thread reader1 = new Thread(() -> resource.producer());
        Thread reader2 = new Thread(() -> resource.producer());
        
        // Only one writer at a time
        Thread writer = new Thread(() -> resource.consume());
        
        reader1.start();
        reader2.start();
        writer.start();
    }
}
```

**Key Points:**
- Multiple threads can hold read locks simultaneously
- Only one thread can hold a write lock (exclusive)
- Write lock can't be acquired while read locks are held
- Read locks can't be acquired while a write lock is held
- Ideal for read-heavy, write-light scenarios

## 4. StampedLock

An advanced lock that supports both read-write locks and optimistic locking.

### Read-Write Mode
```java
import java.util.concurrent.locks.StampedLock;

class SharedResource {
    private StampedLock lock = new StampedLock();
    
    public void producer() {
        long stamp = lock.readLock(); // Returns a stamp
        try {
            System.out.println("Read lock acquired by " + Thread.currentThread().getName());
            Thread.sleep(4000); // Simulate read
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("Read lock released by " + Thread.currentThread().getName());
            lock.unlockRead(stamp); // Must pass stamp
        }
    }
    
    public void consume() {
        long stamp = lock.writeLock(); // Returns a stamp
        try {
            System.out.println("Write lock acquired by " + Thread.currentThread().getName());
            Thread.sleep(4000); // Simulate write
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("Write lock released by " + Thread.currentThread().getName());
            lock.unlockWrite(stamp); // Must pass stamp
        }
    }
}
```

### Optimistic Locking Mode
```java
class SharedResourceOptimistic {
    private int value = 10;
    private StampedLock lock = new StampedLock();
    
    public void producer() {
        // Optimistic read - doesn't block
        long stamp = lock.tryOptimisticRead();
        int currentValue = value; // Read value
        
        // Validate if no write occurred since we took the stamp
        if (!lock.validate(stamp)) {
            // If validation failed, acquire a full read lock
            stamp = lock.readLock();
            try {
                currentValue = value;
            } finally {
                lock.unlockRead(stamp);
            }
        }
        
        System.out.println("Read value: " + currentValue);
    }
    
    public void consume() {
        long stamp = lock.writeLock();
        try {
            System.out.println("Write lock acquired by " + Thread.currentThread().getName());
            value += 5; // Modify value
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlockWrite(stamp);
            System.out.println("Write lock released by " + Thread.currentThread().getName());
        }
    }
}
```

**Key Points:**
- More advanced than ReadWriteLock
- Supports optimistic reads (no blocking)
- Stamps are used to track lock state
- Optimistic reads don't block writers
- Must validate stamps after optimistic reads
- Generally provides better performance than ReadWriteLock

## 5. Semaphore

Controls access to a resource through permits, allowing multiple threads to access simultaneously up to a limit.

```java
import java.util.concurrent.Semaphore;

class SharedResource {
    private Semaphore semaphore = new Semaphore(2); // Allow 2 permits
    
    public void producer() {
        try {
            semaphore.acquire(); // Get permit
            System.out.println("Lock acquired by " + Thread.currentThread().getName());
            Thread.sleep(4000); // Simulate work
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("Lock released by " + Thread.currentThread().getName());
            semaphore.release(); // Release permit
        }
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        
        // Create 4 threads - only 2 can access simultaneously
        for (int i = 0; i < 4; i++) {
            new Thread(() -> resource.producer()).start();
        }
    }
}
```

**Key Points:**
- Controls access to a pool of resources
- Number of permits determines how many threads can access simultaneously
- Useful for resource pools (database connections, printers, etc.)
- Fairness can be configured (order in which threads acquire permits)

## 6. Thread Communication with Condition

Replacement for wait/notify when using explicit locks.

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedResourceCondition {
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    private boolean isAvailable = false;
    
    public void produce() {
        lock.lock();
        try {
            while (isAvailable) { // Wait until consumed
                System.out.println("Producer waiting...");
                condition.await(); // Like wait()
            }
            System.out.println("Producing...");
            isAvailable = true;
            condition.signal(); // Like notify()
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    
    public void consume() {
        lock.lock();
        try {
            while (!isAvailable) { // Wait until produced
                System.out.println("Consumer waiting...");
                condition.await(); // Like wait()
            }
            System.out.println("Consuming...");
            isAvailable = false;
            condition.signal(); // Like notify()
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResourceCondition resource = new SharedResourceCondition();
        
        new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                resource.produce();
            }
        }).start();
        
        new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                resource.consume();
            }
        }).start();
    }
}
```

**Key Points:**
- Condition objects are created from Lock objects
- `await()` is equivalent to `wait()`
- `signal()` is equivalent to `notify()`
- `signalAll()` is equivalent to `notifyAll()`
- Must hold the lock when calling these methods
- More flexible than wait/notify (can create multiple conditions per lock)

## Summary Table

| Lock Type | Characteristics | Best Use Cases |
|-----------|----------------|---------------|
| Synchronized | Object-based, simple, built-in | Simple synchronization needs |
| ReentrantLock | More flexible than synchronized, explicit locking | When you need tryLock(), fairness, etc. |
| ReadWriteLock | Multiple readers or single writer | Read-heavy, write-light scenarios |
| StampedLock | Advanced, supports optimistic reads | High contention read-write scenarios |
| Semaphore | Controls access to resource pool | Resource pools (connections, printers) |
| Condition | Thread communication with explicit locks | Complex thread coordination |

## Best Practices

1. Always release locks in finally blocks to prevent deadlocks
2. Prefer higher-level constructs (like ConcurrentHashMap) when possible
3. For simple cases, synchronized is often sufficient
4. For complex scenarios, consider ReentrantLock or StampedLock
5. Use ReadWriteLock when reads vastly outnumber writes
6. Use Semaphore for resource pool management
7. Keep critical sections as short as possible
8. Consider fairness policies for high contention scenarios

Understanding these different locking mechanisms gives you the tools to handle various concurrency scenarios efficiently in Java.

<br/>
<br/>

# **ReentrantLock in Java - Detailed Explanation**

The `ReentrantLock` is a synchronization mechanism in Java that provides more flexibility and control than the traditional `synchronized` keyword. It is part of the `java.util.concurrent.locks` package and is an implementation of the `Lock` interface.

---

## **1. What is ReentrantLock?**
- A **reentrant mutual exclusion lock** (similar to `synchronized` blocks).
- Allows **the same thread to acquire the lock multiple times** (reentrancy).
- Provides **explicit locking and unlocking** (unlike `synchronized`, which is implicit).
- Supports **fairness policy** (can prioritize the longest-waiting thread).
- Offers **additional features** like `tryLock()`, `lockInterruptibly()`, and timed lock attempts.

---

## **2. Key Features of ReentrantLock**
### **(a) Reentrancy**
- A thread that already holds the lock can reacquire it without deadlocking.
- Each `lock()` call must be matched with an `unlock()` call.

### **(b) Fairness**
- **Fair Mode (true):** Locks are granted in FIFO order (longest-waiting thread gets priority).
- **Unfair Mode (false):** Default mode, allows barging (new threads may acquire the lock before older waiting threads).

### **(c) TryLock Mechanism**
- `tryLock()`: Attempts to acquire the lock **without blocking**.
- `tryLock(timeout, unit)`: Waits for a specified time before giving up.

### **(d) Interruptible Locking**
- `lockInterruptibly()`: Allows a thread to be interrupted while waiting for the lock.

---

## **3. ReentrantLock vs Synchronized**
| Feature | `ReentrantLock` | `synchronized` |
|---------|----------------|----------------|
| **Lock Acquisition** | Explicit (`lock()` and `unlock()`) | Implicit (JVM manages) |
| **Reentrancy** | Yes | Yes |
| **Fairness** | Configurable (fair/unfair) | No (unfair) |
| **TryLock** | Supports `tryLock()` | Not supported |
| **Interruptible** | Yes (`lockInterruptibly()`) | No (blocks indefinitely) |
| **Condition Support** | Multiple `Condition` objects | Single intrinsic condition (`wait()/notify()`) |

---

## **4. How to Use ReentrantLock?**
### **Basic Usage**
```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void performTask() {
        lock.lock();  // Acquire the lock
        try {
            // Critical section (thread-safe operations)
            System.out.println(Thread.currentThread().getName() + " holds the lock");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();  // Always release in finally
            System.out.println(Thread.currentThread().getName() + " releases the lock");
        }
    }

    public static void main(String[] args) {
        ReentrantLockExample example = new ReentrantLockExample();
        
        Runnable task = example::performTask;
        
        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");
        
        t1.start();
        t2.start();
    }
}
```
**Output:**
```
Thread-1 holds the lock
Thread-1 releases the lock
Thread-2 holds the lock
Thread-2 releases the lock
```

---

### **2. Using `tryLock()` (Non-blocking)**
```java
public void performTaskWithTryLock() {
    if (lock.tryLock()) {  // Attempt to acquire lock
        try {
            System.out.println(Thread.currentThread().getName() + " acquired the lock");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
            System.out.println(Thread.currentThread().getName() + " released the lock");
        }
    } else {
        System.out.println(Thread.currentThread().getName() + " could not acquire the lock");
    }
}
```

---

### **3. Fairness Mode**
```java
ReentrantLock fairLock = new ReentrantLock(true);  // Fair lock (FIFO)
```

---

### **4. `lockInterruptibly()` (Handling Interruptions)**
```java
public void performTaskInterruptibly() throws InterruptedException {
    lock.lockInterruptibly();  // Allows interruption
    try {
        System.out.println(Thread.currentThread().getName() + " acquired the lock");
        Thread.sleep(5000);  // Simulate long task
    } finally {
        lock.unlock();
        System.out.println(Thread.currentThread().getName() + " released the lock");
    }
}
```

---

## **5. When to Use ReentrantLock?**
✅ **When you need advanced features** (`tryLock`, fairness, `lockInterruptibly`).  
✅ **When explicit lock control is required** (e.g., locking across multiple methods).  
✅ **When using `Condition` objects** (for fine-grained thread signaling).  
❌ **For simple cases**, `synchronized` is often sufficient.  

---

## **6. Best Practices**
1. **Always unlock in `finally`** to prevent deadlocks.
2. **Avoid nested locks** unless necessary (can lead to deadlocks).
3. **Prefer `tryLock()`** when possible to avoid indefinite blocking.
4. **Use fair locks sparingly** (can reduce throughput due to FIFO overhead).

---

## **7. Example: Producer-Consumer with ReentrantLock & Condition**
```java
import java.util.concurrent.locks.*;

public class ProducerConsumer {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull = lock.newCondition();
    private final int[] buffer = new int[10];
    private int count = 0;

    public void produce(int value) throws InterruptedException {
        lock.lock();
        try {
            while (count == buffer.length) {
                notFull.await();  // Wait until space is available
            }
            buffer[count++] = value;
            notEmpty.signal();  // Notify consumers
        } finally {
            lock.unlock();
        }
    }

    public int consume() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await();  // Wait until data is available
            }
            int value = buffer[--count];
            notFull.signal();  // Notify producers
            return value;
        } finally {
            lock.unlock();
        }
    }
}
```

---

## **Conclusion**
- **ReentrantLock provides more control** than `synchronized`.
- **Supports fairness, `tryLock`, and interruptible locking**.
- **Useful for complex synchronization scenarios**.
- **Always release locks in `finally`** to prevent deadlocks.

By understanding `ReentrantLock`, you can write more efficient and flexible multithreaded applications in Java. 🚀

<br/>
<br/>

# **ReadWriteLock in Java - Detailed Explanation**

`ReadWriteLock` is a specialized lock implementation in Java that allows **multiple threads to read a shared resource simultaneously**, while ensuring that **only one thread can write at a time**. It improves performance in scenarios where **reads are more frequent than writes**.

---

## **1. What is ReadWriteLock?**
- **Two types of locks**:
  - **Read Lock (Shared Lock)** → Multiple threads can hold it simultaneously.
  - **Write Lock (Exclusive Lock)** → Only one thread can hold it (blocks all reads and other writes).
- **Improves concurrency** by allowing concurrent reads.
- **Useful for read-heavy applications** (e.g., caching, database access).

---

## **2. Key Features**
| Feature | Description |
|---------|-------------|
| **Multiple Readers** | Many threads can read simultaneously. |
| **Single Writer** | Only one thread can write at a time. |
| **Write Lock Priority** | If a write is waiting, new reads are blocked. |
| **Reentrancy** | A thread can reacquire the same lock. |
| **Downgrading** | A write lock can be downgraded to a read lock. |
| **Fairness Mode** | Can be configured (fair/unfair). |

---

## **3. ReadWriteLock vs Synchronized vs ReentrantLock**
| Feature | `synchronized` | `ReentrantLock` | `ReadWriteLock` |
|---------|--------------|----------------|----------------|
| **Read Concurrency** | ❌ (Only one thread) | ❌ (Only one thread) | ✅ (Multiple readers) |
| **Write Concurrency** | ❌ (Exclusive) | ❌ (Exclusive) | ✅ (Exclusive) |
| **Fairness** | ❌ | ✅ | ✅ |
| **Performance** | Moderate | Moderate | **High (for reads)** |

---

## **4. How Does ReadWriteLock Work?**
- **Read Lock**:
  - Multiple threads can acquire it **if no write lock is held**.
  - If a **write lock is requested**, new reads are blocked until the write completes.
- **Write Lock**:
  - **Exclusive** – No other thread (read or write) can acquire the lock.
  - Blocks all reads and writes until released.

---

## **5. Implementation (`ReentrantReadWriteLock`)**
Java provides `ReentrantReadWriteLock`, which implements `ReadWriteLock`.

### **Basic Usage**
```java
import java.util.concurrent.locks.*;

public class ReadWriteLockExample {
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();  // Shared lock
    private final Lock writeLock = rwLock.writeLock(); // Exclusive lock
    private int sharedValue = 0;

    // Read operation (multiple threads can access)
    public int readValue() {
        readLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " reading: " + sharedValue);
            return sharedValue;
        } finally {
            readLock.unlock();
        }
    }

    // Write operation (only one thread at a time)
    public void writeValue(int value) {
        writeLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " writing: " + value);
            sharedValue = value;
            Thread.sleep(1000); // Simulate write delay
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            writeLock.unlock();
        }
    }

    public static void main(String[] args) {
        ReadWriteLockExample example = new ReadWriteLockExample();

        // Multiple readers
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                example.readValue();
            }, "Reader-" + i).start();
        }

        // Single writer
        new Thread(() -> {
            example.writeValue(42);
        }, "Writer").start();
    }
}
```

**Output:**
```
Reader-0 reading: 0
Reader-1 reading: 0
Reader-2 reading: 0
Reader-3 reading: 0
Reader-4 reading: 0
Writer writing: 42
```

---

## **6. When to Use ReadWriteLock?**
✅ **Caching Systems** (Many reads, few updates).  
✅ **Database Access** (Concurrent reads, exclusive writes).  
✅ **Configuration Management** (Frequent reads, rare updates).  
❌ **Not for write-heavy scenarios** (Use `ReentrantLock` instead).  

---

## **7. Best Practices**
1. **Prefer `ReadWriteLock` for read-heavy workloads**.
2. **Avoid holding read locks for too long** (can starve writers).
3. **Use `tryLock()` for non-blocking attempts**.
4. **Downgrade write locks to read locks** if needed:
   ```java
   writeLock.lock();
   try {
       // Modify data
       readLock.lock();  // Downgrade
   } finally {
       writeLock.unlock();
   }
   try {
       // Read safely
   } finally {
       readLock.unlock();
   }
   ```

---

## **8. Fairness Mode**
- **Fair Mode (`true`)** → Threads acquire locks in FIFO order.
- **Unfair Mode (`false`)** → Default (better throughput, but may starve threads).

```java
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true); // Fair
```

---

## **9. Example: Thread-Safe Cache**
```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.*;

public class ThreadSafeCache<K, V> {
    private final Map<K, V> cache = new HashMap<>();
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();

    public V get(K key) {
        readLock.lock();
        try {
            return cache.get(key);
        } finally {
            readLock.unlock();
        }
    }

    public void put(K key, V value) {
        writeLock.lock();
        try {
            cache.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }
}
```

---

## **10. Conclusion**
- **`ReadWriteLock` improves performance** by allowing concurrent reads.
- **Use `ReentrantReadWriteLock`** for thread-safe read/write operations.
- **Best for read-heavy, write-light scenarios** (e.g., caches, databases).
- **Avoid in write-heavy cases** (use `ReentrantLock` instead).

By using `ReadWriteLock`, you can **maximize concurrency** while ensuring **data consistency** in multithreaded applications. 🚀

<br/>
<br/>

# **StampedLock in Java - Detailed Explanation**

`StampedLock` is an advanced lock introduced in Java 8 that provides **three modes of locking** (optimistic reading, pessimistic reading, and writing) with **better performance** than `ReentrantReadWriteLock` in certain scenarios.

---

## **1. What is StampedLock?**
- **Three lock modes**:
  1. **Write Lock (Exclusive)** – Only one thread can hold it (like `ReentrantLock`).
  2. **Read Lock (Shared)** – Multiple threads can read simultaneously (like `ReadWriteLock`).
  3. **Optimistic Read (No Lock)** – Reads without blocking, but validates later.
- **Not reentrant** (unlike `ReentrantLock`).
- **Supports lock conversion** (e.g., downgrading a write lock to a read lock).
- **Better performance** than `ReentrantReadWriteLock` in high-contention scenarios.

---

## **2. Lock Modes in StampedLock**
| Mode | Description | Blocking? | Use Case |
|------|-------------|-----------|----------|
| **Write Lock** | Exclusive lock (only one writer) | ✅ Blocks | Updates, exclusive access |
| **Read Lock** | Shared lock (multiple readers) | ✅ Blocks | Concurrent reads |
| **Optimistic Read** | No lock, but checks for conflicts later | ❌ Non-blocking | Read-heavy, low contention |

---

## **3. Key Features**
✅ **Optimistic reads** (no blocking, checks for conflicts later).  
✅ **Better performance** than `ReentrantReadWriteLock`.  
✅ **Supports lock downgrading** (write → read).  
❌ **Not reentrant** (same thread cannot reacquire the lock).  
❌ **No condition variables** (unlike `ReentrantLock`).  

---

## **4. Basic Usage**
### **(a) Write Lock (Exclusive)**
```java
StampedLock lock = new StampedLock();
long stamp = lock.writeLock(); // Blocks until acquired
try {
    // Critical section (exclusive access)
} finally {
    lock.unlockWrite(stamp); // Must pass stamp
}
```

### **(b) Read Lock (Shared)**
```java
long stamp = lock.readLock(); // Blocks until acquired
try {
    // Multiple threads can read
} finally {
    lock.unlockRead(stamp);
}
```

### **(c) Optimistic Read (Non-blocking)**
```java
long stamp = lock.tryOptimisticRead(); // No lock acquired
int value = sharedValue; // Read data
if (!lock.validate(stamp)) { // Check if write occurred
    stamp = lock.readLock(); // Fallback to pessimistic read
    try {
        value = sharedValue;
    } finally {
        lock.unlockRead(stamp);
    }
}
```

---

## **5. Example: Bank Account with StampedLock**
```java
import java.util.concurrent.locks.StampedLock;

public class BankAccount {
    private double balance;
    private final StampedLock lock = new StampedLock();

    // Deposit (write lock)
    public void deposit(double amount) {
        long stamp = lock.writeLock();
        try {
            balance += amount;
        } finally {
            lock.unlockWrite(stamp);
        }
    }

    // Read balance (optimistic read)
    public double getBalance() {
        long stamp = lock.tryOptimisticRead();
        double currentBalance = balance;
        if (!lock.validate(stamp)) { // Check if write occurred
            stamp = lock.readLock(); // Fallback to read lock
            try {
                currentBalance = balance;
            } finally {
                lock.unlockRead(stamp);
            }
        }
        return currentBalance;
    }
}
```

---

## **6. Lock Conversion (Downgrading)**
```java
long stamp = lock.writeLock(); // Acquire write lock
try {
    // Modify data
    stamp = lock.tryConvertToReadLock(stamp); // Downgrade to read lock
    if (stamp == 0L) {
        stamp = lock.readLock(); // Fallback if conversion fails
    }
    // Continue reading
} finally {
    lock.unlock(stamp); // Unlock based on mode
}
```

---

## **7. When to Use StampedLock?**
✅ **Read-heavy, write-light scenarios** (e.g., caching).  
✅ **When optimistic reads can reduce contention**.  
✅ **When lock downgrading is needed**.  
❌ **Not for reentrant locking** (use `ReentrantLock`).  
❌ **Avoid if fairness is required** (no built-in fairness).  

---

## **8. Performance Comparison**
| Lock Type | Read Performance | Write Performance | Optimistic Reads |
|-----------|----------------|------------------|------------------|
| `synchronized` | Slow | Slow | ❌ No |
| `ReentrantLock` | Slow | Moderate | ❌ No |
| `ReadWriteLock` | Fast (shared) | Slow (exclusive) | ❌ No |
| `StampedLock` | **Very Fast** (optimistic) | Moderate | ✅ Yes |

---

## **9. Best Practices**
1. **Prefer optimistic reads** when writes are rare.
2. **Always validate optimistic reads** (`validate(stamp)`).
3. **Use fallback to read lock** if validation fails.
4. **Avoid long critical sections** (can lead to contention).
5. **Downgrade write locks** if transitioning to reads.

---

## **10. Conclusion**
- **`StampedLock` is ideal for read-heavy, low-contention scenarios**.
- **Optimistic reads improve performance** (no blocking).
- **Not reentrant, but supports lock downgrading**.
- **Better than `ReadWriteLock` in high-concurrency cases**.

By using `StampedLock`, you can achieve **higher throughput** in multithreaded applications while maintaining **thread safety**. 🚀

<br/>
<br/>

# **Semaphore in Java - Detailed Explanation with Real-World Use Cases**

## **1. What is a Semaphore?**
A **Semaphore** is a synchronization mechanism that controls access to a shared resource by **limiting the number of threads** that can access it simultaneously. It maintains a set of **permits**:
- Threads **acquire** a permit before accessing the resource.
- Threads **release** the permit when done.
- If no permits are available, threads **block** until one is free.

---

## **2. Key Features**
| Feature | Description |
|---------|-------------|
| **Permits** | Controls how many threads can access a resource. |
| **Fairness** | Can be fair (FIFO) or unfair (default). |
| **Blocking** | Threads wait if no permits are available. |
| **Non-blocking** | `tryAcquire()` attempts without waiting. |
| **Release** | Must manually release permits. |

---

## **3. Types of Semaphores**
### **(a) Counting Semaphore**
- Allows **N threads** to access a resource.
- Example: Database connection pool (max 10 connections).

### **(b) Binary Semaphore (Mutex)**
- Only **1 permit** (like a lock).
- Example: Single-resource access control.

---

## **4. How Semaphore Works?**
```java
Semaphore semaphore = new Semaphore(3); // 3 permits

// Thread 1
semaphore.acquire(); // Takes 1 permit (now 2 left)
// Access resource...
semaphore.release(); // Releases permit (now 3 again)

// Thread 2
if (semaphore.tryAcquire()) { // Try without blocking
    // Access resource...
    semaphore.release();
}
```

---

## **5. Real-World Use Cases**
### **✅ 1. Database Connection Pooling**
```java
public class ConnectionPool {
    private final Semaphore semaphore;
    private final List<Connection> connections;

    public ConnectionPool(int poolSize) {
        semaphore = new Semaphore(poolSize);
        connections = new ArrayList<>(poolSize);
        // Initialize connections...
    }

    public Connection getConnection() throws InterruptedException {
        semaphore.acquire(); // Wait if no permits
        return connections.remove(0);
    }

    public void releaseConnection(Connection conn) {
        connections.add(conn);
        semaphore.release(); // Release permit
    }
}
```
**Why?**  
- Prevents too many connections from overloading the DB.

---

### **✅ 2. Rate Limiting API Calls**
```java
Semaphore rateLimiter = new Semaphore(100); // 100 req/sec

public void callAPI() throws InterruptedException {
    rateLimiter.acquire();
    try {
        // Make API call...
    } finally {
        rateLimiter.release();
    }
}
```
**Why?**  
- Ensures the API isn't flooded with requests.

---

### **✅ 3. Printer Queue Management**
```java
Semaphore printerSemaphore = new Semaphore(2); // 2 printers

public void printDocument(String doc) throws InterruptedException {
    printerSemaphore.acquire();
    try {
        // Send to printer...
    } finally {
        printerSemaphore.release();
    }
}
```
**Why?**  
- Only 2 print jobs run at a time.

---

### **✅ 4. Thread Pool with Bounded Tasks**
```java
ExecutorService executor = Executors.newFixedThreadPool(10);
Semaphore taskLimiter = new Semaphore(5); // Max 5 concurrent tasks

public void submitTask(Runnable task) throws InterruptedException {
    taskLimiter.acquire();
    executor.submit(() -> {
        try {
            task.run();
        } finally {
            taskLimiter.release();
        }
    });
}
```
**Why?**  
- Limits concurrent tasks even if the thread pool is larger.

---

### **✅ 5. Producer-Consumer with Bounded Buffer**
```java
Semaphore emptySlots = new Semaphore(10); // Buffer capacity
Semaphore filledSlots = new Semaphore(0); // Initially empty

// Producer
emptySlots.acquire(); // Wait for empty slot
// Add item to buffer...
filledSlots.release(); // Signal consumer

// Consumer
filledSlots.acquire(); // Wait for filled slot
// Remove item from buffer...
emptySlots.release(); // Signal producer
```
**Why?**  
- Ensures producers don’t overflow the buffer.

---

## **6. Semaphore vs Other Locks**
| Feature | `Semaphore` | `ReentrantLock` | `synchronized` |
|---------|------------|----------------|----------------|
| **Permits** | Multiple | 1 | 1 |
| **Fairness** | Configurable | Configurable | No |
| **Non-blocking** | `tryAcquire()` | `tryLock()` | ❌ No |
| **Release** | Manual | Manual | Automatic |
| **Use Case** | Resource pools | Exclusive access | Simple locking |

---

## **7. Best Practices**
1. **Always release permits** in `finally` to prevent leaks.
2. **Prefer `tryAcquire()`** to avoid deadlocks.
3. **Use fairness mode** if thread starvation is a concern.
4. **Avoid too many permits** (can lead to resource exhaustion).

---

## **8. Conclusion**
- **Use Semaphores for resource pooling, rate limiting, and bounded access.**
- **Better than locks when managing multiple permits.**
- **Essential for real-world scenarios like DB connections, API throttling, and printer queues.**

By mastering `Semaphore`, you can efficiently manage concurrent access in high-performance systems. 🚀

<br/>
<br/>

# **Thread Communication with Condition in Java - Detailed Guide with Real-Time Example**

## **1. What is a Condition in Java?**
A `Condition` is a thread communication mechanism that:
- Allows threads to **wait** (`await()`) until a condition is met
- Enables **signaling** (`signal()`, `signalAll()`) between threads
- Works with `Lock` (unlike `wait()/notify()` which work with `synchronized`)
- Provides **multiple wait sets** per lock (unlike `wait()` which has only one)

## **2. Key Components**
| Component | Description |
|-----------|-------------|
| `await()` | Releases lock and waits (like `wait()`) |
| `signal()` | Wakes one waiting thread (like `notify()`) |
| `signalAll()` | Wakes all waiting threads (like `notifyAll()`) |
| `Lock.newCondition()` | Creates a Condition instance |

## **3. Real-Time Example: Food Delivery System**
Let's model a food delivery app where:
- **Chef (Producer)** prepares food when orders arrive
- **Delivery Agent (Consumer)** picks up prepared orders
- Uses `Condition` to coordinate between them

```java
import java.util.concurrent.locks.*;

class FoodDeliverySystem {
    private final Lock lock = new ReentrantLock();
    private final Condition orderAvailable = lock.newCondition();
    private final Condition deliveryReady = lock.newCondition();
    private String currentOrder = null;
    private boolean orderReady = false;

    // Chef prepares food
    public void prepareOrder(String order) throws InterruptedException {
        lock.lock();
        try {
            // Wait if previous order isn't picked up
            while (orderReady) {
                deliveryReady.await();
            }
            
            System.out.println("Chef preparing: " + order);
            Thread.sleep(2000); // Cooking time
            currentOrder = order;
            orderReady = true;
            orderAvailable.signal(); // Notify delivery agent
        } finally {
            lock.unlock();
        }
    }

    // Delivery agent picks up food
    public String deliverOrder() throws InterruptedException {
        lock.lock();
        try {
            // Wait until order is ready
            while (!orderReady) {
                orderAvailable.await();
            }
            
            System.out.println("Delivering: " + currentOrder);
            String deliveredOrder = currentOrder;
            currentOrder = null;
            orderReady = false;
            deliveryReady.signal(); // Notify chef
            return deliveredOrder;
        } finally {
            lock.unlock();
        }
    }
}
```

## **4. How This Works**
1. **Chef Thread**:
   - Locks the system
   - Checks if previous order was delivered (`while (orderReady)`)
   - If not, waits using `deliveryReady.await()`
   - Prepares food and signals `orderAvailable`

2. **Delivery Agent Thread**:
   - Locks the system
   - Checks if order is ready (`while (!orderReady)`)
   - If not, waits using `orderAvailable.await()`
   - Takes order and signals `deliveryReady`

## **5. Running the System**
```java
public class FoodDeliveryApp {
    public static void main(String[] args) {
        FoodDeliverySystem system = new FoodDeliverySystem();
        
        // Chef thread
        new Thread(() -> {
            try {
                system.prepareOrder("Pizza Margherita");
                system.prepareOrder("Burger with Fries");
                system.prepareOrder("Pasta Alfredo");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        
        // Delivery agent thread
        new Thread(() -> {
            try {
                System.out.println("Delivered: " + system.deliverOrder());
                System.out.println("Delivered: " + system.deliverOrder());
                System.out.println("Delivered: " + system.deliverOrder());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

**Output:**
```
Chef preparing: Pizza Margherita
Delivering: Pizza Margherita
Delivered: Pizza Margherita
Chef preparing: Burger with Fries
Delivering: Burger with Fries
Delivered: Burger with Fries
Chef preparing: Pasta Alfredo
Delivering: Pasta Alfredo
Delivered: Pasta Alfredo
```

## **6. Why Use Condition Over wait()/notify()?**
1. **Multiple Conditions**: Single lock can have multiple conditions
   - In our example: `orderAvailable` and `deliveryReady`
2. **Fairness**: Can create fair locks
3. **Interruptible**: `await()` is interruptible
4. **Timed Waits**: `awaitNanos()`, `awaitUntil()`

## **7. Common Real-World Use Cases**
1. **Producer-Consumer Systems** (like our food delivery)
2. **Thread Pools** (worker threads waiting for tasks)
3. **Resource Allocation** (database connections)
4. **Event Processing** (handling asynchronous events)

## **8. Best Practices**
1. **Always use await() in a loop** (spurious wakeups can occur)
2. **Release locks in finally blocks**
3. **Prefer signalAll()** unless you specifically need signal()
4. **Document your conditions** clearly in code

This pattern is widely used in:
- Message queues (Kafka, RabbitMQ consumers)
- Web server request handling
- Batch processing systems
- Game engine event systems

The Condition mechanism provides a robust way to coordinate threads in complex synchronization scenarios while maintaining clean code structure.