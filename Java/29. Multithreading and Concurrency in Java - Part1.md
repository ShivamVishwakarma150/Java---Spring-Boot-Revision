# **Multithreading in Java - Part 1: Introduction, Process vs Thread, and Basics**

In this guide, we'll cover:
1. **Introduction to Multithreading**
2. **Process vs Thread**
3. **Memory Management in Multithreading**
4. **Creating Threads in Java**
5. **Thread Lifecycle**
6. **Synchronization (in later parts)**

---

## **1. Introduction to Multithreading**
Multithreading allows a program to perform multiple operations **concurrently** (appearing to run simultaneously).  
- **Benefits**:
  - Improved performance (parallel execution).
  - Better CPU utilization.
  - Responsiveness in applications (e.g., UI remains responsive while background tasks run).
- **Challenges**:
  - **Concurrency issues** (race conditions, deadlocks).
  - **Synchronization overhead** (locking mechanisms slow down performance).
  - **Debugging complexity**.

---

## **2. Process vs Thread**
### **Process**
- An **instance of a running program** (e.g., running `java Main` creates a process).
- **Independent** (has its own memory, resources).
- **OS allocates memory (heap, stack, code segment)**.
- **No shared memory between processes** (unless using IPC like sockets).

### **Thread**
- A **lightweight sub-process** inside a process.
- **Shares memory (heap, global variables)** with other threads in the same process.
- **Has its own stack, program counter (PC), and registers**.
- **Threads in the same process share:**
  - **Code segment** (compiled bytecode).
  - **Data segment** (static/global variables).
  - **Heap** (objects created with `new`).

### **Key Differences**
| **Feature**       | **Process**                  | **Thread**                     |
|-------------------|-----------------------------|--------------------------------|
| **Memory**        | Independent (own heap)      | Shared (same heap)             |
| **Creation Cost** | Heavy (OS resources)        | Lightweight (faster)           |
| **Communication** | IPC (sockets, pipes)        | Direct (shared memory)         |
| **Crash Impact**  | Other processes unaffected   | Can crash entire process       |

---

## **3. Memory Management in Multithreading**
When a Java program runs:
1. **JVM creates a process**.
2. **Each process gets a JVM instance** (with its own heap, stack, etc.).
3. **Threads share:**
   - **Code Segment** (machine instructions).
   - **Data Segment** (static/global variables).
   - **Heap** (dynamically allocated objects).
4. **Threads have their own:**
   - **Stack** (local variables, method calls).
   - **Program Counter (PC)** (points to next instruction).
   - **Registers** (CPU context for execution).

### **Example:**
```java
public class MemoryExample {
    static int globalVar = 10; // Stored in Data Segment
    public static void main(String[] args) {
        int localVar = 20; // Stored in Thread's Stack
        Object obj = new Object(); // Stored in Heap (shared)
    }
}
```
- `globalVar` → Shared across threads.
- `localVar` → Thread-specific (stack).
- `obj` → Shared (heap).

---

## **4. Creating Threads in Java**
### **Method 1: Extending `Thread` Class**
```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // Starts a new thread
    }
}
```
**Output:**
```
Thread running: Thread-0
```

### **Method 2: Implementing `Runnable` Interface (Preferred)**
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}
```
**Why `Runnable` is better?**
- Java supports single inheritance (can’t extend `Thread` if already extending another class).
- More flexible (can pass `Runnable` to thread pools).

---

## **5. Thread Lifecycle**
A thread goes through **5 states**:
1. **New**: Created but not started (`new Thread()`).
2. **Runnable**: Ready to run (`start()` called, waiting for CPU).
3. **Running**: Executing (`run()` method is running).
4. **Blocked/Waiting**: Waiting for a lock or I/O.
5. **Terminated**: Thread completes execution.

### **Example:**
```java
public class ThreadLifecycle {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread running...");
            try {
                Thread.sleep(1000); // Moves to TIMED_WAITING
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        System.out.println("State: " + t1.getState()); // NEW
        t1.start();
        System.out.println("State: " + t1.getState()); // RUNNABLE
        Thread.sleep(500);
        System.out.println("State: " + t1.getState()); // TIMED_WAITING
        t1.join();
        System.out.println("State: " + t1.getState()); // TERMINATED
    }
}
```
**Output:**
```
State: NEW
State: RUNNABLE
Thread running...
State: TIMED_WAITING
State: TERMINATED
```

---

## **6. Key Takeaways**
- **Process** = Independent program instance (own memory).
- **Thread** = Lightweight sub-process (shares memory).
- **Threads share heap, code, and data segments** but have their own stack and PC.
- **Two ways to create threads**:
  - Extend `Thread` (not recommended due to Java’s single inheritance).
  - Implement `Runnable` (preferred).
- **Thread states**: New → Runnable → Running → Blocked/Waiting → Terminated.

---
