# **Multithreading in Java - Part 3: Producer-Consumer, Deprecated Methods, Thread Joining, Priority, and Daemon Threads**

## **1. Producer-Consumer Problem**
### **Problem Statement**
- **Producer** produces items and adds them to a shared queue.
- **Consumer** consumes items from the queue.
- **Constraints**:
  - If the queue is **full**, the producer must **wait**.
  - If the queue is **empty**, the consumer must **wait**.

### **Solution Using `wait()` and `notify()`**
- **Shared Resource (Queue)** is accessed by both threads.
- **`synchronized`** methods ensure thread safety.
- **`wait()`** releases the lock and puts the thread in a waiting state.
- **`notify()`** wakes up a waiting thread.

### **Implementation**
```java
import java.util.LinkedList;
import java.util.Queue;

class SharedBuffer {
    private final Queue<Integer> queue;
    private final int bufferSize;

    public SharedBuffer(int bufferSize) {
        this.bufferSize = bufferSize;
        this.queue = new LinkedList<>();
    }

    public synchronized void produce(int item) throws InterruptedException {
        while (queue.size() == bufferSize) {
            System.out.println("Buffer full. Producer waiting...");
            wait(); // Wait if buffer is full
        }
        queue.add(item);
        System.out.println("Produced: " + item);
        notify(); // Notify consumer that an item is added
    }

    public synchronized void consume() throws InterruptedException {
        while (queue.isEmpty()) {
            System.out.println("Buffer empty. Consumer waiting...");
            wait(); // Wait if buffer is empty
        }
        int item = queue.poll();
        System.out.println("Consumed: " + item);
        notify(); // Notify producer that space is available
    }
}

public class ProducerConsumerExample {
    public static void main(String[] args) {
        SharedBuffer buffer = new SharedBuffer(3); // Buffer size = 3

        // Producer Thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 6; i++) {
                    buffer.produce(i);
                    Thread.sleep(1000); // Simulate production time
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // Consumer Thread
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 6; i++) {
                    buffer.consume();
                    Thread.sleep(1500); // Simulate consumption time
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();
    }
}
```

### **Output Explanation**
- **Producer** adds items until the buffer is full, then **waits**.
- **Consumer** removes items until the buffer is empty, then **waits**.
- **`notify()`** ensures the other thread is awakened when space/item is available.

---

## **2. Why `stop()`, `resume()`, and `suspend()` are Deprecated**
### **Problems with Deprecated Methods**
| Method | Issue |
|--------|-------|
| **`stop()`** | Abruptly terminates the thread **without releasing locks**, leading to **deadlocks**. |
| **`suspend()`** | Pauses the thread **without releasing locks**, causing potential **deadlocks**. |
| **`resume()`** | Used to wake a suspended thread, but since `suspend()` is unsafe, `resume()` is also deprecated. |

### **Safe Alternative: `wait()` and `notify()`**
- **`wait()`** releases the lock before pausing.
- **`notify()`** safely wakes up waiting threads.

### **Example of `suspend()` Causing Deadlock**
```java
class SharedResource {
    synchronized void produce() {
        System.out.println("Lock acquired by " + Thread.currentThread().getName());
        try {
            Thread.sleep(8000); // Simulate work
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Lock released by " + Thread.currentThread().getName());
    }
}

public class DeprecatedMethodsExample {
    public static void main(String[] args) throws InterruptedException {
        SharedResource resource = new SharedResource();
        
        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 calling produce()");
            resource.produce();
        });

        Thread t2 = new Thread(() -> {
            try {
                Thread.sleep(1000); // Let t1 acquire lock first
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 2 calling produce()");
            resource.produce();
        });

        t1.start();
        t2.start();

        Thread.sleep(2000); // Let t1 acquire lock
        t1.suspend(); // Deadlock: t1 holds lock, t2 waits forever
        System.out.println("Thread 1 suspended, but lock not released!");

        // t1.resume(); // Uncomment to fix deadlock (but still unsafe)
    }
}
```

### **Output**
```
Thread 1 calling produce()
Lock acquired by Thread-0
Thread 2 calling produce()
Thread 1 suspended, but lock not released!
```
- **Thread 2** is stuck waiting forever because **Thread 1** was suspended **without releasing the lock**.

---

## **3. Thread Joining**
### **What is `join()`?**
- **`thread.join()`** makes the **current thread wait** until the specified thread finishes execution.
- Useful for **coordinating threads** (e.g., waiting for initialization before proceeding).

### **Example**
```java
public class ThreadJoinExample {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started");

        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 started");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 1 completed");
        });

        t1.start();
        t1.join(); // Main thread waits for t1 to finish

        System.out.println("Main thread completed");
    }
}
```

### **Output**
```
Main thread started
Thread 1 started
Thread 1 completed
Main thread completed
```
- **Main thread waits** for `t1` to finish before proceeding.

---

## **4. Thread Priority**
### **What is Thread Priority?**
- **Priority (1-10)** hints to the JVM about thread scheduling.
- **1 (MIN_PRIORITY), 5 (NORM_PRIORITY), 10 (MAX_PRIORITY)**.
- **No strict guarantee**—just a suggestion.

### **Example**
```java
public class ThreadPriorityExample {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> System.out.println("Thread 1 (Priority 1)"));
        Thread t2 = new Thread(() -> System.out.println("Thread 2 (Priority 5)"));
        Thread t3 = new Thread(() -> System.out.println("Thread 3 (Priority 10)"));

        t1.setPriority(Thread.MIN_PRIORITY);
        t2.setPriority(Thread.NORM_PRIORITY);
        t3.setPriority(Thread.MAX_PRIORITY);

        t1.start();
        t2.start();
        t3.start();
    }
}
```
- **Possible Output (Order Not Guaranteed)**:
```
Thread 3 (Priority 10)
Thread 2 (Priority 5)
Thread 1 (Priority 1)
```

---

## **5. Daemon Threads**
### **What is a Daemon Thread?**
- Runs in the **background** (e.g., garbage collector, auto-save).
- **Dies automatically** when all **user threads** finish.

### **Example**
```java
public class DaemonThreadExample {
    public static void main(String[] args) {
        System.out.println("Main thread started");

        Thread daemonThread = new Thread(() -> {
            while (true) {
                System.out.println("Daemon thread running...");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        daemonThread.setDaemon(true); // Mark as daemon
        daemonThread.start();

        try {
            Thread.sleep(3000); // Main thread sleeps
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread completed");
    }
}
```
### **Output**
```
Main thread started
Daemon thread running...
Daemon thread running...
Daemon thread running...
Main thread completed
```
- **Daemon thread stops** when the **main thread (user thread) finishes**.

---

## **Summary**
| Topic | Key Takeaway |
|--------|--------------|
| **Producer-Consumer** | Use `wait()` and `notify()` for thread coordination. |
| **Deprecated Methods** | Avoid `stop()`, `suspend()`, `resume()`—use `wait()`/`notify()`. |
| **Thread Joining** | `join()` makes a thread wait for another to finish. |
| **Thread Priority** | Just a hint—no strict scheduling guarantee. |
| **Daemon Threads** | Background threads that die when user threads finish. |
