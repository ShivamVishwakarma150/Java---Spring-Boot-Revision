# Native Queries and Criteria API in JPA

## Native Queries in JPA

Native queries allow you to execute plain SQL directly against your database, bypassing JPA's abstraction layer.

### Key Characteristics:
- **Database dependent** - If you change databases, queries may need modification
- **No caching** - Doesn't use JPA's persistence context caching
- **No lifecycle management** - Entities aren't managed by JPA
- **More flexible** - Can execute complex queries that JPQL can't handle

### When to Use Native Queries:
- Complex queries involving JSON columns
- Joins between unrelated entities
- Queries that return non-entity results (like aggregates)
- When you need better performance for bulk operations

### Basic Native Query Example:

```java
@Repository
public interface UserDetailRepository extends JpaRepository<UserDetail, Long> {
    
    @Query(value = "SELECT * FROM user_detail WHERE user_name = :name", 
           nativeQuery = true)
    List<UserDetail> findByNameNative(@Param("name") String name);
}
```

### Handling Partial Field Results

When your query doesn't return all entity fields, you need explicit mapping:

#### Option 1: Using @SqlResultSetMapping

```java
// In your entity class
@Entity
@NamedNativeQuery(
    name = "UserDetail.findUsernameAndPhone",
    query = "SELECT user_name, phone FROM user_detail",
    resultSetMapping = "UserDTOMapping"
)
@SqlResultSetMapping(
    name = "UserDTOMapping",
    classes = @ConstructorResult(
        targetClass = UserDTO.class,
        columns = {
            @ColumnResult(name = "user_name", type = String.class),
            @ColumnResult(name = "phone", type = String.class)
        }
    )
)
public class UserDetail { ... }

// DTO class
public class UserDTO {
    private String username;
    private String phone;
    
    public UserDTO(String username, String phone) {
        this.username = username;
        this.phone = phone;
    }
    // getters/setters
}

// Repository method
@Query(name = "UserDetail.findUsernameAndPhone", nativeQuery = true)
List<UserDTO> findUsernameAndPhoneNative();
```

#### Option 2: Manual Mapping with Object Arrays

```java
@Query(value = "SELECT user_name, phone FROM user_detail", nativeQuery = true)
List<Object[]> findUsernameAndPhoneNative();

// In service layer
public List<UserDTO> getUsernameAndPhone() {
    return userDetailRepository.findUsernameAndPhoneNative().stream()
        .map(row -> new UserDTO((String)row[0], (String)row[1]))
        .collect(Collectors.toList());
}
```

### Dynamic Native Queries

For queries that need to be built dynamically:

```java
public List<UserDetail> findUsersDynamic(String username, String phone) {
    StringBuilder queryBuilder = new StringBuilder("SELECT * FROM user_detail WHERE 1=1");
    List<Object> parameters = new ArrayList<>();
    
    if (username != null && !username.isEmpty()) {
        queryBuilder.append(" AND user_name = ?");
        parameters.add(username);
    }
    
    if (phone != null && !phone.isEmpty()) {
        queryBuilder.append(" AND phone = ?");
        parameters.add(phone);
    }
    
    Query query = entityManager.createNativeQuery(queryBuilder.toString(), UserDetail.class);
    
    for (int i = 0; i < parameters.size(); i++) {
        query.setParameter(i + 1, parameters.get(i));
    }
    
    return query.getResultList();
}
```

### Pagination and Sorting with Native Queries

#### Using @Query annotation:

```java
@Query(value = "SELECT * FROM user_detail ORDER BY phone DESC",
       countQuery = "SELECT COUNT(*) FROM user_detail",
       nativeQuery = true)
Page<UserDetail> findAllUsersNative(Pageable pageable);
```

#### With dynamic queries:

```java
public List<UserDetail> findUsersWithPagination(int page, int size, String sortField, String sortDir) {
    StringBuilder queryBuilder = new StringBuilder("SELECT * FROM user_detail");
    
    if (sortField != null) {
        queryBuilder.append(" ORDER BY ").append(sortField)
                    .append(" ").append(sortDir);
    }
    
    queryBuilder.append(" LIMIT ? OFFSET ?");
    
    Query query = entityManager.createNativeQuery(queryBuilder.toString(), UserDetail.class);
    query.setParameter(1, size);
    query.setParameter(2, page * size);
    
    return query.getResultList();
}
```

## Criteria API

The Criteria API provides a type-safe way to build dynamic queries programmatically.

### Key Advantages:
- Type-safe - Compile-time checking
- Database independent
- Supports dynamic query building
- Works with JPA entity lifecycle

### Basic Criteria API Structure:

1. Get `CriteriaBuilder` from `EntityManager`
2. Create `CriteriaQuery` from builder
3. Define root entity (FROM clause)
4. Build predicates (WHERE conditions)
5. Execute query

### Simple Criteria Query Example:

```java
public List<UserDetail> findByPhoneCriteria(String phone) {
    // 1. Get CriteriaBuilder
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    
    // 2. Create CriteriaQuery
    CriteriaQuery<UserDetail> cq = cb.createQuery(UserDetail.class);
    
    // 3. Define root (FROM clause)
    Root<UserDetail> user = cq.from(UserDetail.class);
    
    // 4. Build predicate (WHERE condition)
    Predicate phonePredicate = cb.equal(user.get("phone"), phone);
    
    // 5. Combine query parts
    cq.where(phonePredicate);
    
    // 6. Execute query
    return entityManager.createQuery(cq).getResultList();
}
```

### Multiple Conditions:

```java
Predicate namePredicate = cb.equal(user.get("name"), "John");
Predicate phonePredicate = cb.equal(user.get("phone"), "12345");

// AND condition
cq.where(cb.and(namePredicate, phonePredicate));

// OR condition
cq.where(cb.or(namePredicate, phonePredicate));
```

### Partial Field Selection:

```java
public List<UserDTO> findUsernameAndPhoneCriteria() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
    Root<UserDetail> user = cq.from(UserDetail.class);
    
    // Select specific fields
    cq.multiselect(user.get("name"), user.get("phone"));
    
    List<Object[]> results = entityManager.createQuery(cq).getResultList();
    
    return results.stream()
        .map(row -> new UserDTO((String)row[0], (String)row[1]))
        .collect(Collectors.toList());
}
```

### Joins:

```java
public List<Object[]> findUserWithAddress() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
    
    Root<UserDetail> user = cq.from(UserDetail.class);
    Join<UserDetail, Address> address = user.join("address", JoinType.INNER);
    
    cq.multiselect(user.get("name"), address.get("city"));
    
    return entityManager.createQuery(cq).getResultList();
}
```

### Pagination and Sorting:

```java
public List<UserDetail> findAllUsersCriteria(int page, int size, String sortField, String sortDir) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<UserDetail> cq = cb.createQuery(UserDetail.class);
    Root<UserDetail> user = cq.from(UserDetail.class);
    
    // Sorting
    if (sortField != null) {
        Order order = sortDir.equalsIgnoreCase("DESC") 
            ? cb.desc(user.get(sortField))
            : cb.asc(user.get(sortField));
        cq.orderBy(order);
    }
    
    TypedQuery<UserDetail> query = entityManager.createQuery(cq);
    
    // Pagination
    query.setFirstResult(page * size);
    query.setMaxResults(size);
    
    return query.getResultList();
}
```

### Common Predicate Methods:

```java
// Comparison
cb.equal(root.get("field"), value)      // field = value
cb.notEqual(root.get("field"), value)   // field != value
cb.gt(root.get("field"), value)         // field > value
cb.ge(root.get("field"), value)         // field >= value
cb.lt(root.get("field"), value)         // field < value
cb.le(root.get("field"), value)         // field <= value

// String operations
cb.like(root.get("field"), "pattern")   // field LIKE pattern
cb.notLike(root.get("field"), "pattern")

// Logical
cb.and(predicate1, predicate2)          // condition1 AND condition2
cb.or(predicate1, predicate2)           // condition1 OR condition2
cb.not(predicate)                       // NOT condition

// Collection
cb.in(root.get("field")).value(1).value(2).value(3) // field IN (1,2,3)
```

## Choosing Between Native Queries and Criteria API

| Feature                | Native Queries | Criteria API |
|------------------------|----------------|--------------|
| Database independence  | No             | Yes          |
| Type safety            | No             | Yes          |
| Dynamic query building | Manual         | Built-in     |
| Performance            | Faster         | Slightly slower |
| Complexity             | Simple SQL     | More complex |
| Caching                | No             | Yes          |
| Lifecycle management   | No             | Yes          |

Use native queries when:
- You need maximum performance
- You're using database-specific features
- You have complex queries that are hard to express in JPQL/Criteria

Use Criteria API when:
- You need database independence
- You want type safety
- You need to build dynamic queries programmatically
- You want to maintain JPA entity lifecycle

<br/>
<br/>

# **Criteria API in JPA - Detailed Explanation with Code Examples**

The **Criteria API** in JPA provides a **type-safe, programmatic** way to build dynamic queries. Unlike JPQL (which is string-based), the Criteria API uses Java objects to construct queries, reducing errors and improving maintainability.

---

## **1. Why Use Criteria API?**
- **Type-safe**: Compile-time checking of field names and operations.
- **Dynamic Queries**: Easily build queries based on runtime conditions.
- **Avoids SQL Injection**: No string concatenation in queries.
- **Database Independent**: Works across different databases.
- **Supports Complex Joins**: Handles relationships between entities smoothly.

---

## **2. Core Components of Criteria API**
| Component | Purpose |
|-----------|---------|
| `CriteriaBuilder` | Factory for creating criteria queries, predicates, expressions |
| `CriteriaQuery` | Defines the structure of the query (SELECT, FROM, WHERE, etc.) |
| `Root` | Represents the root entity in the FROM clause |
| `Predicate` | Represents WHERE conditions (e.g., `=`, `>`, `LIKE`) |
| `Join` | Handles JOIN operations between entities |
| `Order` | Used for sorting (ORDER BY) |
| `TypedQuery` | Executes the query and returns results |

---

## **3. Basic Criteria Query Example**
### **Find all users with a given name**
```java
public List<User> findUsersByName(String name) {
    // 1. Get CriteriaBuilder from EntityManager
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();

    // 2. Create CriteriaQuery (specify return type)
    CriteriaQuery<User> cq = cb.createQuery(User.class);

    // 3. Define the root entity (FROM clause)
    Root<User> user = cq.from(User.class);

    // 4. Define WHERE condition (Predicate)
    Predicate namePredicate = cb.equal(user.get("name"), name);

    // 5. Apply WHERE to CriteriaQuery
    cq.where(namePredicate);

    // 6. Execute query
    TypedQuery<User> query = entityManager.createQuery(cq);
    return query.getResultList();
}
```
**Explanation**:
1. `CriteriaBuilder` helps create query components.
2. `CriteriaQuery<User>` means the query returns `User` objects.
3. `Root<User>` defines the main entity (`FROM User`).
4. `Predicate` defines the condition (`WHERE name = ?`).
5. `cq.where()` applies the condition.
6. `TypedQuery` executes the query.

---

## **4. Dynamic Query Building**
### **Find users with optional filters (name, email, age)**
```java
public List<User> findUsers(String name, String email, Integer age) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> cq = cb.createQuery(User.class);
    Root<User> user = cq.from(User.class);

    List<Predicate> predicates = new ArrayList<>();

    if (name != null) {
        predicates.add(cb.equal(user.get("name"), name));
    }
    if (email != null) {
        predicates.add(cb.like(user.get("email"), "%" + email + "%"));
    }
    if (age != null) {
        predicates.add(cb.gt(user.get("age"), age)); // age > ?
    }

    // Apply all predicates (AND condition)
    cq.where(predicates.toArray(new Predicate[0]));

    return entityManager.createQuery(cq).getResultList();
}
```
**Explanation**:
- Conditions are added dynamically.
- `cb.like()` is used for partial string matching.
- `cb.gt()` means "greater than".
- `cq.where(predicates)` applies all conditions with `AND`.

---

## **5. Joins (1-to-Many, Many-to-Many)**
### **Find users with their orders (One-to-Many)**
```java
public List<Object[]> findUsersWithOrders() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
    Root<User> user = cq.from(User.class);

    // Join with orders (User has List<Order>)
    Join<User, Order> orders = user.join("orders", JoinType.LEFT);

    // Select user.name and order.total
    cq.multiselect(user.get("name"), orders.get("total"));

    return entityManager.createQuery(cq).getResultList();
}
```
**Explanation**:
- `Join<User, Order>` defines the relationship.
- `JoinType.LEFT` ensures users without orders are included.
- `cq.multiselect()` selects specific columns.

---

## **6. Sorting (ORDER BY)**
### **Find users sorted by name (ASC/DESC)**
```java
public List<User> findAllUsersSorted(String sortField, String sortDirection) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> cq = cb.createQuery(User.class);
    Root<User> user = cq.from(User.class);

    // Apply sorting
    Order order = sortDirection.equalsIgnoreCase("DESC") 
        ? cb.desc(user.get(sortField)) 
        : cb.asc(user.get(sortField));
    
    cq.orderBy(order);

    return entityManager.createQuery(cq).getResultList();
}
```
**Explanation**:
- `cb.asc()` for ascending, `cb.desc()` for descending.
- `cq.orderBy()` applies sorting.

---

## **7. Pagination (LIMIT & OFFSET)**
### **Find users with pagination (page, size)**
```java
public List<User> findUsersWithPagination(int page, int size) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> cq = cb.createQuery(User.class);
    Root<User> user = cq.from(User.class);

    TypedQuery<User> query = entityManager.createQuery(cq);

    // Pagination
    query.setFirstResult(page * size); // OFFSET
    query.setMaxResults(size);         // LIMIT

    return query.getResultList();
}
```
**Explanation**:
- `setFirstResult()` = `OFFSET` (skips previous pages).
- `setMaxResults()` = `LIMIT` (number of records per page).

---

## **8. Aggregations (COUNT, MAX, MIN, AVG)**
### **Count users by age group**
```java
public Long countUsersByAge(int age) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Long> cq = cb.createQuery(Long.class);
    Root<User> user = cq.from(User.class);

    // WHERE age > ?
    cq.where(cb.gt(user.get("age"), age));

    // SELECT COUNT(*)
    cq.select(cb.count(user));

    return entityManager.createQuery(cq).getSingleResult();
}
```
**Explanation**:
- `cb.count()` = `COUNT(*)`.
- `cb.max()`, `cb.min()`, `cb.avg()` are also available.

---

## **9. Subqueries**
### **Find users with orders above average**
```java
public List<User> findUsersWithOrdersAboveAverage() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> cq = cb.createQuery(User.class);
    Root<User> user = cq.from(User.class);

    // Subquery to find average order total
    Subquery<Double> subquery = cq.subquery(Double.class);
    Root<Order> order = subquery.from(Order.class);
    subquery.select(cb.avg(order.get("total")));

    // WHERE orders.total > (SELECT AVG(total) FROM Order)
    Join<User, Order> orders = user.join("orders");
    cq.where(cb.gt(orders.get("total"), subquery));

    return entityManager.createQuery(cq).getResultList();
}
```
**Explanation**:
- `Subquery` creates a nested query.
- Used in `WHERE` condition.

---

## **10. Summary & Best Practices**
### **When to Use Criteria API?**
✅ **Dynamic queries** (filters change at runtime).  
✅ **Type-safe queries** (avoid typos in field names).  
✅ **Complex joins** (handles relationships well).  
✅ **Pagination & Sorting** (easy to implement).  

### **When to Avoid?**
❌ **Simple static queries** (JPQL is simpler).  
❌ **Native SQL features** (use `@NativeQuery` instead).  

### **Best Practices**
✔ Use **metamodel classes** (`User_.name` instead of `"name"`) for type safety.  
✔ **Reuse `CriteriaBuilder`** for better performance.  
✔ **Extract predicates** into methods for reusability.  

---
## **Final Thoughts**
The **Criteria API** is powerful for **dynamic, type-safe queries** in JPA. While it has a steeper learning curve than JPQL, it provides better maintainability and flexibility for complex queries.  

<br/>
<br/>

# **Common Predicate Methods in JPA Criteria API (Detailed Guide)**

Predicates in the Criteria API are used to define **WHERE conditions** in queries. The `CriteriaBuilder` provides various methods to create these predicates. Below is a comprehensive breakdown of the most commonly used predicate methods.

---

## **1. Basic Comparison Predicates**
These are used for simple comparisons (`=`, `!=`, `>`, `<`, etc.).

### **a) `equal()` - Checks if two values are equal**
```java
Predicate equalPredicate = cb.equal(root.get("name"), "John");
// WHERE name = 'John'
```

### **b) `notEqual()` - Checks if two values are not equal**
```java
Predicate notEqualPredicate = cb.notEqual(root.get("age"), 30);
// WHERE age != 30
```

### **c) `greaterThan()` (`gt`) - Checks if a value is greater than another**
```java
Predicate gtPredicate = cb.greaterThan(root.get("salary"), 50000);
// WHERE salary > 50000
```

### **d) `greaterThanOrEqualTo()` (`ge`) - Checks if a value is greater than or equal to another**
```java
Predicate gePredicate = cb.ge(root.get("age"), 18);
// WHERE age >= 18
```

### **e) `lessThan()` (`lt`) - Checks if a value is less than another**
```java
Predicate ltPredicate = cb.lessThan(root.get("score"), 60);
// WHERE score < 60
```

### **f) `lessThanOrEqualTo()` (`le`) - Checks if a value is less than or equal to another**
```java
Predicate lePredicate = cb.le(root.get("price"), 100.0);
// WHERE price <= 100.0
```

---

## **2. String Predicates**
Used for string comparisons (`LIKE`, `NOT LIKE`, `LENGTH`, etc.).

### **a) `like()` - Checks if a string matches a pattern**
```java
Predicate likePredicate = cb.like(root.get("email"), "%@gmail.com");
// WHERE email LIKE '%@gmail.com'
```

### **b) `notLike()` - Checks if a string does not match a pattern**
```java
Predicate notLikePredicate = cb.notLike(root.get("name"), "A%");
// WHERE name NOT LIKE 'A%'
```

### **c) `length()` - Checks the length of a string**
```java
Predicate lengthPredicate = cb.gt(cb.length(root.get("description")), 100);
// WHERE LENGTH(description) > 100
```

### **d) `trim()` - Removes whitespace before comparison**
```java
Predicate trimPredicate = cb.equal(cb.trim(root.get("username")), "admin");
// WHERE TRIM(username) = 'admin'
```

---

## **3. Logical Predicates**
Used to combine multiple predicates (`AND`, `OR`, `NOT`).

### **a) `and()` - Combines predicates with `AND`**
```java
Predicate andPredicate = cb.and(
    cb.equal(root.get("role"), "ADMIN"),
    cb.gt(root.get("loginCount"), 10)
);
// WHERE role = 'ADMIN' AND loginCount > 10
```

### **b) `or()` - Combines predicates with `OR`**
```java
Predicate orPredicate = cb.or(
    cb.equal(root.get("status"), "ACTIVE"),
    cb.equal(root.get("status"), "PENDING")
);
// WHERE status = 'ACTIVE' OR status = 'PENDING'
```

### **c) `not()` - Negates a predicate**
```java
Predicate notPredicate = cb.not(cb.equal(root.get("isDeleted"), true));
// WHERE NOT (isDeleted = true)
```

---

## **4. Collection Predicates**
Used for checking values in collections (`IN`, `IS EMPTY`, `IS NOT EMPTY`).

### **a) `in()` - Checks if a value is in a list**
```java
CriteriaBuilder.In<String> inPredicate = cb.in(root.get("department"));
inPredicate.value("IT").value("HR").value("Finance");
// WHERE department IN ('IT', 'HR', 'Finance')
```

### **b) `isEmpty()` - Checks if a collection is empty**
```java
Predicate isEmptyPredicate = cb.isEmpty(root.get("orders"));
// WHERE orders IS EMPTY
```

### **c) `isNotEmpty()` - Checks if a collection is not empty**
```java
Predicate isNotEmptyPredicate = cb.isNotEmpty(root.get("comments"));
// WHERE comments IS NOT EMPTY
```

---

## **5. Null Checks**
Used to check if a field is `NULL` or not.

### **a) `isNull()` - Checks if a field is `NULL`**
```java
Predicate isNullPredicate = cb.isNull(root.get("middleName"));
// WHERE middleName IS NULL
```

### **b) `isNotNull()` - Checks if a field is not `NULL`**
```java
Predicate isNotNullPredicate = cb.isNotNull(root.get("email"));
// WHERE email IS NOT NULL
```

---

## **6. Date & Time Predicates**
Used for date/time comparisons.

### **a) `between()` - Checks if a value is within a range**
```java
Date startDate = ...;
Date endDate = ...;
Predicate betweenPredicate = cb.between(root.get("createdAt"), startDate, endDate);
// WHERE createdAt BETWEEN :startDate AND :endDate
```

### **b) `currentDate()` - Compares with the current date**
```java
Predicate currentDatePredicate = cb.greaterThan(root.get("expiryDate"), cb.currentDate());
// WHERE expiryDate > CURRENT_DATE
```

---

## **7. Advanced Predicates**
### **a) `exists()` - Checks if a subquery returns any rows**
```java
Subquery<Long> subquery = cq.subquery(Long.class);
Root<Order> order = subquery.from(Order.class);
subquery.select(cb.literal(1L)).where(cb.equal(order.get("user"), root));

Predicate existsPredicate = cb.exists(subquery);
// WHERE EXISTS (SELECT 1 FROM Order o WHERE o.user = user)
```

### **b) `all()`, `any()`, `some()` - Used with subqueries**
```java
Subquery<Integer> subquery = cq.subquery(Integer.class);
Root<Order> order = subquery.from(Order.class);
subquery.select(order.get("amount"));

Predicate allPredicate = cb.gt(root.get("creditLimit"), cb.all(subquery));
// WHERE creditLimit > ALL (SELECT amount FROM Order)
```

---

## **8. Combining Predicates Dynamically**
### **Example: Building a dynamic WHERE clause**
```java
List<Predicate> predicates = new ArrayList<>();

if (name != null) {
    predicates.add(cb.like(root.get("name"), "%" + name + "%"));
}
if (minAge != null) {
    predicates.add(cb.ge(root.get("age"), minAge));
}
if (maxAge != null) {
    predicates.add(cb.le(root.get("age"), maxAge));
}

cq.where(predicates.toArray(new Predicate[0]));
```

---

## **Summary Table of Common Predicate Methods**
| Method | Example | SQL Equivalent |
|--------|---------|----------------|
| `equal()` | `cb.equal(root.get("name"), "John")` | `name = 'John'` |
| `notEqual()` | `cb.notEqual(root.get("age"), 30)` | `age != 30` |
| `greaterThan()` | `cb.gt(root.get("salary"), 50000)` | `salary > 50000` |
| `lessThan()` | `cb.lt(root.get("score"), 60)` | `score < 60` |
| `like()` | `cb.like(root.get("email"), "%@gmail.com")` | `email LIKE '%@gmail.com'` |
| `and()` | `cb.and(pred1, pred2)` | `cond1 AND cond2` |
| `or()` | `cb.or(pred1, pred2)` | `cond1 OR cond2` |
| `not()` | `cb.not(pred)` | `NOT (cond)` |
| `in()` | `cb.in(root.get("dept")).value("IT")` | `dept IN ('IT')` |
| `isNull()` | `cb.isNull(root.get("middleName"))` | `middleName IS NULL` |
| `between()` | `cb.between(root.get("date"), start, end)` | `date BETWEEN start AND end` |

---

## **Best Practices**
✔ **Use `CriteriaBuilder` methods** instead of raw strings for type safety.  
✔ **Combine predicates dynamically** for flexible queries.  
✔ **Use `@StaticMetamodel` (e.g., `User_.name`)** to avoid typos in field names.  
✔ **Avoid too many `OR` conditions** (can impact performance).  

---

### **Final Thoughts**
The **Criteria API's predicate methods** provide a **powerful, type-safe** way to build dynamic queries in JPA. By mastering these methods, you can write **flexible, maintainable, and efficient** database queries.  

<br/>
<br/>

# **Selecting Multiple Fields in JPA Criteria API**

When using the Criteria API, you often need to select **specific columns** rather than entire entities. This improves performance by fetching only the required data. Below are different ways to select multiple fields with detailed examples.

---

## **1. Selecting Multiple Fields as `Object[]`**
### **Use Case:** Fetching `name`, `email`, and `age` from `User`
```java
public List<Object[]> findUserDetails() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
    Root<User> user = cq.from(User.class);

    // Select specific fields
    cq.multiselect(
        user.get("name"),
        user.get("email"),
        user.get("age")
    );

    return entityManager.createQuery(cq).getResultList();
}
```
### **How to Access Results**
```java
List<Object[]> results = findUserDetails();
for (Object[] row : results) {
    String name = (String) row[0];  // Index 0 = name
    String email = (String) row[1]; // Index 1 = email
    int age = (int) row[2];         // Index 2 = age
}
```

---

## **2. Selecting Fields into a Custom DTO (Recommended)**
### **Use Case:** Mapping results to a `UserDTO`
```java
public List<UserDTO> findUserDTOs() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<UserDTO> cq = cb.createQuery(UserDTO.class);
    Root<User> user = cq.from(User.class);

    // Constructor-based mapping
    cq.select(cb.construct(
        UserDTO.class,
        user.get("name"),
        user.get("email"),
        user.get("age")
    ));

    return entityManager.createQuery(cq).getResultList();
}
```
### **DTO Class**
```java
public class UserDTO {
    private String name;
    private String email;
    private int age;

    // Constructor must match SELECT order
    public UserDTO(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
    // Getters and setters
}
```

---

## **3. Selecting Fields with Joins**
### **Use Case:** Fetching `user.name` and `order.total` from a joined query
```java
public List<Object[]> findUsersWithOrderTotals() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
    Root<User> user = cq.from(User.class);
    Join<User, Order> order = user.join("orders", JoinType.LEFT);

    cq.multiselect(
        user.get("name"),
        order.get("total")
    );

    return entityManager.createQuery(cq).getResultList();
}
```

---

## **4. Selecting Aggregated Fields (COUNT, SUM, AVG)**
### **Use Case:** Counting users per department
```java
public List<Object[]> countUsersByDepartment() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
    Root<User> user = cq.from(User.class);

    cq.multiselect(
        user.get("department"),
        cb.count(user)
    ).groupBy(user.get("department"));

    return entityManager.createQuery(cq).getResultList();
}
```
**Output Example:**
```
["IT", 5]
["HR", 3]
["Finance", 2]
```

---

## **5. Using Tuple for Type-Safe Field Access**
### **Use Case:** Fetching fields with type safety (alternative to `Object[]`)
```java
public List<Tuple> findUsersWithTuples() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Tuple> cq = cb.createTupleQuery();
    Root<User> user = cq.from(User.class);

    cq.multiselect(
        user.get("name").alias("username"), // Named alias
        user.get("email").alias("useremail")
    );

    return entityManager.createQuery(cq).getResultList();
}
```
### **Accessing Tuple Data**
```java
List<Tuple> results = findUsersWithTuples();
for (Tuple tuple : results) {
    String name = tuple.get("username", String.class); // By alias
    String email = tuple.get(1, String.class);        // By position
}
```

---

## **6. Dynamic Field Selection**
### **Use Case:** Selecting fields based on runtime conditions
```java
public List<Object[]> findUsersDynamic(Set<String> fields) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
    Root<User> user = cq.from(User.class);

    List<Selection<?>> selections = new ArrayList<>();
    if (fields.contains("name")) selections.add(user.get("name"));
    if (fields.contains("email")) selections.add(user.get("email"));
    if (fields.contains("age")) selections.add(user.get("age"));

    cq.multiselect(selections);

    return entityManager.createQuery(cq).getResultList();
}
```
**Usage Example:**
```java
Set<String> fields = Set.of("name", "email");
List<Object[]> results = findUsersDynamic(fields);
```

---

## **Key Takeaways**
| Approach | Use Case | Pros | Cons |
|----------|---------|------|------|
| `Object[]` | Simple column selection | Fast, flexible | Manual casting required |
| **DTO (Recommended)** | Structured results | Type-safe, clean | Requires DTO class |
| `Tuple` | Type-safe field access | No casting needed | Verbose syntax |
| Dynamic Selection | Runtime field choices | Highly flexible | Complex setup |

---

## **Best Practices**
1. **Prefer DTOs** for maintainability.
2. **Use aliases** (`alias()`) for clarity in `Tuple` queries.
3. **Avoid `SELECT *`** – fetch only needed fields.
4. **For joins**, explicitly declare `JoinType` (`INNER`, `LEFT`).

---

## **FAQ**
### **Q: How to select all fields without listing them?**
```java
cq.select(user); // Equivalent to SELECT *
```
But this defeats the purpose of partial selection.

### **Q: Can I mix entities and fields in `multiselect()`?**
Yes, but it’s not recommended (leads to mixed result types).

---

### **Final Thoughts**
The Criteria API provides **flexible, type-safe** ways to select multiple fields. For most cases, **DTO mapping** is the cleanest approach, while `Tuple` offers a balance between type safety and flexibility.  

<br/>
<br/>

# **End-to-End JPA Criteria API Project**

This project demonstrates all major Criteria API features:
- Basic queries
- Dynamic filtering
- Joins
- Projections (DTOs, Object[], Tuple)
- Pagination & Sorting
- Aggregations
- Subqueries

## **1. Project Setup**

### **Technologies Used**
- Java 17
- Spring Boot 3.x
- Hibernate/JPA
- H2 Database (in-memory)
- Maven

### **pom.xml**
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

## **2. Entity Classes**

### **User.java**
```java
@Entity
@Data
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private String email;
    private Integer age;
    private String department;
    
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}
```

### **Order.java**
```java
@Entity
@Data
public class Order {
    @Id @GeneratedValue
    private Long id;
    private Double total;
    private LocalDate orderDate;
    
    @ManyToOne
    private User user;
}
```

## **3. DTO Classes**

### **UserDTO.java**
```java
@Data
@AllArgsConstructor
public class UserDTO {
    private String name;
    private String email;
    private Integer age;
}
```

### **UserOrderDTO.java**
```java
@Data
@AllArgsConstructor
public class UserOrderDTO {
    private String userName;
    private Double orderTotal;
}
```

## **4. Repository Layer**

### **UserRepositoryCustom.java**
```java
public interface UserRepositoryCustom {
    List<User> findUsersByCriteria(String name, String email, Integer age);
    List<UserDTO> findUserDTOs();
    List<UserOrderDTO> findUsersWithOrders();
    List<Object[]> findAggregatedData();
    Page<User> findUsersWithPagination(Pageable pageable);
}
```

### **UserRepositoryImpl.java**
```java
@Repository
@RequiredArgsConstructor
public class UserRepositoryImpl implements UserRepositoryCustom {

    private final EntityManager em;

    @Override
    public List<User> findUsersByCriteria(String name, String email, Integer age) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<User> cq = cb.createQuery(User.class);
        Root<User> user = cq.from(User.class);

        List<Predicate> predicates = new ArrayList<>();
        
        if (name != null) {
            predicates.add(cb.like(user.get("name"), "%" + name + "%"));
        }
        if (email != null) {
            predicates.add(cb.equal(user.get("email"), email));
        }
        if (age != null) {
            predicates.add(cb.gt(user.get("age"), age));
        }

        cq.where(predicates.toArray(new Predicate[0]));
        return em.createQuery(cq).getResultList();
    }

    @Override
    public List<UserDTO> findUserDTOs() {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<UserDTO> cq = cb.createQuery(UserDTO.class);
        Root<User> user = cq.from(User.class);

        cq.select(cb.construct(
            UserDTO.class,
            user.get("name"),
            user.get("email"),
            user.get("age")
        ));

        return em.createQuery(cq).getResultList();
    }

    @Override
    public List<UserOrderDTO> findUsersWithOrders() {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<UserOrderDTO> cq = cb.createQuery(UserOrderDTO.class);
        Root<User> user = cq.from(User.class);
        Join<User, Order> orders = user.join("orders", JoinType.LEFT);

        cq.select(cb.construct(
            UserOrderDTO.class,
            user.get("name"),
            orders.get("total")
        ));

        return em.createQuery(cq).getResultList();
    }

    @Override
    public List<Object[]> findAggregatedData() {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
        Root<User> user = cq.from(User.class);

        cq.multiselect(
            user.get("department"),
            cb.count(user),
            cb.avg(user.get("age"))
        ).groupBy(user.get("department"));

        return em.createQuery(cq).getResultList();
    }

    @Override
    public Page<User> findUsersWithPagination(Pageable pageable) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<User> cq = cb.createQuery(User.class);
        Root<User> user = cq.from(User.class);

        CriteriaQuery<Long> countQuery = cb.createQuery(Long.class);
        Root<User> countRoot = countQuery.from(User.class);
        countQuery.select(cb.count(countRoot));

        Long total = em.createQuery(countQuery).getSingleResult();
        
        List<User> result = em.createQuery(cq)
            .setFirstResult((int) pageable.getOffset())
            .setMaxResults(pageable.getPageSize())
            .getResultList();

        return new PageImpl<>(result, pageable, total);
    }
}
```

## **5. Service Layer**

### **UserService.java**
```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final UserRepositoryCustom userRepositoryCustom;

    public List<User> searchUsers(String name, String email, Integer age) {
        return userRepositoryCustom.findUsersByCriteria(name, email, age);
    }

    public List<UserDTO> getUserDTOs() {
        return userRepositoryCustom.findUserDTOs();
    }

    public List<UserOrderDTO> getUserOrders() {
        return userRepositoryCustom.findUsersWithOrders();
    }

    public List<Object[]> getDepartmentStats() {
        return userRepositoryCustom.findAggregatedData();
    }

    public Page<User> getUsersWithPagination(int page, int size) {
        return userRepositoryCustom.findUsersWithPagination(PageRequest.of(page, size));
    }
}
```

## **6. Controller Layer**

### **UserController.java**
```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {
    private final UserService userService;

    @GetMapping("/search")
    public List<User> searchUsers(
            @RequestParam(required = false) String name,
            @RequestParam(required = false) String email,
            @RequestParam(required = false) Integer age) {
        return userService.searchUsers(name, email, age);
    }

    @GetMapping("/dto")
    public List<UserDTO> getUserDTOs() {
        return userService.getUserDTOs();
    }

    @GetMapping("/orders")
    public List<UserOrderDTO> getUserOrders() {
        return userService.getUserOrders();
    }

    @GetMapping("/stats")
    public List<Object[]> getDepartmentStats() {
        return userService.getDepartmentStats();
    }

    @GetMapping("/paged")
    public Page<User> getUsersWithPagination(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return userService.getUsersWithPagination(page, size);
    }
}
```

## **7. Data Initialization**

### **DataLoader.java**
```java
@Component
@RequiredArgsConstructor
public class DataLoader implements CommandLineRunner {
    private final UserRepository userRepository;

    @Override
    public void run(String... args) {
        User user1 = new User(null, "John Doe", "john@example.com", 30, "IT", new ArrayList<>());
        User user2 = new User(null, "Jane Smith", "jane@example.com", 25, "HR", new ArrayList<>());
        
        Order order1 = new Order(null, 100.0, LocalDate.now(), user1);
        Order order2 = new Order(null, 200.0, LocalDate.now(), user1);
        
        user1.getOrders().addAll(List.of(order1, order2));
        
        userRepository.saveAll(List.of(user1, user2));
    }
}
```

## **8. Testing the API**

### **Sample Requests**
1. **Dynamic Filtering**
   ```
   GET /api/users/search?name=John&age=25
   ```

2. **DTO Projection**
   ```
   GET /api/users/dto
   ```

3. **Join Query**
   ```
   GET /api/users/orders
   ```

4. **Aggregation**
   ```
   GET /api/users/stats
   ```

5. **Pagination**
   ```
   GET /api/users/paged?page=0&size=5
   ```

## **Key Features Demonstrated**
1. **Dynamic Queries**: Filter users by optional parameters
2. **DTO Projections**: Map entities to custom DTOs
3. **Joins**: Fetch user data with related orders
4. **Aggregations**: Calculate department statistics
5. **Pagination**: Return paginated results

This complete implementation covers all major Criteria API use cases in a production-ready Spring Boot application. The code is organized with:
- Clear separation of concerns (Controller/Service/Repository)
- Proper DTO usage
- Type-safe queries
- Pagination support
- Dynamic filtering capabilities

