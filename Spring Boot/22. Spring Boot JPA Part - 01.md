# **Spring Boot JPA - Part 1: JDBC & Spring Boot JDBC Template**  

## **1. Introduction**  
- Till now, we focused on **application logic**.  
- Now, we need to **insert/fetch data from a database**.  
- **JPA (Java Persistence API)** and **JDBC (Java Database Connectivity)** help in database interactions.  

---

## **2. Database Interaction Flow**  
1. **Application** → Uses **JPA (Interface)**.  
2. **JPA** → Implemented by **Hibernate, EclipseLink, OpenJPA**.  
3. **Hibernate (ORM Framework)** → Uses **JDBC (API)**.  
4. **JDBC** → Uses **specific DB drivers** (MySQL, PostgreSQL, H2).  

### **Key Points:**  
- **JPA** is just an **interface**, **Hibernate** provides implementation.  
- **JDBC** is also an **interface**, implemented by **DB drivers**.  
- **ORM (Object-Relational Mapping)** bridges **Java objects** ↔ **Relational DB tables**.  

---

## **3. Plain JDBC (Without Spring Boot)**  
### **Challenges with Plain JDBC:**  
1. **Driver Class Loading** → Manually load using `Class.forName()`.  
2. **DB Connection Management** → Manually create & close connections.  
3. **Exception Handling** → Only `SQLException` (too generic).  
4. **Resource Leakage Risk** → Must close `Connection`, `Statement`, `ResultSet`.  
5. **No Connection Pooling** → Need to manually implement.  

### **Example:**  
```java
public class DatabaseConnection {
    public Connection getConnection() throws SQLException {
        Class.forName("org.h2.Driver"); // Load driver
        return DriverManager.getConnection("jdbc:h2:mem:userdb", "sa", ""); // Create connection
    }
}
```
```java
public class UserDao {
    public void createUser(String username, int age) {
        Connection conn = null;
        PreparedStatement stmt = null;
        try {
            conn = new DatabaseConnection().getConnection();
            String sql = "INSERT INTO users (username, age) VALUES (?, ?)";
            stmt = conn.prepareStatement(sql);
            stmt.setString(1, username);
            stmt.setInt(2, age);
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            // Must close resources
            stmt.close();
            conn.close();
        }
    }
}
```
**Issues:**  
- **Boilerplate code** (loading driver, managing connections, closing resources).  
- **No connection pooling** → Performance issues.  

---

## **4. Spring Boot JDBC (Using `JdbcTemplate`)**  
### **Advantages:**  
1. **No manual driver loading** → Auto-loaded by Spring Boot.  
2. **Simplified DB operations** → Uses `JdbcTemplate`.  
3. **Better exception handling** → Granular exceptions (`DuplicateKeyException`, `QueryTimeoutException`).  
4. **Auto resource management** → No need to close connections manually.  
5. **Connection pooling** → Uses **HikariCP** by default.  

### **Steps:**  
#### **1. Add Dependencies (`pom.xml`)**  
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

#### **2. Configure `application.properties`**  
```properties
spring.datasource.url=jdbc:h2:mem:userdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
```

#### **3. Use `JdbcTemplate`**  
```java
@Repository
public class UserRepository {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void createTable() {
        jdbcTemplate.execute("CREATE TABLE users (user_id INT AUTO_INCREMENT, username VARCHAR(255), age INT)");
    }

    public void insertUser(String username, int age) {
        jdbcTemplate.update("INSERT INTO users (username, age) VALUES (?, ?)", username, age);
    }

    public List<User> getUsers() {
        return jdbcTemplate.query("SELECT * FROM users", (rs, rowNum) -> 
            new User(rs.getInt("user_id"), rs.getString("username"), rs.getInt("age"))
        );
    }
}
```
**Key Methods:**  
- **`jdbcTemplate.execute(sql)`** → Execute DDL (CREATE, ALTER).  
- **`jdbcTemplate.update(sql, args)`** → INSERT, UPDATE, DELETE.  
- **`jdbcTemplate.query(sql, RowMapper)`** → Fetch multiple rows.  
- **`jdbcTemplate.queryForList(sql, Class)`** → Single column from multiple rows.  
- **`jdbcTemplate.queryForObject(sql, Class)`** → Single row or value.  

---

## **5. Connection Pooling in Spring Boot**  
- **Default:** **HikariCP** (fast & efficient).  
- **Configurable in `application.properties`:**  
```properties
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
```
- **Custom DataSource Configuration:**  
```java
@Configuration
public class AppConfig {
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:h2:mem:userdb");
        config.setUsername("sa");
        config.setPassword("");
        return new HikariDataSource(config);
    }
}
```

---

## **6. Summary**  
| **Aspect**          | **Plain JDBC** | **Spring Boot JDBC** |
|----------------------|----------------|----------------------|
| **Driver Loading**   | Manual (`Class.forName()`) | Auto-loaded |
| **Connection Mgmt**  | Manual open/close | Auto-managed |
| **Exception Handling** | `SQLException` (generic) | Granular exceptions |
| **Connection Pooling** | Manual setup | Auto (HikariCP) |
| **Boilerplate Code** | High | Minimal (`JdbcTemplate`) |

---
