# **Dynamic Initialization of Beans in Spring Boot Using @Value Annotation**

## **Introduction**
In this guide, we'll explore how to dynamically initialize beans in Spring Boot using the `@Value` annotation. We'll also revisit the **Unsatisfied Dependency Problem**, discuss solutions using `@Qualifier`, and then dive into dynamic dependency injection.

---

## **1. Unsatisfied Dependency Problem**
### **Scenario:**
- We have an **`Order`** interface with two implementations:
  - `OnlineOrder` (marked with `@Component`)
  - `OfflineOrder` (marked with `@Component`)
- A **`User`** controller class depends on an `Order` object (`@Autowired`).

### **Problem:**
When Spring tries to create the `User` bean, it doesn’t know which implementation (`OnlineOrder` or `OfflineOrder`) to inject. This leads to:
```
Error creating bean with name 'user': Unsatisfied dependency expressed through field 'order'
```

### **Solution 1: Using `@Qualifier` (Static Injection)**
- We can explicitly tell Spring which bean to inject using `@Qualifier`.
  
#### **Implementation:**
1. **Annotate the beans with `@Qualifier`:**
   ```java
   @Component
   @Qualifier("onlineOrder")
   public class OnlineOrder implements Order { ... }

   @Component
   @Qualifier("offlineOrder")
   public class OfflineOrder implements Order { ... }
   ```
2. **Inject the desired bean in `User`:**
   ```java
   @Autowired
   @Qualifier("onlineOrder")
   private Order order;
   ```
   
#### **Limitation:**
- **Hardcoded dependency**: The `User` class always gets `OnlineOrder`.  
- **Breaks Dependency Inversion Principle (DIP)** since the dependency is static.

---

## **2. Dynamic Initialization of Beans**
### **Solution 2: Using `@Qualifier` with Multiple Beans (Dynamic Selection)**
Instead of hardcoding, we can inject both beans and dynamically choose one at runtime.

#### **Implementation:**
1. **Define both beans in `User`:**
   ```java
   @Autowired
   @Qualifier("onlineOrder")
   private Order onlineOrder;

   @Autowired
   @Qualifier("offlineOrder")
   private Order offlineOrder;
   ```
2. **Choose dynamically in a method:**
   ```java
   public void createOrder(boolean isOnlineOrder) {
       if (isOnlineOrder) {
           onlineOrder.createOrder();
       } else {
           offlineOrder.createOrder();
       }
   }
   ```
   
#### **Advantages:**
- **Runtime flexibility**: The client can decide which implementation to use.
- **No hardcoding**: Follows DIP better than static `@Qualifier`.

---

### **Solution 3: Using `@Value` (Dynamic from Configuration)**
Instead of hardcoding, we can fetch the bean type from **`application.properties`** using `@Value`.

#### **Implementation:**
1. **Remove `@Component` and define beans manually in a `@Configuration` class:**
   ```java
   @Configuration
   public class OrderConfig {
       
       @Bean
       @ConditionalOnProperty(name = "isOnlineOrder", havingValue = "true")
       public Order onlineOrder() {
           return new OnlineOrder();
       }

       @Bean
       @ConditionalOnProperty(name = "isOnlineOrder", havingValue = "false")
       public Order offlineOrder() {
           return new OfflineOrder();
       }
   }
   ```
   
   Alternatively, using `@Value`:
   ```java
   @Bean
   public Order order(@Value("${isOnlineOrder}") boolean isOnlineOrder) {
       return isOnlineOrder ? new OnlineOrder() : new OfflineOrder();
   }
   ```
   
2. **Set the value in `application.properties`:**
   ```properties
   isOnlineOrder=false
   ```
   
3. **Inject `Order` normally in `User`:**
   ```java
   @Autowired
   private Order order;  // Resolves to OfflineOrder if isOnlineOrder=false
   ```

#### **Advantages:**
- **External configuration**: Change bean type without recompiling.
- **Cleaner injection**: No need for multiple `@Qualifier` fields.

---

## **Key Takeaways**
| Approach | Mechanism | Flexibility | DIP Compliance |
|----------|-----------|-------------|----------------|
| `@Qualifier` (Static) | Hardcodes dependency | ❌ Low | ❌ No |
| `@Qualifier` (Dynamic) | Injects multiple beans, selects at runtime | ✅ High | ✅ Yes |
| `@Value` (Config-based) | Fetches bean type from properties | ✅ High | ✅ Yes |

### **When to Use Which?**
- **Use `@Qualifier` (Static)** when the dependency is fixed.
- **Use `@Qualifier` (Dynamic)** when the decision is based on runtime conditions.
- **Use `@Value`** when the dependency should be configurable externally.

---

## **Conclusion**
- **Static `@Qualifier`** is simple but inflexible.
- **Dynamic `@Qualifier`** allows runtime selection.
- **`@Value`** enables externalized configuration for maximum flexibility.

By using these techniques, we can ensure **Dependency Inversion Principle (DIP)** is maintained while keeping the system adaptable.

