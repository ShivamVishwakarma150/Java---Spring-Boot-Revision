# **Mastering `@ConditionalOnProperty` in Spring Boot**  
**A Guide to Dynamic Bean Initialization & Application Optimization**  

## **Introduction**  
In large-scale Spring Boot applications, managing bean initialization efficiently is crucial. The **`@ConditionalOnProperty`** annotation allows you to **conditionally create beans** based on configuration, preventing unnecessary clutter in the application context.  

This guide covers:  
‚úî **What is `@ConditionalOnProperty`?**  
‚úî **Real-world use cases**  
‚úî **Implementation with examples**  
‚úî **Advantages & Disadvantages**  
‚úî **Best Practices**  

---

## **1. What is `@ConditionalOnProperty`?**  
This annotation **controls bean creation** based on a property value in `application.properties`.  

### **Key Attributes:**  
| Attribute | Description | Example |  
|-----------|-------------|---------|  
| `prefix` | First part of the property key | `sql.connection` |  
| `value` | Second part (after the dot) | `enabled` |  
| `havingValue` | Expected value for the bean to be created | `"true"`, `"mysql"` |  
| `matchIfMissing` | If `true`, bean is created when the property is missing (default: `false`) | `false` |  

### **Property Key Format:**  
```properties
prefix.value = havingValue
```  
Example:  
```properties
sql.connection.enabled = true
```  

---

## **2. Why Use `@ConditionalOnProperty`?**  
### **Use Case 1: Feature Toggles (Migration Scenarios)**  
- **Scenario:** A company migrates from **MySQL ‚Üí NoSQL**.  
- **Problem:** Both beans (`MySQLConnection`, `NoSQLConnection`) exist, but only one should be active.  
- **Solution:** Use `@ConditionalOnProperty` to toggle between them via config.  

### **Use Case 2: Shared Codebase with Multiple Apps**  
- **Scenario:** Two applications (`App1`, `App2`) share a common library.  
  - `App1` needs **NoSQL**.  
  - `App2` needs **MySQL**.  
- **Solution:** Conditionally load only the required bean per app.  

---

## **3. Implementation Example**  

### **Step 1: Define Beans with `@ConditionalOnProperty`**  
```java
@Component
@ConditionalOnProperty(  
    prefix = "sql.connection",  
    name = "enabled",  
    havingValue = "true"  
)  
public class MySQLConnection {  
    public MySQLConnection() {  
        System.out.println("Initializing MySQL bean...");  
    }  
}  

@Component  
@ConditionalOnProperty(  
    prefix = "nosql.connection",  
    name = "enabled",  
    havingValue = "true"  
)  
public class NoSQLConnection {  
    public NoSQLConnection() {  
        System.out.println("Initializing NoSQL bean...");  
    }  
}  
```  

### **Step 2: Configure `application.properties`**  
```properties
# Enable MySQL, disable NoSQL  
sql.connection.enabled=true  
nosql.connection.enabled=false  
```  

### **Step 3: Inject with `@Autowired(required = false)`**  
Since beans are **conditionally created**, mark dependencies as optional:  
```java
@Component  
public class DBConnection {  

    @Autowired(required = false)  
    private MySQLConnection mySQLConnection;  

    @Autowired(required = false)  
    private NoSQLConnection noSQLConnection;  

    @PostConstruct  
    public void init() {  
        System.out.println("DBConnection created!");  
        System.out.println("Is MySQL null? " + (mySQLConnection == null));  
        System.out.println("Is NoSQL null? " + (noSQLConnection == null));  
    }  
}  
```  

### **Expected Output:**  
```plaintext
Initializing MySQL bean...  
DBConnection created!  
Is MySQL null? false  
Is NoSQL null? true  
```  

---

## **4. Advantages**  
‚úÖ **Feature Toggling** ‚Äì Switch implementations via config (e.g., `MySQL` ‚Üí `NoSQL`).  
‚úÖ **Reduces Memory Usage** ‚Äì Avoids unnecessary beans in the Spring context.  
‚úÖ **Faster Startup** ‚Äì Fewer beans ‚Üí quicker initialization.  
‚úÖ **Cleaner Code** ‚Äì No hardcoded `@Qualifier` or manual checks.  

---

## **5. Disadvantages & Pitfalls**  
‚ùå **Misconfiguration Risks** ‚Äì Wrong property values can disable critical beans.  
‚ùå **Increased Complexity** ‚Äì Managing many conditionals can become messy.  
‚ùå **Debugging Challenges** ‚Äì Beans not loading? Check `application.properties` first!  
‚ùå **Overuse Can Clutter Configs** ‚Äì Too many conditionals ‚Üí harder maintenance.  

---

## **6. Best Practices**  
‚úî **Use Descriptive Property Names** (e.g., `db.mysql.enabled`).  
‚úî **Set `matchIfMissing = false`** (Avoid accidental bean creation).  
‚úî **Document Conditional Beans** (Add comments explaining the toggle).  
‚úî **Test Configurations Thoroughly** (Ensure beans load as expected).  

---

## **Conclusion**  
`@ConditionalOnProperty` is a **powerful tool** for:  
üîπ **Dynamic bean initialization**  
üîπ **Feature toggling**  
üîπ **Optimizing application startup & memory**  

<br/>
<br/>

# **Mastering `@ConditionalOnProperty` in Spring Boot**  
**In-Depth Guide with `matchIfMissing` and Best Practices**  

## **1. What is `@ConditionalOnProperty`?**  
This annotation **conditionally creates Spring beans** based on configuration properties.  

### **Key Attributes Deep Dive:**  
| Attribute | Description | Default | Example |  
|-----------|-------------|---------|---------|  
| `prefix` | First part of property key | - | `"db.mysql"` |  
| `value` (or `name`) | Second part of key | - | `"enabled"` ‚Üí Forms `db.mysql.enabled` |  
| `havingValue` | Required property value | `""` (any value) | `"true"`, `"prod"` |  
| `matchIfMissing` | Behavior if property is missing | `false` | `true` ‚Üí Create bean if missing |  

---

## **2. `matchIfMissing` Explained**  
Controls whether the bean should be created **if the property is absent** in `application.properties`.  

### **Use Cases:**  
| Value | Behavior | When to Use |  
|-------|----------|-------------|  
| `false` (Default) | **Bean is NOT created** if property missing | Strict control (fail-safe) |  
| `true` | **Bean IS created** if property missing | Backward compatibility |  

### **Example:**  
```java
@Configuration
public class DatabaseConfig {

    @Bean
    @ConditionalOnProperty(
        prefix = "db.mysql",
        name = "enabled",
        havingValue = "true",
        matchIfMissing = false  // Default behavior
    )
    public MySQLConnection mySQLConnection() {
        return new MySQLConnection();
    }

    @Bean
    @ConditionalOnProperty(
        prefix = "db.nosql",
        name = "enabled",
        havingValue = "true",
        matchIfMissing = true  // Create bean if property is missing
    )
    public NoSQLConnection noSQLConnection() {
        return new NoSQLConnection();
    }
}
```

### **Scenarios:**  
1. **Property Exists & Matches (`db.mysql.enabled=true`)** ‚Üí Bean created ‚úÖ  
2. **Property Exists But Mismatch (`db.mysql.enabled=false`)** ‚Üí Bean skipped ‚ùå  
3. **Property Missing (`db.mysql.enabled` not defined)** ‚Üí Bean skipped ‚ùå (`matchIfMissing=false`)  
4. **Property Missing (`db.nosql.enabled` not defined)** ‚Üí Bean created ‚úÖ (`matchIfMissing=true`)  

---

## **3. Real-World Implementation**  

### **Step 1: Define Conditional Beans**  
```java
@Component
@ConditionalOnProperty(
    prefix = "cache",
    name = "type",
    havingValue = "redis",
    matchIfMissing = false
)
public class RedisCache implements CacheProvider {
    // Redis implementation
}

@Component
@ConditionalOnProperty(
    prefix = "cache",
    name = "type",
    havingValue = "ehcache",
    matchIfMissing = true  // Default if no config
)
public class EhCache implements CacheProvider {
    // EhCache implementation
}
```

### **Step 2: Configure `application.properties`**  
```properties
# Uncomment to switch to Redis
# cache.type=redis
```

### **Step 3: Inject with Optional Dependency**  
```java
@Service
public class PaymentService {

    @Autowired(required = false)
    private CacheProvider cacheProvider;

    public void processPayment() {
        if (cacheProvider != null) {
            cacheProvider.cache("payment-data");
        }
    }
}
```

### **Behavior Summary:**  
| Configuration | Active Bean |  
|---------------|-------------|  
| `cache.type=redis` | `RedisCache` |  
| `cache.type=ehcache` | `EhCache` |  
| **No configuration** | `EhCache` (due to `matchIfMissing=true`) |  

---

## **4. Advantages of `matchIfMissing`**  
‚úÖ **Backward Compatibility** ‚Äì Ensures a default bean loads if config is missing.  
‚úÖ **Smoother Migrations** ‚Äì Gradually shift from old to new implementations.  
‚úÖ **Reduced Config Overhead** ‚Äì Avoids forcing users to define every property.  

---

## **5. Pitfalls to Avoid**  
‚ùå **Accidental Bean Creation** ‚Äì Setting `matchIfMissing=true` blindly may load unwanted beans.  
‚ùå **Configuration Ambiguity** ‚Äì Multiple beans with `matchIfMissing=true` can cause conflicts.  
‚ùå **Debugging Complexity** ‚Äì Hidden defaults make it harder to trace why a bean loaded.  

---

## **6. Best Practices**  
‚úî **Explicit > Implicit** ‚Äì Prefer setting `matchIfMissing=false` unless needed.  
‚úî **Document Defaults** ‚Äì Clearly comment why `matchIfMissing=true` is used.  
‚úî **Test Edge Cases** ‚Äì Verify behavior when:  
   - Property is missing  
   - Property value is invalid  
   - Multiple conditionals overlap  

---

## **Conclusion**  
`@ConditionalOnProperty` + `matchIfMissing` gives you:  
üîπ **Precise control** over bean initialization  
üîπ **Flexible defaults** for configuration  
üîπ **Clean migration paths** between implementations  
