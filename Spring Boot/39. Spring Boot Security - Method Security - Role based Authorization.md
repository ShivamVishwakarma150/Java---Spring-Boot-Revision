# **Spring Security Annotation-Based Authorization**

#### **1. Introduction & The "Why"**

*   **Problem with Filter-Chain Authorization:** In large applications with hundreds of APIs, defining authorization rules (`antMatchers().hasRole()`) in the Security Filter Chain becomes messy, difficult to maintain, and is not scalable.
*   **Solution: Controller-Level Authorization:** A cleaner and more maintainable approach is to define authorization rules right at the controller layer, next to the endpoint definitions themselves.
*   **The Tool: Annotations:** Spring Security provides powerful annotations (`@PreAuthorize`, `@PostAuthorize`) to achieve this, moving authorization logic from the filter to the method level.

---

#### **2. Core Annotations: `@PreAuthorize` & `@PostAuthorize`**

These annotations use **Spring Expression Language (SpEL)** to define access rules.

| Annotation | Purpose | Execution Timing | Best For |
| :--- | :--- | :--- | :--- |
| **`@PreAuthorize`** | **Pre-execution Authorization** | **Before** the controller method runs. | Standard checks based on user roles/permissions *before* any business logic executes. |
| **`@PostAuthorize`** | **Post-execution Authorization** | **After** the controller method runs but **before** the response is sent. | Checks that require access to the **returned object** from the method (e.g., "does the user own this resource?"). |

---

#### **3. Key SpEL Expressions for Authorization**

Inside the annotations, you use SpEL expressions that evaluate to `true` (access granted) or `false` (access denied - 403 Forbidden).

| Expression | Description | Key Difference |
| :--- | :--- | :--- |
| **`hasRole('ROLE_NAME')`** | Checks if the user has the specified role. | **Automatically adds the prefix `ROLE_`.** So `hasRole('ADMIN')` checks for `ROLE_ADMIN`. |
| **`hasAuthority('AUTHORITY')`** | Checks if the user has the specified authority (permission). | **Uses the string as-is, no prefix is added.** So `hasAuthority('ORDER_READ')` checks for `ORDER_READ`. |
| **`hasAnyRole(...)` / `hasAnyAuthority(...)`** | Checks if the user has any one of the given roles/authorities. | Useful for providing access with multiple possible roles. |
| **`principal`** | Refers to the user's principal object (often a `UserDetails` implementation). | Used to access user-specific fields like `principal.id` or `principal.username`. |
| **`returnObject`** | (Only in `@PostAuthorize`) Refers to the object returned by the controller method. | Used to perform checks on the data being returned. |

> **ðŸ’¡ Important Note:** Technically, `hasRole` and `hasAuthority` work on the **same list** of `GrantedAuthority` objects stored in the `Authentication` object. The only difference is the automatic `ROLE_` prefix added by `hasRole`.

---

#### **4. Implementation Setup**

**Step 1: Enable Method Security**
You **must** enable annotation-based security in your security configuration class.

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true) // <- THIS IS CRUCIAL
public class SecurityConfig {
    // ... other security configuration (httpSecurity, authentication, etc.)
}
```

**Step 2: Populate `GrantedAuthority` Correctly**
In your custom `UserDetailsService` implementation, ensure you load both roles and permissions into the `GrantedAuthority` list.

```java
@Override
public UserDetails loadUserByUsername(String username) {
    User user = userRepository.findByUsername(username);
    // Create a list of authorities from both roles and permissions
    List<GrantedAuthority> authorities = new ArrayList<>();
    authorities.add(new SimpleGrantedAuthority("ROLE_" + user.getRole())); // Add role
    for (String permission : user.getPermissions()) { // Add all permissions
        authorities.add(new SimpleGrantedAuthority(permission));
    }
    // Return UserDetails with the combined authorities
    return new org.springframework.security.core.userdetails.User(
            user.getUsername(),
            user.getPassword(),
            authorities
    );
}
```
*This results in an `Authentication` object containing authorities like: `["ROLE_USER", "ORDER_READ", "SALES_CREATE"]`.*

---

#### **5. Usage Examples in Controllers**

**Example 1: Basic `@PreAuthorize`**
```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @GetMapping
    @PreAuthorize("hasRole('USER') and hasAuthority('ORDER_READ')")
    public String getAllOrders() {
        return "All orders have been fetched successfully.";
    }
}
```
*Access is granted only if the user has **BOTH** the `ROLE_USER` **AND** the `ORDER_READ` permission.*

**Example 2: `@PostAuthorize` with Return Object Check**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    @GetMapping("/{id}")
    @PostAuthorize("returnObject.id == authentication.principal.id")
    public UserDto getUserById(@PathVariable Long id) {
        UserDto user = userService.findById(id); // Fetches user from DB
        return user; // Authorization happens HERE, after fetch
    }
}
```
*This ensures a user can only fetch their **own** details. If User `B` (id=2) tries to GET `/api/users/1`, the method runs and fetches User `A`'s data. The `@PostAuthorize` rule then checks `1 == 2`, which is `false`, resulting in a 403 Forbidden, protecting User `A`'s data.*

---

#### **6. How It Works: The Magic Behind the Scenes**

1.  **Interception:** When a request maps to an annotated controller method, Spring's **AOP (Aspect-Oriented Programming)** magic kicks in.
2.  **Interceptors:**
    *   **`AuthorizationManagerBeforeMethodInterceptor`** intercepts `@PreAuthorize` annotations **before** the method is called.
    *   **`AuthorizationManagerAfterMethodInterceptor`** intercepts `@PostAuthorize` annotations **after** the method returns but **before** the response is written.
3.  **SpEL Parsing:** The interceptor takes the SpEL string (e.g., `"hasRole('USER')"`), parses it into an **Abstract Syntax Tree (AST)**, and resolves all its parts (variables, methods, operators).
4.  **Evaluation:** The parsed expression is evaluated against the current security context (which has the `Authentication` object) and, in the case of `@PostAuthorize`, the method's return object.
5.  **Decision:** If the expression evaluates to `true`, the request proceeds (or the response is sent). If `false`, an `AccessDeniedException` is thrown, resulting in a **403 Forbidden** response.

---

#### **Summary & Key Takeaways**

*   **Use `@PreAuthorize`** for most authorization needsâ€”checking roles and permissions *before* business logic runs.
*   **Use `@PostAuthorize`** for advanced scenarios where you need to **validate the data being returned** against the logged-in user.
*   **`hasRole('X')`** is shorthand for checking `ROLE_X`.
*   **`hasAuthority('Y')`** checks for the exact string `Y` in the authorities list.
*   **Always remember to use `@EnableMethodSecurity(prePostEnabled = true)`** in your config.
*   The power comes from combining SpEL expressions with logical operators (`and`, `or`) and access to security objects like `authentication` and `returnObject`.

This approach provides a clean, declarative, and powerful way to manage authorization in complex Spring Boot applications.

<br/>
<br/>

# **Scenario: A Project Management API**

Imagine an endpoint that allows a user to view the details of a specific project: `GET /api/projects/{projectId}`.

We need two layers of security:
1.  **Pre-Authorization (`@PreAuthorize`):** Does the user have the general permission to even *try* to view any project? (A broad, pre-check).
2.  **Post-Authorization (`@PostAuthorize`):** Is this user allowed to see *this specific project* they just requested? (A granular, data-specific check).

---

### **Code Implementation**

#### **1. Entity Classes (Simplified)**

```java
// Project Entity
@Entity
public class Project {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String description;

    // Many-to-Many: Users who have access to this project
    @ManyToMany
    @JoinTable(
        name = "project_collaborators",
        joinColumns = @JoinColumn(name = "project_id"),
        inverseJoinColumns = @JoinColumn(name = "user_id")
    )
    private Set<User> collaborators = new HashSet<>();

    // Getters and Setters
}

// User Entity (implementing UserDetails)
@Entity
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; // This is the principal.id we will use
    private String username;
    private String password;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_permissions",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "permission_id")
    )
    private Set<Permission> permissions = new HashSet<>();

    // Getters and Setters for all fields

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        // Load both roles and permissions into the authorities list
        return this.permissions.stream()
                .map(permission -> new SimpleGrantedAuthority(permission.getName()))
                .collect(Collectors.toList());
    }

    // Other UserDetails methods (isAccountNonExpired, etc.)
}

// Permission Entity
@Entity
public class Permission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name; // e.g., "PROJECT_READ", "PROJECT_WRITE"

    // Getters and Setters
}
```

#### **2. Project DTO (To Return Data Safely)**

```java
public class ProjectDto {
    private Long id;
    private String name;
    private String description;
    // Note: We do NOT expose the list of collaborators in the DTO for this endpoint.

    // Constructor to create DTO from Entity
    public ProjectDto(Project project) {
        this.id = project.getId();
        this.name = project.getName();
        this.description = project.getDescription();
    }
    // Getters and Setters
}
```

#### **3. The Controller (Using Both Annotations)**

```java
@RestController
@RequestMapping("/api/projects")
public class ProjectController {

    @Autowired
    private ProjectService projectService;

    @GetMapping("/{projectId}")
    // LAYER 1: Pre-Authorization - Can the user try to view projects?
    @PreAuthorize("hasAuthority('PROJECT_READ')")
    // LAYER 2: Post-Authorization - Can the user see THIS specific project?
    @PostAuthorize("@projectAccessService.canAccessProject(returnObject, authentication.principal.id)")
    public ProjectDto getProjectById(@PathVariable Long projectId) {
        // This code only runs if the user has the PROJECT_READ permission
        Project project = projectService.findById(projectId)
                .orElseThrow(() -> new ResourceNotFoundException("Project not found"));
        // Convert the entity to a DTO
        return new ProjectDto(project);
    }
}
```

#### **4. The Access Service Bean (Called from SpEL)**

We create a separate service to handle the complex access logic. This keeps the SpEL expression clean and testable.

```java
@Service("projectAccessService") // The name must match the one used in @PostAuthorize
public class ProjectAccessService {

    @Autowired
    private ProjectRepository projectRepository;

    public boolean canAccessProject(ProjectDto projectDto, Long principalId) {
        // 1. Find the full project entity using the ID from the DTO
        Project project = projectRepository.findById(projectDto.getId())
                .orElseThrow(() -> new ResourceNotFoundException("Project not found during access check"));

        // 2. Implement the business rule: A user can access the project if...
        //    a) They are the owner of the project? OR
        //    b) They are in the project's collaborators list?
        // Let's assume rule (b) for this example.

        // Check if the authenticated user's ID (principalId) is in the project's collaborator list
        boolean isCollaborator = project.getCollaborators().stream()
                .anyMatch(user -> user.getId().equals(principalId));

        // Return true if they are a collaborator, false otherwise.
        // A 'false' result will throw AccessDeniedException after the method runs.
        return isCollaborator;
    }
}
```

---

### **How It Works: Step-by-Step Flow**

Let's say user **Alice** (`id=10`, has `PROJECT_READ` permission) tries to view a project with `id=5`.

1.  **Request:** `GET /api/projects/5` with Alice's credentials (e.g., JWT in header).
2.  **Authentication:** Spring Security validates the token and creates an `Authentication` object. The `principal` is a `User` object with `id=10` and an authority list containing `"PROJECT_READ"`.
3.  **Pre-Authorization (`@PreAuthorize`):**
    *   The `AuthorizationManagerBeforeMethodInterceptor` kicks in.
    *   It evaluates the SpEL: `hasAuthority('PROJECT_READ')`.
    *   It checks the `Authentication` object. Does the authority list contain `"PROJECT_READ"`? **Yes.**
    *   **Result: PASS.** The controller method is allowed to execute.
4.  **Method Execution:**
    *   `projectService.findById(5)` is called and fetches the project entity from the database.
    *   A `ProjectDto` is created from the entity and returned from the method.
5.  **Post-Authorization (`@PostAuthorize`):**
    *   The `AuthorizationManagerAfterMethodInterceptor` kicks in **now**.
    *   It evaluates the SpEL: `@projectAccessService.canAccessProject(returnObject, authentication.principal.id)`.
    *   It injects the `returnObject` (the `ProjectDto` for project `id=5`) and the `principal.id` (`10`).
    *   It calls the `canAccessProject` method with these arguments.
    *   The service fetches the full project and checks if user `id=10` is in the project's collaborators.
        *   **If YES:** The method returns `true`. The request is successful, and the `ProjectDto` is sent back to Alice.
        *   **If NO:** The method returns `false`. Spring Security throws an `AccessDeniedException`, resulting in an HTTP **403 Forbidden** response. Alice sees an error, even though she had the general `PROJECT_READ` permission.

### **Why This is Powerful**

*   **Separation of Concerns:** `@PreAuthorize` handles broad, simple rules. `@PostAuthorize` handles complex, data-driven rules in a separate service.
*   **Defense in Depth:** Even if a user bypasses the UI to guess a project ID, the post-authorization check acts as a final, robust gatekeeper, ensuring they can only access data they truly own.
*   **Clean Code:** The security logic is declarative (annotations) and modular (external service), not mixed with business logic.