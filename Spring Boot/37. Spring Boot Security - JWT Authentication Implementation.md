# **JWT Implementation in Spring Boot: A Complete Guide**

This guide will walk you through implementing a secure JWT-based authentication system in a Spring Boot application. We'll cover user registration, token generation, token validation, refresh tokens, and role-based authorization.

---

### **1. Core JWT Concepts Recap**

**What is JWT?**
JSON Web Token (JWT) is a compact, URL-safe means of representing **claims** to be transferred between two parties. It's a **stateless** authentication mechanism, meaning the server does not store any session state.

**JWT Structure:**
A JWT is a string with three parts, separated by dots (`.`):
`header.payload.signature`

*   **Header**: Contains metadata about the token type (JWT) and the signing algorithm (e.g., HS256, RS256).
    *   `{"alg": "HS256", "typ": "JWT"}` -> Base64Url encoded.
*   **Payload**: Contains the **claims** (statements about an entity, typically the user). There are three types of claims:
    *   **Registered claims**: Predefined claims like `iss` (issuer), `exp` (expiration time), `sub` (subject).
    *   **Public claims**: Custom claims defined by those using JWTs.
    *   **Private claims**: Custom claims created to share information between parties.
    *   Example: `{"sub": "sj", "exp": 1735689999}` -> Base64Url encoded.
*   **Signature**: Verifies the message wasn't changed along the way. It is created by signing the encoded header, encoded payload, and a secret using the algorithm specified in the header.
    *   `HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`

**Why JWT?**
*   **Stateless & Scalable**: No server-side session storage is needed.
*   **Decoupled & Portable**: Tokens can be generated anywhere and verified by any service that has the secret/key.
*   **Fine-Grained Authorization**: The payload can contain user roles and permissions.

---

### **2. Implementation Steps & Architecture**

We will integrate JWT into the Spring Security framework by extending its components. Here's the high-level architecture and the steps we'll follow:

```mermaid
flowchart TD
    A[HTTP Request] --> B[Custom JWT Auth Filter<br>Checks for /generate-token]
    B -- If match --> C[Create UsernamePasswordAuthenticationToken]
    C --> D[AuthenticationManager]
    D --> E[DaoAuthenticationProvider<br>Validates Credentials vs DB]
    E -- If Success --> F[JWT Util: Generate Tokens]
    F -- Access & Refresh Tokens --> G[Set in Response Header/Cookie]
    
    H[HTTP Request<br>With JWT] --> I[Custom JWT Validation Filter]
    I --> J[Create JwtAuthenticationToken]
    J --> K[AuthenticationManager]
    K --> L[JwtAuthenticationProvider<br>Validates Token Signature & Expiry]
    L -- If Success --> M[Load UserDetails & Create<br>Fully Authenticated Principal]
    M --> N[Store in SecurityContextHolder]
    N --> O[Access Granted to Controller]
    
    P[HTTP Request to<br>/refresh-token] --> Q[Custom JWT Refresh Filter<br>Extracts Refresh Token from Cookie]
    Q --> R[Create JwtAuthenticationToken]
    R --> S[AuthenticationManager]
    S --> L
    L -- If Success --> T[JWT Util: Generate New Access Token]
    T --> U[Set new Access Token in Response]
```

**Step 1: User Registration**
*   Expose a `/api/user/register` API.
*   Hash the password (using BCrypt) and save the user details (username, hashed password, role) to the database.
*   Implement a `UserDetailsService` to tell Spring Security how to load users from your database.

**Step 2: Token Generation (`/generate-token`)**
*   Create a custom **Filter** that intercepts login requests (`/generate-token`).
*   This filter creates a `UsernamePasswordAuthenticationToken` and delegates authentication to the `AuthenticationManager` and `DaoAuthenticationProvider`.
*   Upon successful validation, the filter uses a **JWT Utility** class to generate both an **Access Token** (short-lived) and a **Refresh Token** (long-lived).
*   The Access Token is sent in the `Authorization` header, and the Refresh Token is sent as a secure, HTTP-only cookie.

**Step 3: Token Validation (Protecting APIs)**
*   Create another custom **Filter** that runs on every request.
*   It extracts the JWT from the `Authorization` header.
*   It creates a custom `JwtAuthenticationToken` (which is not yet authenticated).
*   It delegates validation to the `AuthenticationManager`, which uses a custom **JWT Authentication Provider**.
*   This provider verifies the token's signature and expiry. If valid, it loads the user's details and creates a *fully authenticated* authentication object.
*   This object is stored in the `SecurityContextHolder`, granting access to the protected controller.

**Step 4: Token Refresh (`/refresh-token`)**
*   Create a third custom **Filter** that intercepts requests to `/refresh-token`.
*   It extracts the long-lived Refresh Token from the secure cookie.
*   It validates this token using the same **JWT Authentication Provider**.
*   If valid, it generates a *new* Access Token and returns it in the response.

**Step 5: Authorization**
*   Use Spring Security's `authorizeHttpRequests` to define access rules based on user roles contained within the JWT.

---

### **3. Detailed Code Implementation**

#### **Dependencies (`pom.xml`)**
You need libraries to create and parse JWTs.
```xml
<!-- JJWT for JWT creation and validation -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

#### **JWT Utility Class (`JwtUtil.java`)**
This class handles the creation and validation of JWTs.
```java
import io.jsonwebtoken.*;
import org.springframework.stereotype.Component;
import java.util.Date;

@Component
public class JwtUtil {
    // In production, store this securely (e.g., environment variable, secret manager)
    private static final String SECRET_KEY = "myVerySecretKeyThatIsLongEnoughForHS512";
    private static final long ACCESS_TOKEN_EXPIRATION_MS = 15 * 60 * 1000; // 15 min
    private static final long REFRESH_TOKEN_EXPIRATION_MS = 7 * 24 * 60 * 60 * 1000; // 7 days

    public String generateAccessToken(String username) {
        return generateToken(username, ACCESS_TOKEN_EXPIRATION_MS);
    }

    public String generateRefreshToken(String username) {
        return generateToken(username, REFRESH_TOKEN_EXPIRATION_MS);
    }

    private String generateToken(String subject, long expirationMs) {
        return Jwts.builder()
                .setSubject(subject)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expirationMs))
                .signWith(SignatureAlgorithm.HS512, SECRET_KEY)
                .compact();
    }

    public String extractUsername(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(SECRET_KEY)
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(SECRET_KEY).build().parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            // Log the exception
            return false;
        }
    }
}
```

#### **Custom JWT Authentication Filter (`JwtAuthenticationFilter.java`)**
Handles the `/generate-token` endpoint.
```java
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final AuthenticationManager authenticationManager;
    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {
        if (!"/generate-token".equals(request.getServletPath())) {
            chain.doFilter(request, response);
            return;
        }

        // 1. Read credentials from request body
        LoginRequest loginRequest = new ObjectMapper().readValue(request.getInputStream(), LoginRequest.class);
        String username = loginRequest.getUsername();
        String password = loginRequest.getPassword();

        // 2. Create authentication object
        Authentication authentication = new UsernamePasswordAuthenticationToken(username, password);

        // 3. Delegate validation to AuthenticationManager & DaoAuthenticationProvider
        Authentication authenticated = authenticationManager.authenticate(authentication);

        // 4. If successful, generate tokens
        String accessToken = jwtUtil.generateAccessToken(username);
        String refreshToken = jwtUtil.generateRefreshToken(username);

        // 5. Set tokens in response
        response.setHeader("Authorization", "Bearer " + accessToken);
        ResponseCookie refreshCookie = ResponseCookie.from("refreshToken", refreshToken)
                .httpOnly(true)
                .secure(true) // Send only over HTTPS
                .path("/refresh-token") // Only sent for refresh requests
                .maxAge(REFRESH_TOKEN_EXPIRATION_MS / 1000)
                .build();
        response.addHeader("Set-Cookie", refreshCookie.toString());
    }
}
// DTO for login request
class LoginRequest {
    private String username;
    private String password;
    // getters and setters
}
```

#### **Custom JWT Validation Filter (`JwtValidationFilter.java`)**
Validates the JWT on every request.
```java
public class JwtValidationFilter extends OncePerRequestFilter {
    private final AuthenticationManager authenticationManager;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {
        // 1. Extract JWT from header
        String header = request.getHeader("Authorization");
        if (header == null || !header.startsWith("Bearer ")) {
            chain.doFilter(request, response);
            return;
        }
        String token = header.substring(7);

        // 2. Create a custom authentication token
        JwtAuthenticationToken authRequest = new JwtAuthenticationToken(token);

        // 3. Delegate validation to our custom JwtAuthenticationProvider
        Authentication authResult = authenticationManager.authenticate(authRequest);

        // 4. If successful, set the authentication in the SecurityContext
        SecurityContextHolder.getContext().setAuthentication(authResult);
        chain.doFilter(request, response);
    }
}

// Custom Authentication Token
class JwtAuthenticationToken extends AbstractAuthenticationToken {
    private final String token;
    public JwtAuthenticationToken(String token) {
        super(null);
        this.token = token;
        setAuthenticated(false); // Not authenticated until validated by provider
    }
    @Override
    public Object getCredentials() { return token; }
    @Override
    public Object getPrincipal() { return null; } // Will be populated by the provider
}
```

#### **Custom JWT Authentication Provider (`JwtAuthenticationProvider.java`)**
Validates the token and creates a fully authenticated principal.
```java
public class JwtAuthenticationProvider implements AuthenticationProvider {
    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;

    @Override
    public boolean supports(Class<?> authentication) {
        // This provider only handles our custom JwtAuthenticationToken
        return JwtAuthenticationToken.class.isAssignableFrom(authentication);
    }

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        JwtAuthenticationToken authToken = (JwtAuthenticationToken) authentication;
        String jwt = (String) authToken.getCredentials();

        // 1. Validate JWT signature and expiry
        if (!jwtUtil.validateToken(jwt)) {
            throw new BadCredentialsException("Invalid JWT token");
        }

        // 2. Extract username from token
        String username = jwtUtil.extractUsername(jwt);

        // 3. Load user details from database
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);

        // 4. Create a fully authenticated authentication object
        JwtAuthenticationToken authenticatedToken = new JwtAuthenticationToken(jwt, userDetails.getAuthorities());
        authenticatedToken.setDetails(userDetails);
        authenticatedToken.setAuthenticated(true); // Mark as fully authenticated
        return authenticatedToken;
    }
}
```

#### **Security Configuration (`SecurityConfig.java`)**
Ties everything together.
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, AuthenticationManager authManager, JwtUtil jwtUtil, UserDetailsService userDetailsService) throws Exception {
        // Create custom providers
        DaoAuthenticationProvider daoProvider = new DaoAuthenticationProvider();
        daoProvider.setUserDetailsService(userDetailsService);
        daoProvider.setPasswordEncoder(passwordEncoder());

        JwtAuthenticationProvider jwtProvider = new JwtAuthenticationProvider(jwtUtil, userDetailsService);

        // Build a custom AuthenticationManager with our providers
        AuthenticationManager customAuthManager = new ProviderManager(Arrays.asList(daoProvider, jwtProvider));

        // Create custom filters
        JwtAuthenticationFilter jwtAuthFilter = new JwtAuthenticationFilter(customAuthManager, jwtUtil);
        JwtValidationFilter jwtValidationFilter = new JwtValidationFilter(customAuthManager);

        http
            .csrf(csrf -> csrf.disable()) // Consider implications for stateless API
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/user/register", "/generate-token").permitAll()
                .requestMatchers("/refresh-token").authenticated()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasAnyRole("ADMIN", "USER")
                .anyRequest().authenticated()
            )
            // Add filters in the correct order
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
            .addFilterAfter(jwtValidationFilter, JwtAuthenticationFilter.class)
            .addFilterAfter(new JwtRefreshFilter(customAuthManager, jwtUtil), JwtValidationFilter.class)
            .authenticationManager(customAuthManager);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

### **4. Key Takeaways & Best Practices**

*   **Statelessness**: The server does not store any token state. All necessary information is contained within the JWT itself.
*   **Secret Key**: The signing key **must** be kept secret and strong enough for the algorithm (e.g., >256 bits for HS256). Never hardcode it in production; use environment variables or a secret management service.
*   **Token Expiry**: Use short-lived access tokens (minutes) and long-lived refresh tokens (days/weeks) to minimize the risk of token compromise.
*   **Secure Transmission**: Always use **HTTPS** to prevent tokens from being intercepted.
*   **Storage on Client**:
    *   **Access Token**: Store in memory (e.g., JS variable). Avoid `localStorage` due to XSS risks.
    *   **Refresh Token**: Store in an **HttpOnly, Secure, SameSite=Strict** cookie to mitigate XSS and CSRF attacks.
*   **Framework Integration**: By creating custom filters and providers, we seamlessly integrate JWT authentication into the Spring Security framework, leveraging its powerful authorization and exception handling mechanisms.

This implementation provides a robust and secure foundation for a modern, stateless REST API using Spring Boot and JWT.

<br/>
<br/>

# **Bonus**

### **1. Security Hardening**

This is the most crucial category, addressing potential vulnerabilities.

*   **1.1. Refresh Token Rotation & Reuse Detection:**
    *   **The Problem:** If a refresh token is stolen, an attacker can use it to generate new access tokens indefinitely.
    *   **The Solution:** Invalidate the used refresh token and issue a *new* refresh token along with the new access token. Store a hash of the current valid refresh token for the user. On a refresh request, check the submitted token against the stored hash. If an old token is used, it indicates theft—immediately invalidate *all* tokens for that user.

*   **1.2. Token Blacklisting for Logout:**
    *   **The Problem:** JWTs are valid until they expire. If a user logs out, the token is still valid until its expiry time.
    *   **The Solution:** Implement a short-lived blacklist (e.g., using a Redis cache with TTL). On logout, store the token's unique identifier (a "jti" claim) or the token itself until its natural expiry time. During validation, check this blacklist.

*   **1.3. Stronger JWT Signing Algorithms (Asymmetric Cryptography):**
    *   **The Problem:** Using a symmetric key (HS256) means everyone who can validate a token can also create one. This is a risk if multiple services need to validate tokens but only one should create them.
    *   **The Solution:** Use RS256 (RSA) or ES256 (ECDSA). The Auth Server holds the **private key** to *sign* tokens. Other services use the corresponding **public key** only to *validate* them. This is more secure and scalable for microservices.

*   **1.4. Advanced Claim Validation:**
    *   Validate the `iss` (Issuer) claim to ensure the token was created by your service.
    *   Validate the `aud` (Audience) claim to ensure the token is intended for your specific service.

*   **1.5. Secret Management:**
    *   **Never** hardcode the secret key. Use environment variables, a secure vault (like HashiCorp Vault, AWS Secrets Manager, or Azure Key Vault), or pull it from a secure configuration service.

---

### **2. Production Readiness & Operational Excellence**

*   **2.1. Comprehensive Logging and Monitoring:**
    *   Log authentication successes and failures (without logging passwords or tokens).
    *   Monitor endpoints for brute-force attacks (e.g., many failed `/generate-token` requests).
    *   Set up alerts for unexpected error rates related to authentication.

*   **2.2. Detailed Error Handling:**
    *   Don't expose too much information in errors. Avoid messages like "Invalid Signature." Instead, use generic messages like "Invalid credentials" or "Authentication failed" and log the detailed reason internally.

*   **2.3. API Documentation:**
    *   Document your auth flows using **OpenAPI (Swagger)**. Clearly show the `/generate-token`, `/refresh-token`, and protected endpoints, including required headers and expected responses.

*   **2.4. Rate Limiting:**
    *   Implement rate limiting on the `/generate-token` and `/refresh-token` endpoints to prevent abuse and brute-force attacks. Use frameworks like Spring Boot's built-in support or Bucket4j.

*   **2.5. Unit and Integration Tests:**
    *   Write tests for your `JwtUtil` class (token creation/parsing).
    *   Write tests for your custom filters and providers, mocking dependencies.
    *   Write integration tests that simulate the entire flow: registration -> token generation -> accessing a protected endpoint.

---

### **3. Functionality & User Experience (UX)**

*   **3.1. Proper Login Response DTO:**
    *   Instead of just putting tokens in headers, also consider returning a JSON body for the `/generate-token` and `/refresh-token` endpoints. This is helpful for clients that might not be web browsers.

    ```json
    {
      "accessToken": "eyJ...",
      "refreshToken": "eyJ...", // If not using HttpOnly cookie
      "expiresIn": 3600,
      "tokenType": "Bearer"
    }
    ```

*   **3.2. Token Introspection Endpoint:**
    *   Create an endpoint like `/api/validate` or `/api/me` that a client can call with its access token to check if it's still valid and get basic user information (e.g., username, roles).

*   **3.3. Multi-Factor Authentication (MFA) Ready:**
    *   Design your token payload and auth flow to accommodate future MFA integration. You might have a claim like `mfa_authenticated: true`.

---

### **4. Code Structure & Best Practices**

*   **4.1. Centralized Security Constants:**
    *   Define constants for header names (`Authorization`), token prefixes (`Bearer `), cookie names, and secret key names in one place.

*   **4.2. Custom Security Exceptions:**
    *   Create a dedicated exception handler for security-related exceptions (`@RestControllerAdvice`) to return consistent, structured error responses for all auth failures.

    ```java
    @RestControllerAdvice
    public class AuthExceptionHandler {
        @ExceptionHandler(BadCredentialsException.class)
        public ResponseEntity<ErrorResponse> handleBadCredentials() {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new ErrorResponse("Invalid login credentials"));
        }
        // ... handle other exceptions
    }
    ```

*   **4.3. Using a Dedicated `UserDetails` Implementation:**
    *   Instead of using Spring's default `User` class, create your own class implementing `UserDetails`. This allows you to add custom fields (e.g., `userId`, `email`) directly to the principal.

### **Summary: What's Next?**

| Category | Action Item | Priority for Production |
| :--- | :--- | :--- |
| **Security** | Implement Refresh Token Rotation | Critical |
| **Security** | Implement Token Blacklisting | High |
| **Security** | Switch to RS256/ES256 Algorithms | High (for microservices) |
| **Operational** | Centralized Logging & Monitoring | High |
| **Operational** | Comprehensive Testing | High |
| **UX** | Structured JSON Login Response | Medium |
| **Code Quality**| Custom Exception Handling | Medium |

You have built the engine. Now it's time to add the safety features, monitoring systems, and polish needed to run it reliably and securely in a real-world environment.

<br/>
<br/>

# Complete JWT Authentication System in Spring Boot

I'll create a complete Spring Boot application with JWT authentication that you can run immediately. This implementation includes user registration, login, token generation, protected endpoints, and token refresh functionality.

## Project Structure
```
src/
├── main/
│   ├── java/
│   │   └── com/
│   │       └── example/
│   │           └── jwtapp/
│   │               ├── controller/
│   │               ├── dto/
│   │               ├── filter/
│   │               ├── model/
│   │               ├── repository/
│   │               ├── service/
│   │               ├── util/
│   │               └── JwtAppApplication.java
│   └── resources/
│       └── application.properties
```

Let me implement this step by step:

## 1. First, the Maven dependencies (pom.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>jwtapp</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>
    
    <name>jwtapp</name>
    <description>JWT Authentication Demo</description>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.4</version>
        <relativePath/>
    </parent>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

## 2. Application Properties (application.properties)

```properties
# Server configuration
server.port=8080

# Database configuration (H2 in-memory database)
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# JPA configuration
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.h2.console.enabled=true

# JWT Secret Key (in production, use a stronger key from environment variables)
jwt.secret=mySecretKeyWhichShouldBeLongEnoughToBeSecureAndNotShort
```

## 3. Main Application Class

```java
package com.example.jwtapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JwtAppApplication {
    public static void main(String[] args) {
        SpringApplication.run(JwtAppApplication.class, args);
    }
}
```

## 4. User Entity Class

```java
package com.example.jwtapp.model;

import jakarta.persistence.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;

@Entity
@Table(name = "users")
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String username;
    
    @Column(nullable = false)
    private String password;
    
    @Column(nullable = false)
    private String role;
    
    // Constructors
    public User() {}
    
    public User(String username, String password, String role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public String getRole() { return role; }
    public void setRole(String role) { this.role = role; }
    
    // UserDetails methods
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(role));
    }
    
    @Override
    public boolean isAccountNonExpired() { return true; }
    
    @Override
    public boolean isAccountNonLocked() { return true; }
    
    @Override
    public boolean isCredentialsNonExpired() { return true; }
    
    @Override
    public boolean isEnabled() { return true; }
}
```

## 5. User Repository

```java
package com.example.jwtapp.repository;

import com.example.jwtapp.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Boolean existsByUsername(String username);
}
```

## 6. JWT Utility Class

```java
package com.example.jwtapp.util;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;

@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration:900000}") // 15 minutes default
    private long jwtExpiration;
    
    @Value("${jwt.refresh.expiration:604800000}") // 7 days default
    private long refreshExpiration;
    
    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }
    
    public String generateAccessToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration))
                .signWith(getSigningKey())
                .compact();
    }
    
    public String generateRefreshToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + refreshExpiration))
                .signWith(getSigningKey())
                .compact();
    }
    
    public String extractUsername(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
    
    public long getExpirationTime() {
        return jwtExpiration;
    }
}
```

## 7. Custom UserDetailsService

```java
package com.example.jwtapp.service;

import com.example.jwtapp.model.User;
import com.example.jwtapp.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
        return user;
    }
}
```

## 8. Data Transfer Objects (DTOs)

```java
package com.example.jwtapp.dto;

public class LoginRequest {
    private String username;
    private String password;
    
    // Constructors
    public LoginRequest() {}
    
    public LoginRequest(String username, String password) {
        this.username = username;
        this.password = password;
    }
    
    // Getters and Setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}
```

```java
package com.example.jwtapp.dto;

public class AuthResponse {
    private String accessToken;
    private String refreshToken;
    private String type = "Bearer";
    private long expiresIn;
    
    // Constructors
    public AuthResponse() {}
    
    public AuthResponse(String accessToken, String refreshToken, long expiresIn) {
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
        this.expiresIn = expiresIn;
    }
    
    // Getters and Setters
    public String getAccessToken() { return accessToken; }
    public void setAccessToken(String accessToken) { this.accessToken = accessToken; }
    
    public String getRefreshToken() { return refreshToken; }
    public void setRefreshToken(String refreshToken) { this.refreshToken = refreshToken; }
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public long getExpiresIn() { return expiresIn; }
    public void setExpiresIn(long expiresIn) { this.expiresIn = expiresIn; }
}
```

```java
package com.example.jwtapp.dto;

public class RegisterRequest {
    private String username;
    private String password;
    private String role;
    
    // Constructors
    public RegisterRequest() {}
    
    public RegisterRequest(String username, String password, String role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }
    
    // Getters and Setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public String getRole() { return role; }
    public void setRole(String role) { this.role = role; }
}
```

## 9. JWT Authentication Filter

```java
package com.example.jwtapp.filter;

import com.example.jwtapp.dto.LoginRequest;
import com.example.jwtapp.util.JwtUtil;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import java.io.IOException;

public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    private final AuthenticationManager authenticationManager;
    private final JwtUtil jwtUtil;
    
    public JwtAuthenticationFilter(AuthenticationManager authenticationManager, JwtUtil jwtUtil) {
        this.authenticationManager = authenticationManager;
        this.jwtUtil = jwtUtil;
        setFilterProcessesUrl("/api/auth/login");
    }
    
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, 
                                                HttpServletResponse response) 
            throws AuthenticationException {
        try {
            LoginRequest loginRequest = new ObjectMapper().readValue(
                    request.getInputStream(), LoginRequest.class);
            
            return authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(), 
                            loginRequest.getPassword())
            );
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    @Override
    protected void successfulAuthentication(HttpServletRequest request, 
                                            HttpServletResponse response, 
                                            FilterChain chain, 
                                            Authentication authResult) 
            throws IOException {
        String username = authResult.getName();
        String accessToken = jwtUtil.generateAccessToken(username);
        String refreshToken = jwtUtil.generateRefreshToken(username);
        
        AuthResponse authResponse = new AuthResponse(
                accessToken, refreshToken, jwtUtil.getExpirationTime());
        
        response.setContentType("application/json");
        response.getWriter().write(new ObjectMapper().writeValueAsString(authResponse));
    }
}
```

## 10. JWT Authorization Filter

```java
package com.example.jwtapp.filter;

import com.example.jwtapp.util.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

public class JwtAuthorizationFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;
    
    public JwtAuthorizationFilter(JwtUtil jwtUtil, UserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        final String authorizationHeader = request.getHeader("Authorization");
        
        String username = null;
        String jwt = null;
        
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            username = jwtUtil.extractUsername(jwt);
        }
        
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
            
            if (jwtUtil.validateToken(jwt)) {
                UsernamePasswordAuthenticationToken authToken = 
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}
```

## 11. Security Configuration

```java
package com.example.jwtapp.config;

import com.example.jwtapp.filter.JwtAuthenticationFilter;
import com.example.jwtapp.filter.JwtAuthorizationFilter;
import com.example.jwtapp.service.CustomUserDetailsService;
import com.example.jwtapp.util.JwtUtil;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final CustomUserDetailsService userDetailsService;
    private final JwtUtil jwtUtil;
    
    public SecurityConfig(CustomUserDetailsService userDetailsService, JwtUtil jwtUtil) {
        this.userDetailsService = userDetailsService;
        this.jwtUtil = jwtUtil;
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception {
        return http.getSharedObject(AuthenticationManagerBuilder.class)
                .userDetailsService(userDetailsService)
                .passwordEncoder(passwordEncoder())
                .and()
                .build();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {
        JwtAuthenticationFilter jwtAuthenticationFilter = new JwtAuthenticationFilter(authManager, jwtUtil);
        jwtAuthenticationFilter.setFilterProcessesUrl("/api/auth/login");
        
        http.csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilter(jwtAuthenticationFilter)
            .addFilterBefore(new JwtAuthorizationFilter(jwtUtil, userDetailsService), 
                            UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

## 12. Controllers

```java
package com.example.jwtapp.controller;

import com.example.jwtapp.dto.AuthResponse;
import com.example.jwtapp.dto.LoginRequest;
import com.example.jwtapp.dto.RegisterRequest;
import com.example.jwtapp.model.User;
import com.example.jwtapp.repository.UserRepository;
import com.example.jwtapp.util.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
public class AuthController {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @PostMapping("/register")
    public ResponseEntity<String> register(@RequestBody RegisterRequest registerRequest) {
        if (userRepository.existsByUsername(registerRequest.getUsername())) {
            return ResponseEntity.badRequest().body("Error: Username is already taken!");
        }
        
        User user = new User(
                registerRequest.getUsername(),
                passwordEncoder.encode(registerRequest.getPassword()),
                registerRequest.getRole()
        );
        
        userRepository.save(user);
        
        return ResponseEntity.ok("User registered successfully!");
    }
    
    @PostMapping("/refresh")
    public ResponseEntity<AuthResponse> refreshToken(@RequestHeader("Authorization") String refreshToken) {
        if (refreshToken != null && refreshToken.startsWith("Bearer ")) {
            String token = refreshToken.substring(7);
            
            if (jwtUtil.validateToken(token)) {
                String username = jwtUtil.extractUsername(token);
                String newAccessToken = jwtUtil.generateAccessToken(username);
                
                AuthResponse authResponse = new AuthResponse(
                        newAccessToken, token, jwtUtil.getExpirationTime());
                
                return ResponseEntity.ok(authResponse);
            }
        }
        
        return ResponseEntity.badRequest().build();
    }
}
```

```java
package com.example.jwtapp.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/user")
public class UserController {
    
    @GetMapping("/hello")
    public String userHello() {
        return "Hello User!";
    }
}
```

```java
package com.example.jwtapp.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/admin")
public class AdminController {
    
    @GetMapping("/hello")
    public String adminHello() {
        return "Hello Admin!";
    }
}
```

## How to Run and Test the Application

1. **Start the application**:
   ```
   mvn spring-boot:run
   ```

2. **Register a new user**:
   ```bash
   curl -X POST http://localhost:8080/api/auth/register \
   -H "Content-Type: application/json" \
   -d '{"username":"user","password":"password","role":"ROLE_USER"}'
   ```

3. **Register an admin user**:
   ```bash
   curl -X POST http://localhost:8080/api/auth/register \
   -H "Content-Type: application/json" \
   -d '{"username":"admin","password":"password","role":"ROLE_ADMIN"}'
   ```

4. **Login to get JWT tokens**:
   ```bash
   curl -X POST http://localhost:8080/api/auth/login \
   -H "Content-Type: application/json" \
   -d '{"username":"user","password":"password"}'
   ```

5. **Access protected user endpoint**:
   ```bash
   curl -X GET http://localhost:8080/api/user/hello \
   -H "Authorization: Bearer <your_access_token>"
   ```

6. **Access protected admin endpoint**:
   ```bash
   curl -X GET http://localhost:8080/api/admin/hello \
   -H "Authorization: Bearer <your_access_token>"
   ```

7. **Refresh your access token**:
   ```bash
   curl -X POST http://localhost:8080/api/auth/refresh \
   -H "Authorization: Bearer <your_refresh_token>"
   ```

This complete implementation provides a working JWT authentication system with user registration, login, token refresh, and role-based authorization. The application uses an in-memory H2 database for simplicity.