# Spring Boot Second Level Caching (L2 Cache) - Comprehensive Notes

## Overview of Caching in Hibernate/JPA

1. **First Level Cache (L1 Cache)**
   - Exists within the EntityManager/Persistence Context
   - Limited to a single request/session
   - Cache hit only occurs within the same EntityManager instance
   - New request = new EntityManager = new Persistence Context = no cache hit between requests

2. **Second Level Cache (L2 Cache)**
   - Shared across multiple EntityManager instances
   - Persists beyond a single request/session
   - Significantly improves performance for frequently accessed data
   - Used in production-level applications, especially in large-scale systems

## L2 Cache Architecture

```
Application → EntityManager → Persistence Context (L1) → Second Level Cache (L2) → Database
```

- Requests first check L1 cache, then L2 cache, then database
- Data flows: DB → L2 → L1 → Application
- L2 cache is shared across all EntityManager instances

## Setup Requirements

### 1. Dependencies (pom.xml)

Three essential dependencies:

1. **Cache Provider Implementation** (e.g., Ehcache)
   ```xml
   <dependency>
     <groupId>org.ehcache</groupId>
     <artifactId>ehcache</artifactId>
     <version>3.x.x</version>
   </dependency>
   ```

2. **JCache API** (Standard interfaces)
   ```xml
   <dependency>
     <groupId>javax.cache</groupId>
     <artifactId>cache-api</artifactId>
   </dependency>
   ```

3. **Hibernate JCache** (Bridge between Hibernate and JCache)
   ```xml
   <dependency>
     <groupId>org.hibernate</groupId>
     <artifactId>hibernate-jcache</artifactId>
   </dependency>
   ```

### 2. Application Properties

```properties
# Enable second level cache
spring.jpa.properties.hibernate.cache.use_second_level_cache=true

# Specify cache region factory
spring.jpa.properties.hibernate.cache.region.factory_class=jcache

# Set cache provider
spring.jpa.properties.javax.cache.provider=org.ehcache.jsr107.EhcacheCachingProvider

# For debugging
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

### 3. Entity Configuration

```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "userDetailCache")
public class UserDetail {
    // entity fields
}
```

## Cache Regions

- Logical grouping of cached data
- Each region can have different configurations:
  - Eviction policies (LRU, FIFO, LFU)
  - Time-to-live (TTL)
  - Maximum entries
  - Concurrency strategy

Example:
```java
// Different regions for different entities
@Cache(usage = ..., region = "userDetailCache")
public class UserDetail { ... }

@Cache(usage = ..., region = "orderDetailCache")
public class OrderDetail { ... }
```

## Cache Concurrency Strategies

### 1. READ_ONLY
- For immutable data that never changes
- Attempts to update will throw exceptions
- Highest performance, no locking overhead

### 2. READ_WRITE
- For frequently read but occasionally updated data
- Uses soft locks to prevent stale reads during updates
- Update flow:
  1. Acquire lock on cache entry
  2. Mark entry as invalid
  3. Update database
  4. If commit succeeds, update cache and remove invalid flag
  5. If rollback occurs, just release lock (entry remains invalid)
- Ensures no stale reads during updates

### 3. NONSTRICT_READ_WRITE
- Lighter version of READ_WRITE
- No locks during reads
- During updates:
  1. Acquire lock
  2. Update database
  3. On commit success, invalidate cache (don't update)
  4. On rollback, just release lock
- Small chance of stale reads during the update window

### 4. TRANSACTIONAL
- Strictest consistency
- Locks during both reads and writes
- During read lock, other reads go directly to DB
- Similar to READ_WRITE for updates but with stricter read locking

## Typical Flow Examples

### READ_WRITE Example Flow:
1. POST /insert → DB insert (no cache interaction)
2. First GET /user → Cache miss → DB read → Store in L2 cache
3. Subsequent GET /user → Cache hit (from L2)
4. PUT /update → 
   - Acquire lock
   - Invalidate cache entry
   - Update DB
   - On success: update cache with new data
   - Release lock

### NONSTRICT_READ_WRITE Example Flow:
1. POST /insert → DB insert
2. GET /user → Cache miss → DB read → Store in cache
3. PUT /update → 
   - Acquire lock
   - Update DB
   - On success: invalidate cache (don't update)
   - Release lock
4. Next GET /user → Cache invalid → DB read → Store in cache

## Debugging Tips

1. Set breakpoints in:
   - JCacheRegionFactory (cache initialization)
   - Cache operations during GET/PUT requests
2. Monitor SQL logs to see when DB is actually hit
3. Verify cache behavior after rollback scenarios

## Best Practices

1. Choose appropriate concurrency strategy based on:
   - Read vs write frequency
   - Data consistency requirements
   - Performance needs
2. Use regions to group entities with similar caching needs
3. Configure appropriate TTL and eviction policies per region
4. Monitor cache hit ratios in production
5. Consider cache size based on available memory

## Common Use Cases

1. **READ_ONLY**: Reference data (countries, currencies)
2. **READ_WRITE**: User profiles, product catalogs
3. **NONSTRICT_READ_WRITE**: High-read, low-write non-critical data
4. **TRANSACTIONAL**: Financial data requiring strict consistency

<br/>
<br/>

# Spring Boot Second Level Cache (L2 Cache) Testing Project

This is a complete end-to-end testing project for Spring Boot Second Level Caching with all four concurrency strategies.

## Project Setup

### 1. Create a new Spring Boot project

Use [Spring Initializr](https://start.spring.io/) with these dependencies:
- Spring Web
- Spring Data JPA
- H2 Database (for testing)
- Lombok (for reducing boilerplate code)

### 2. Add caching dependencies to pom.xml

```xml
<!-- Caching dependencies -->
<dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
    <version>3.10.0</version>
</dependency>
<dependency>
    <groupId>javax.cache</groupId>
    <artifactId>cache-api</artifactId>
</dependency>
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-jcache</artifactId>
</dependency>
```

### 3. Configure application.properties

```properties
# Enable H2 console
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# Database configuration
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# JPA properties
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.format_sql=true

# Second level cache configuration
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=jcache
spring.jpa.properties.javax.cache.provider=org.ehcache.jsr107.EhcacheCachingProvider
spring.jpa.properties.hibernate.generate_statistics=true
```

### 4. Create Ehcache configuration (ehcache.xml)

```xml
<config xmlns="http://www.ehcache.org/v3"
        xmlns:jcache="http://www.ehcache.org/v3/jsr107">

    <persistence directory="/tmp/spring-cache"/>

    <cache alias="readOnlyEntityCache">
        <key-type>java.lang.Long</key-type>
        <value-type>com.example.caching.model.ReadOnlyEntity</value-type>
        <expiry>
            <ttl unit="minutes">30</ttl>
        </expiry>
        <resources>
            <heap unit="entries">1000</heap>
            <offheap unit="MB">10</offheap>
        </resources>
    </cache>

    <cache alias="readWriteEntityCache">
        <key-type>java.lang.Long</key-type>
        <value-type>com.example.caching.model.ReadWriteEntity</value-type>
        <expiry>
            <ttl unit="minutes">30</ttl>
        </expiry>
        <resources>
            <heap unit="entries">1000</heap>
            <offheap unit="MB">10</offheap>
        </resources>
    </cache>

    <cache alias="nonStrictReadWriteEntityCache">
        <key-type>java.lang.Long</key-type>
        <value-type>com.example.caching.model.NonStrictReadWriteEntity</value-type>
        <expiry>
            <ttl unit="minutes">30</ttl>
        </expiry>
        <resources>
            <heap unit="entries">1000</heap>
            <offheap unit="MB">10</offheap>
        </resources>
    </cache>

    <cache alias="transactionalEntityCache">
        <key-type>java.lang.Long</key-type>
        <value-type>com.example.caching.model.TransactionalEntity</value-type>
        <expiry>
            <ttl unit="minutes">30</ttl>
        </expiry>
        <resources>
            <heap unit="entries">1000</heap>
            <offheap unit="MB">10</offheap>
        </resources>
    </cache>

</config>
```

## Entity Classes

### 1. ReadOnlyEntity.java

```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_ONLY, region = "readOnlyEntityCache")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ReadOnlyEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String description;
}
```

### 2. ReadWriteEntity.java

```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "readWriteEntityCache")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ReadWriteEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String description;
}
```

### 3. NonStrictReadWriteEntity.java

```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE, region = "nonStrictReadWriteEntityCache")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class NonStrictReadWriteEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String description;
}
```

### 4. TransactionalEntity.java

```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL, region = "transactionalEntityCache")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class TransactionalEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String description;
}
```

## Repository Interfaces

```java
public interface ReadOnlyEntityRepository extends JpaRepository<ReadOnlyEntity, Long> {}
public interface ReadWriteEntityRepository extends JpaRepository<ReadWriteEntity, Long> {}
public interface NonStrictReadWriteEntityRepository extends JpaRepository<NonStrictReadWriteEntity, Long> {}
public interface TransactionalEntityRepository extends JpaRepository<TransactionalEntity, Long> {}
```

## Service Layer

```java
@Service
@RequiredArgsConstructor
public class CacheDemoService {
    private final ReadOnlyEntityRepository readOnlyEntityRepository;
    private final ReadWriteEntityRepository readWriteEntityRepository;
    private final NonStrictReadWriteEntityRepository nonStrictReadWriteEntityRepository;
    private final TransactionalEntityRepository transactionalEntityRepository;

    // ReadOnly Entity Operations
    public ReadOnlyEntity createReadOnlyEntity(ReadOnlyEntity entity) {
        return readOnlyEntityRepository.save(entity);
    }

    public ReadOnlyEntity getReadOnlyEntity(Long id) {
        return readOnlyEntityRepository.findById(id).orElse(null);
    }

    // ReadWrite Entity Operations
    public ReadWriteEntity createReadWriteEntity(ReadWriteEntity entity) {
        return readWriteEntityRepository.save(entity);
    }

    public ReadWriteEntity getReadWriteEntity(Long id) {
        return readWriteEntityRepository.findById(id).orElse(null);
    }

    public ReadWriteEntity updateReadWriteEntity(Long id, String newName) {
        ReadWriteEntity entity = readWriteEntityRepository.findById(id).orElseThrow();
        entity.setName(newName);
        return readWriteEntityRepository.save(entity);
    }

    // NonStrictReadWrite Entity Operations
    public NonStrictReadWriteEntity createNonStrictReadWriteEntity(NonStrictReadWriteEntity entity) {
        return nonStrictReadWriteEntityRepository.save(entity);
    }

    public NonStrictReadWriteEntity getNonStrictReadWriteEntity(Long id) {
        return nonStrictReadWriteEntityRepository.findById(id).orElse(null);
    }

    public NonStrictReadWriteEntity updateNonStrictReadWriteEntity(Long id, String newName) {
        NonStrictReadWriteEntity entity = nonStrictReadWriteEntityRepository.findById(id).orElseThrow();
        entity.setName(newName);
        return nonStrictReadWriteEntityRepository.save(entity);
    }

    // Transactional Entity Operations
    public TransactionalEntity createTransactionalEntity(TransactionalEntity entity) {
        return transactionalEntityRepository.save(entity);
    }

    public TransactionalEntity getTransactionalEntity(Long id) {
        return transactionalEntityRepository.findById(id).orElse(null);
    }

    public TransactionalEntity updateTransactionalEntity(Long id, String newName) {
        TransactionalEntity entity = transactionalEntityRepository.findById(id).orElseThrow();
        entity.setName(newName);
        return transactionalEntityRepository.save(entity);
    }
}
```

## Controller Layer

```java
@RestController
@RequestMapping("/api/cache-demo")
@RequiredArgsConstructor
public class CacheDemoController {
    private final CacheDemoService cacheDemoService;

    // ReadOnly Entity Endpoints
    @PostMapping("/read-only")
    public ReadOnlyEntity createReadOnlyEntity(@RequestBody ReadOnlyEntity entity) {
        return cacheDemoService.createReadOnlyEntity(entity);
    }

    @GetMapping("/read-only/{id}")
    public ReadOnlyEntity getReadOnlyEntity(@PathVariable Long id) {
        return cacheDemoService.getReadOnlyEntity(id);
    }

    // ReadWrite Entity Endpoints
    @PostMapping("/read-write")
    public ReadWriteEntity createReadWriteEntity(@RequestBody ReadWriteEntity entity) {
        return cacheDemoService.createReadWriteEntity(entity);
    }

    @GetMapping("/read-write/{id}")
    public ReadWriteEntity getReadWriteEntity(@PathVariable Long id) {
        return cacheDemoService.getReadWriteEntity(id);
    }

    @PutMapping("/read-write/{id}")
    public ReadWriteEntity updateReadWriteEntity(@PathVariable Long id, @RequestParam String newName) {
        return cacheDemoService.updateReadWriteEntity(id, newName);
    }

    // NonStrictReadWrite Entity Endpoints
    @PostMapping("/non-strict-read-write")
    public NonStrictReadWriteEntity createNonStrictReadWriteEntity(@RequestBody NonStrictReadWriteEntity entity) {
        return cacheDemoService.createNonStrictReadWriteEntity(entity);
    }

    @GetMapping("/non-strict-read-write/{id}")
    public NonStrictReadWriteEntity getNonStrictReadWriteEntity(@PathVariable Long id) {
        return cacheDemoService.getNonStrictReadWriteEntity(id);
    }

    @PutMapping("/non-strict-read-write/{id}")
    public NonStrictReadWriteEntity updateNonStrictReadWriteEntity(@PathVariable Long id, @RequestParam String newName) {
        return cacheDemoService.updateNonStrictReadWriteEntity(id, newName);
    }

    // Transactional Entity Endpoints
    @PostMapping("/transactional")
    public TransactionalEntity createTransactionalEntity(@RequestBody TransactionalEntity entity) {
        return cacheDemoService.createTransactionalEntity(entity);
    }

    @GetMapping("/transactional/{id}")
    public TransactionalEntity getTransactionalEntity(@PathVariable Long id) {
        return cacheDemoService.getTransactionalEntity(id);
    }

    @PutMapping("/transactional/{id}")
    public TransactionalEntity updateTransactionalEntity(@PathVariable Long id, @RequestParam String newName) {
        return cacheDemoService.updateTransactionalEntity(id, newName);
    }
}
```

## Testing the Application

### 1. Start the application

Run the Spring Boot application. You can access the H2 console at: `http://localhost:8080/h2-console`

### 2. Test READ_ONLY Strategy

**Step 1:** Create a READ_ONLY entity
```bash
POST http://localhost:8080/api/cache-demo/read-only
Content-Type: application/json

{
  "name": "ReadOnly Test",
  "description": "Test description"
}
```

**Step 2:** Retrieve the entity multiple times
```bash
GET http://localhost:8080/api/cache-demo/read-only/1
```

**Observation:**
- First GET will show SQL in logs (cache miss)
- Subsequent GETs won't show SQL (cache hit)
- Attempting to update will throw an exception

### 3. Test READ_WRITE Strategy

**Step 1:** Create a READ_WRITE entity
```bash
POST http://localhost:8080/api/cache-demo/read-write
Content-Type: application/json

{
  "name": "ReadWrite Test",
  "description": "Test description"
}
```

**Step 2:** Retrieve the entity
```bash
GET http://localhost:8080/api/cache-demo/read-write/1
```

**Step 3:** Update the entity
```bash
PUT http://localhost:8080/api/cache-demo/read-write/1?newName=Updated%20Name
```

**Step 4:** Retrieve again
```bash
GET http://localhost:8080/api/cache-demo/read-write/1
```

**Observation:**
- First GET shows SQL (cache miss)
- Second GET (before update) doesn't show SQL (cache hit)
- Update shows SQL for update and cache invalidation
- GET after update shows SQL once (cache miss due to invalidation), then subsequent GETs hit cache

### 4. Test NONSTRICT_READ_WRITE Strategy

**Step 1:** Create a NONSTRICT_READ_WRITE entity
```bash
POST http://localhost:8080/api/cache-demo/non-strict-read-write
Content-Type: application/json

{
  "name": "NonStrict Test",
  "description": "Test description"
}
```

**Step 2:** Retrieve the entity
```bash
GET http://localhost:8080/api/cache-demo/non-strict-read-write/1
```

**Step 3:** Update the entity
```bash
PUT http://localhost:8080/api/cache-demo/non-strict-read-write/1?newName=Updated%20Name
```

**Step 4:** Retrieve again
```bash
GET http://localhost:8080/api/cache-demo/non-strict-read-write/1
```

**Observation:**
- Similar to READ_WRITE but with a small chance of stale reads during updates
- Cache is invalidated after update rather than updated

### 5. Test TRANSACTIONAL Strategy

**Step 1:** Create a TRANSACTIONAL entity
```bash
POST http://localhost:8080/api/cache-demo/transactional
Content-Type: application/json

{
  "name": "Transactional Test",
  "description": "Test description"
}
```

**Step 2:** Retrieve the entity
```bash
GET http://localhost:8080/api/cache-demo/transactional/1
```

**Step 3:** Update the entity
```bash
PUT http://localhost:8080/api/cache-demo/transactional/1?newName=Updated%20Name
```

**Step 4:** Retrieve again
```bash
GET http://localhost:8080/api/cache-demo/transactional/1
```

**Observation:**
- Strictest consistency
- During updates, reads are blocked or directed to DB
- Cache is updated transactionally

## Monitoring Cache Statistics

Add this endpoint to see cache statistics:

```java
@RestController
@RequestMapping("/api/cache-stats")
public class CacheStatsController {

    @Autowired
    private SessionFactory sessionFactory;

    @GetMapping
    public Map<String, Object> getCacheStats() {
        Statistics stats = sessionFactory.getStatistics();
        
        Map<String, Object> result = new HashMap<>();
        result.put("SecondLevelCacheHitCount", stats.getSecondLevelCacheHitCount());
        result.put("SecondLevelCacheMissCount", stats.getSecondLevelCacheMissCount());
        result.put("SecondLevelCachePutCount", stats.getSecondLevelCachePutCount());
        
        return result;
    }
}
```

Access it via:
```bash
GET http://localhost:8080/api/cache-stats
```

## Expected Output Analysis

1. **READ_ONLY**:
   - Cache hits after first read
   - Updates fail with exception

2. **READ_WRITE**:
   - Cache hits after first read
   - Updates invalidate cache
   - Next read after update causes DB hit, then cache hits again

3. **NONSTRICT_READ_WRITE**:
   - Similar to READ_WRITE but with possible stale reads during updates
   - Cache invalidated rather than updated after writes

4. **TRANSACTIONAL**:
   - Strict consistency
   - Reads may be blocked during updates
   - Cache updated transactionally

## Conclusion

This complete project demonstrates all four second-level cache concurrency strategies in Spring Boot with Hibernate. You can test each strategy's behavior by following the test steps and observing the SQL logs and cache statistics.