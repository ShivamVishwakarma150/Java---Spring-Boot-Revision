# **Microservices Load Balancing: Client-Side with Spring Cloud**

#### **1. Introduction & Core Concept**

A **Load Balancer (LB)** is a critical component that distributes incoming network traffic across multiple backend servers (instances). This prevents any single server from becoming a bottleneck, thereby enhancing:
*   **Scalability:** Handle more traffic by adding instances.
*   **Availability:** If one instance fails, traffic is routed to healthy ones.
*   **Performance:** Distributes load to prevent overutilization.

There are two primary types:
*   **Server-Side Load Balancer:** A dedicated, centralized piece of hardware or software (e.g., NGINX, AWS ALB) that sits between the client and the servers. The client is unaware of the multiple backend instances.
*   **Client-Side Load Balancer:** The logic for choosing an instance resides within the client application itself. The client queries a **Service Discovery** server (like Eureka) to get a list of all available instances and then uses its built-in algorithm to select one.

**Today's Focus:** **Client-Side Load Balancing** with **Spring Cloud Load Balancer**.

#### **2. Prerequisite: Service Discovery**

Client-side load balancing is intrinsically linked to Service Discovery. The process is:
1.  The client application asks the Service Discovery server (e.g., Eureka) for all instances of a service (e.g., `product-service`).
2.  The Service Discovery server returns the list (e.g., `192.168.1.10:8081`, `192.168.1.11:8082`).
3.  The client's **load balancer** uses an algorithm to pick one instance from this list.
4.  The client sends the request directly to the chosen instance.

Without a Service Discovery pattern, client-side load balancing cannot function dynamically.

#### **3. Spring Cloud Load Balancer in Action**

Spring Cloud provides abstractions to make client-side load balancing seamless. Let's see how it integrates with different HTTP clients.

#### **A. With `RestTemplate`**

**Without Load Balancer (Manual):**
You manually use the `DiscoveryClient` to get instances and choose one (e.g., always the first one). This is cumbersome and not intelligent.

```java
@Service
public class OrderService {
    @Autowired
    private RestTemplate restTemplate;
    @Autowired
    private DiscoveryClient discoveryClient;

    public Product getProduct(Long id) {
        // 1. Manually get instances from Discovery Server
        List<ServiceInstance> instances = discoveryClient.getInstances("product-service");
        if (instances.isEmpty()) throw new RuntimeException("Service not found!");

        // 2. Poor manual "algorithm" (always picks first instance)
        ServiceInstance instance = instances.get(0);
        String url = "http://" + instance.getHost() + ":" + instance.getPort() + "/products/" + id;

        // 3. Use RestTemplate
        return restTemplate.getForObject(url, Product.class);
    }
}
```

**With Spring Cloud Load Balancer (Automatic):**
1.  **Add Dependency:** Include `spring-cloud-starter-loadbalancer`.
2.  **Create a Load-Balanced `RestTemplate` Bean:** Use the `@LoadBalanced` annotation. This tells Spring to add a `LoadBalancerInterceptor` to this specific `RestTemplate` bean.
3.  **Invoke Service by Name:** Use the service name from discovery (e.g., `product-service`) instead of a hardcoded host:port. The load balancer handles the resolution.

```java
@Configuration
public class RestTemplateConfig {
    @Bean
    @LoadBalanced // The magic annotation
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

@Service
public class OrderService {
    @Autowired
    private RestTemplate restTemplate; // Injects the load-balanced bean

    public Product getProduct(Long id) {
        // Clean and simple! URL uses the service name.
        String url = "http://product-service/products/" + id;
        return restTemplate.getForObject(url, Product.class);
    }
}
```
**What happens under the hood?** The `@LoadBalanced` annotation adds a `LoadBalancerInterceptor`. When `restTemplate.getForObject(...)` is called, this interceptor:
1.  Extracts the service name (`product-service`) from the URL.
2.  Contacts the configured **Service Discovery** to get all instances.
3.  Uses the configured **Load Balancing algorithm** (default: Round Robin) to choose one instance.
4.  Rebuilds the request with the actual host and port of the chosen instance and executes it.

#### **B. With `FeignClient`**

It's even simpler with Feign, as the integration is automatic once you have the dependencies.
1.  Ensure `spring-cloud-starter-openfeign` and `spring-cloud-starter-loadbalancer` are present.
2.  Define your Feign Client interface.

```java
@FeignClient(name = "product-service") // Service name in discovery
public interface ProductClient {
    @GetMapping("/products/{id}")
    Product getProductById(@PathVariable Long id);
}

@Service
public class OrderService {
    @Autowired
    private ProductClient productClient; // Feign client is automatically load-balanced

    public Product getProduct(Long id) {
        return productClient.getProductById(id);
    }
}
```
Feign automatically uses Spring Cloud Load Balancer to resolve `product-service` and distribute requests.

#### **4. Load Balancing Algorithms & Configuration**

Spring Cloud Load Balancer comes with two built-in algorithms:
1.  **Round Robin (Default):** Distributes requests sequentially to each instance in turn.
2.  **Random:** randomly selects an instance for each request.

**The key concept:** A load-balancing algorithm is always **attached to a specific service (Service ID)**.

##### **How to Change the Algorithm for a Specific Service**

You can override the default Round Robin algorithm for a service (e.g., `product-service`) by defining a custom configuration.

1.  **Create a Configuration Class:** This class defines the load balancer implementation (e.g., `RandomLoadBalancer`) for a specific service.

```java
// Configuration specifically for 'product-service'
// This bean is created lazily, only when needed.
public class LoadBalancerProductConfig {
    @Bean
    ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {

        String serviceId = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        // Return a Random Load Balancer for this specific serviceId
        return new RandomLoadBalancer(
                loadBalancerClientFactory.getLazyProvider(serviceId, ServiceInstanceListSupplier.class),
                serviceId);
    }
}
```

2.  **Tell Your Application to Use This Config:** Annotate your main application class or a configuration class with `@LoadBalancerClient`.

```java
@SpringBootApplication
@EnableFeignClients
// Bind the configuration to the service name
@LoadBalancerClient(name = "product-service", configuration = LoadBalancerProductConfig.class)
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```
Now, all requests to `product-service` will use the **Random** algorithm, while requests to other services will still use the default **Round Robin**.

##### **How to Set a Global Default Algorithm**

Use `@LoadBalancerClients` to set a default configuration for all services, while still allowing specific overrides.

```java
@LoadBalancerClients(
        // Global default configuration for ALL services
        defaultConfiguration = GlobalLoadBalancerConfig.class,
        // Specific configurations for specific services
        value = {
                @LoadBalancerClient(name = "product-service", configuration = LoadBalancerProductConfig.class),
                @LoadBalancerClient(name = "order-service", configuration = SomeOtherConfig.class)
        }
)
public class OrderServiceApplication {
    // ...
}
```

Define your global config. The `@ConditionalOnMissingBean` ensures this is only used if no more specific configuration exists for a service.

```java
public class GlobalLoadBalancerConfig {
    @Bean
    @ConditionalOnMissingBean // Crucial: only create if no specific config exists
    ReactorLoadBalancer<ServiceInstance> roundRobinLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {

        String serviceId = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        // ServiceId is dynamically resolved at runtime!
        return new RoundRobinLoadBalancer(
                loadBalancerClientFactory.getLazyProvider(serviceId, ServiceInstanceListSupplier.class),
                serviceId);
    }
}
```

#### **5. Writing a Custom Load Balancer**

You can implement custom logic (e.g., Weighted, Least Connections, based on a custom metric).

1.  **Create a custom class** that extends `ReactorServiceInstanceLoadBalancer`.
2.  **Implement the `choose` method** with your logic.

```java
public class CustomLoadBalancer implements ReactorServiceInstanceLoadBalancer {

    private final String serviceId;
    private final ServiceInstanceListSupplier supplier;

    public CustomLoadBalancer(ServiceInstanceListSupplier supplier, String serviceId) {
        this.supplier = supplier;
        this.serviceId = serviceId;
    }

    @Override
    public Mono<Response<ServiceInstance>> choose(Request request) {
        return supplier.get().next().map(instances -> {
            if (instances.isEmpty()) {
                return new EmptyResponse();
            }
            // --- YOUR CUSTOM ALGORITHM LOGIC HERE ---
            // Example: Always pick the second instance (just a demo!)
            ServiceInstance instance = instances.get(1 % instances.size());
            // ----------------------------------------
            return new DefaultResponse(instance);
        });
    }
}
```

3.  **Use your custom load balancer** in your service-specific configuration class by returning a new instance of `CustomLoadBalancer`.

#### **Summary & Key Takeaways**

| Concept | Description |
| :--- | :--- |
| **Client-Side LB** | Load balancing logic is inside the client app. Requires Service Discovery. |
| **`@LoadBalanced`** | Annotation that enables load balancing for a `RestTemplate` bean. |
| **Service ID** | The key identifier (e.g., `product-service`) to which a load-balancing algorithm is attached. |
| **Default Algorithm** | **Round Robin** is used for all services by default. |
| **Change Algorithm** | Use `@LoadBalancerClient(name = "x", configuration = Y.class)` to set a specific algorithm for service `x`. |
| **Global Config** | Use `@LoadBalancerClients(defaultConfiguration = Z.class)` to set a default for all services. Use `@ConditionalOnMissingBean` to avoid conflicts. |
| **Custom Algorithm** | Implement `ReactorServiceInstanceLoadBalancer` and override the `choose()` method. |
| **Runtime Resolution** | Load balancer configuration beans are created **lazily at runtime** when the service is first called, allowing dynamic resolution of the `serviceId`. |

**Remember:** The deep dive into the `LoadBalancerInterceptor` and the lazy creation of configuration beans is what helps you debug complex issues and create advanced, specific load-balancing rules for your microservices architecture.

---