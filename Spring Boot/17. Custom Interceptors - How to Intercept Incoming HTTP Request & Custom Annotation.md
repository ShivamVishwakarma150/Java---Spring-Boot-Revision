# Spring Boot Custom Interceptors - Detailed Notes

## üéØ Introduction

Interceptors are **mediators** that get invoked **before or after** your actual code execution. They are crucial for cross-cutting concerns like:
- Authentication & Authorization
- Logging
- Caching
- Request/Response modification

---

## üîß Prerequisites
1. **Java Annotations** - Understand how annotations work
2. **Spring AOP** - Understand Aspect-Oriented Programming concepts
3. **Spring MVC** - Understand the request handling flow

---

## üìã Types of Interceptors

### 1. Handler Interceptor (Before Controller)
Intercepts requests **before** they reach the controller.

### 2. Method-level Interceptor (After Controller)
Intercepts method executions **after** the controller receives the request.

---

## üõ†Ô∏è Implementation 1: Handler Interceptor

### Step 1: Create Custom Interceptor Class
```java
@Component
public class MyCustomInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) {
        // Executes BEFORE controller method
        System.out.println("Pre Handle method is called");
        return true; // Continue execution
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) {
        // Executes AFTER controller method (only on success)
        System.out.println("Post Handle method is called");
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) {
        // Executes AFTER request completion (always - success or error)
        System.out.println("After Completion method is called");
    }
}
```

### Step 2: Register Interceptor
```java
@Configuration
public class AppConfig implements WebMvcConfigurer {
    
    @Autowired
    private MyCustomInterceptor myCustomInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(myCustomInterceptor)
                .addPathPatterns("/api/**")          // Include these paths
                .excludePathPatterns("/api/updateUser"); // Exclude these paths
    }
}
```

### üåä Execution Flow
1. Request ‚Üí DispatcherServlet
2. **preHandle()** executed
3. Controller method executed
4. **postHandle()** executed (only if no exception)
5. **afterCompletion()** executed (always)

---

## üõ†Ô∏è Implementation 2: Method-level Interceptor

### Step 1: Create Custom Annotation
```java
@Target(ElementType.METHOD)           // Where annotation can be used
@Retention(RetentionPolicy.RUNTIME)   // Available at runtime
public @interface MyCustomAnnotation {
    String name() default "";          // Annotation field
    int value() default 0;             // Another field
}
```

### üìä Retention Policies
| Policy | Description |
|--------|-------------|
| SOURCE | Discarded by compiler, not in .class files |
| CLASS | Recorded in .class but ignored by JVM |
| RUNTIME | Recorded in .class AND available at runtime |

### Step 2: Use Annotation on Method
```java
@RestController
public class UserController {
    
    @GetMapping("/getUser")
    @MyCustomAnnotation(name = "user", value = 10)
    public User getUser() {
        return new User("John", 30);
    }
}
```

### Step 3: Create Aspect Interceptor
```java
@Component
@Aspect
public class MyCustomInterceptorAspect {
    
    @Around("@annotation(com.example.MyCustomAnnotation)")
    public Object interceptMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        
        // Before method execution
        System.out.println("Doing something before actual method");
        
        // Get annotation details
        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
        MyCustomAnnotation annotation = method.getAnnotation(MyCustomAnnotation.class);
        
        System.out.println("Annotation name: " + annotation.name());
        System.out.println("Annotation value: " + annotation.value());
        
        // Proceed with actual method
        Object result = joinPoint.proceed();
        
        // After method execution
        System.out.println("Doing something after actual method");
        
        return result;
    }
}
```

---

## üéØ Key Differences

| Handler Interceptor | Method Interceptor |
|---------------------|-------------------|
| Works at HTTP request level | Works at method level |
| Implement HandlerInterceptor | Uses AOP aspects |
| Configured via WebMvcConfigurer | Uses @Aspect annotations |
| Pre/Post controller execution | Wraps specific methods |

---

## üí° Use Cases

1. **Authentication**: Validate tokens before controller execution
2. **Logging**: Log method executions with custom annotations
3. **Caching**: Check cache before method execution
4. **Validation**: Validate request parameters/body
5. **Performance Monitoring**: Measure execution time

---

## ‚ö†Ô∏è Important Notes

- **preHandle()** must return `true` to continue execution
- **postHandle()** only runs if controller executes successfully
- **afterCompletion()** always runs (like `finally` block)
- Method interceptors require **AOP dependency** in Spring Boot
- Use **@Order** to define interceptor execution sequence

---

## üîß Dependencies

For method interceptors, ensure you have:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

---

## üìù Summary

1. **Handler Interceptors** - For request/response level interception
2. **Custom Annotations** - Define where and how to intercept
3. **AOP Aspects** - For method-level interception logic
4. **Runtime Retention** - Essential for reflection-based interception
5. **Flexible Configuration** - Include/exclude specific paths/methods

Mastering interceptors is crucial for building robust, maintainable Spring Boot applications with proper cross-cutting concern separation.

---

*Practice these concepts thoroughly as they form the foundation for advanced topics like security, caching, and monitoring in Spring Boot applications.*