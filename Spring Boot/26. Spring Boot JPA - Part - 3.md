# **JPA Annotations and Entity Mappings - Detailed Notes**

## **1. Schema and Table Configuration (`spring.jpa.hibernate.ddl-auto`)**
- **Purpose**: Controls how Hibernate manages the database schema.
- **Options**:
  - **`none`**: Does nothing (Recommended for **production**).
  - **`update`**: Updates schema (adds new columns, but **does not delete** existing ones).
  - **`validate`**: Validates if DB schema matches entities (throws exception if mismatch).
  - **`create`**: Drops and recreates schema on **startup** (deletes existing data).
  - **`create-drop`**: Creates schema on startup and drops it on **shutdown** (useful for testing).

### **Difference Between DB and Schema**
- A **database (DB)** can have multiple **schemas** (logical grouping of tables).
- **Example**:
  - **DB**: `CompanyDB`
  - **Schemas**: `HR_Schema`, `Finance_Schema`, `Sales_Schema`
- **Why use schemas?**
  - Multiple teams can share one DB but have separate schemas.
  - Better permission management (each team owns its schema).

### **How to Define Schema in `application.properties`**
```properties
# Create schema if not exists
spring.datasource.url=jdbc:mysql://localhost:3306/CompanyDB?createDatabaseIfNotExist=true&init=CREATE SCHEMA IF NOT EXISTS onboarding
```
- **In Entity**:
  ```java
  @Table(name = "user_details", schema = "onboarding")
  public class UserDetails { ... }
  ```

---

## **2. `@Table` Annotation**
- **Purpose**: Customize table name, schema, and constraints.
- **Attributes**:
  - **`name`**: Specifies table name (default: entity name in lowercase with underscores).
  - **`schema`**: Assigns table to a schema.
  - **`uniqueConstraints`**: Defines composite unique keys.
  - **`indexes`**: Creates indexes on columns.

### **Example: Unique Constraints**
```java
@Table(
    name = "user_details",
    uniqueConstraints = {
        @UniqueConstraint(columnNames = {"phone"}),
        @UniqueConstraint(columnNames = {"name", "email"})
    }
)
public class UserDetails { ... }
```
- **Result**: 
  - `phone` must be unique.
  - `name` + `email` combination must be unique.

### **Example: Indexes**
```java
@Table(
    indexes = {
        @Index(name = "idx_phone", columnList = "phone"),
        @Index(name = "idx_name_email", columnList = "name,email")
    }
)
```
- **Result**: Improves query performance on `phone` and `(name, email)`.

---

## **3. `@Column` Annotation**
- **Purpose**: Customize column properties.
- **Attributes**:
  - **`name`**: Column name in DB.
  - **`unique`**: Enforces uniqueness (`@Column(unique = true)`).
  - **`nullable`**: Allows NULL values (`@Column(nullable = false)`).
  - **`length`**: Defines max length (`@Column(length = 100)`).

### **Example**
```java
@Column(name = "full_name", nullable = false, length = 50)
private String name;
```

---

## **4. Primary Key Strategies (`@Id` and `@GeneratedValue`)**
### **Single Primary Key**
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment (MySQL)
private Long id;
```
- **Strategies**:
  - **`IDENTITY`**: Auto-increment (DB-managed).
  - **`SEQUENCE`**: Uses DB sequence (Oracle, PostgreSQL).
  - **`TABLE`**: Uses a separate table (inefficient, rarely used).

### **Composite Primary Key (Two Approaches)**
#### **Approach 1: `@IdClass`**
1. **Create a separate class** (implements `Serializable`):
   ```java
   public class UserDetailsPK implements Serializable {
       private String name;
       private String address;
       // Must override equals() and hashCode()
   }
   ```
2. **Use in Entity**:
   ```java
   @IdClass(UserDetailsPK.class)
   public class UserDetails {
       @Id private String name;
       @Id private String address;
   }
   ```

#### **Approach 2: `@Embeddable` + `@EmbeddedId`**
1. **Create an embeddable class**:
   ```java
   @Embeddable
   public class UserDetailsPK implements Serializable {
       private String name;
       private String address;
       // Must override equals() and hashCode()
   }
   ```
2. **Use in Entity**:
   ```java
   public class UserDetails {
       @EmbeddedId
       private UserDetailsPK id;
   }
   ```

### **Why `equals()` and `hashCode()`?**
- JPA uses **hash maps** for caching (1st/2nd level cache).
- Composite keys must be **compared correctly** for caching.

### **Why `Serializable`?**
- Composite keys may be **serialized** (e.g., distributed caching).

---

## **5. `@GeneratedValue` with `SEQUENCE` (Recommended for Scalability)**
### **How to Define a Sequence**
```java
@SequenceGenerator(
    name = "user_seq_gen",
    sequenceName = "user_sequence",
    initialValue = 100,
    allocationSize = 5
)
public class UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq_gen")
    private Long id;
}
```
- **Behavior**:
  - First 5 inserts: `100, 101, 102, 103, 104` (no DB calls after initial fetch).
  - 6th insert: Fetches next 5 values (`105-109`).

### **Advantages Over `IDENTITY`**
1. **Not tied to a table** (can be shared across tables).
2. **Better performance** (caching multiple IDs).
3. **Portable** (works consistently across DBs).

---

## **6. `@TableGenerator` (Avoid Using)**
- Creates a **separate table** to manage IDs.
- **Disadvantages**:
  - Slower (requires `SELECT` + `UPDATE` for each ID).
  - Concurrency issues (requires locks).

---

## **Next Topics (Coming Soon)**
1. **Relationships**:
   - `@OneToOne`, `@OneToMany`, `@ManyToMany`.
2. **Custom Queries**:
   - JPQL, Criteria API, Pagination, Sorting.

---

### **Summary**
| Annotation | Purpose | Example |
|------------|---------|---------|
| `@Table` | Configures table name, schema, constraints | `@Table(name = "users", schema = "hr")` |
| `@Column` | Customizes column properties | `@Column(name = "full_name", nullable = false)` |
| `@Id` | Marks primary key | `@Id private Long id;` |
| `@GeneratedValue` | Auto-generates IDs | `@GeneratedValue(strategy = SEQUENCE)` |
| `@IdClass` | Composite key (approach 1) | `@IdClass(UserPK.class)` |
| `@Embeddable` + `@EmbeddedId` | Composite key (approach 2) | `@EmbeddedId private UserPK id;` |

<br/>
<br/>

# **Composite Primary Key in JPA (Two Approaches with Examples)**

A **composite primary key** consists of **multiple columns** that together uniquely identify a row.  
JPA supports two approaches:
1. **`@IdClass`** (Older approach, more verbose)
2. **`@Embeddable` + `@EmbeddedId`** (Modern, cleaner)

---

## **1. `@IdClass` Approach**
### **Use Case:**  
A `Student` table where **`studentId` + `courseId`** together form a composite key.

### **Step 1: Define the Composite Key Class**
- Must implement `Serializable`.
- Must override `equals()` and `hashCode()`.

```java
import java.io.Serializable;
import java.util.Objects;

public class StudentCoursePK implements Serializable {
    private Long studentId;
    private Long courseId;

    // Default constructor (required)
    public StudentCoursePK() {}

    // Constructor with fields
    public StudentCoursePK(Long studentId, Long courseId) {
        this.studentId = studentId;
        this.courseId = courseId;
    }

    // Getters & Setters

    // Must override equals() and hashCode()
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        StudentCoursePK that = (StudentCoursePK) o;
        return studentId.equals(that.studentId) && courseId.equals(that.courseId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(studentId, courseId);
    }
}
```

### **Step 2: Use `@IdClass` in Entity**
```java
import javax.persistence.*;

@Entity
@Table(name = "student_courses")
@IdClass(StudentCoursePK.class) // Link the composite key class
public class StudentCourse {
    @Id
    @Column(name = "student_id")
    private Long studentId;

    @Id
    @Column(name = "course_id")
    private Long courseId;

    private String grade;

    // Constructors, Getters, Setters
}
```

### **How to Use**
```java
// Insert a record
StudentCourse sc = new StudentCourse();
sc.setStudentId(1L);
sc.setCourseId(101L);
sc.setGrade("A");
studentCourseRepository.save(sc);

// Find by composite key
StudentCourse found = studentCourseRepository.findById(new StudentCoursePK(1L, 101L)).orElse(null);
```

---

## **2. `@Embeddable` + `@EmbeddedId` Approach**
### **Use Case:**  
A `Book` table where **`isbn` + `authorId`** together form a composite key.

### **Step 1: Define the Embeddable Key Class**
```java
import java.io.Serializable;
import java.util.Objects;
import javax.persistence.Embeddable;

@Embeddable
public class BookId implements Serializable {
    private String isbn;
    private Long authorId;

    // Default constructor (required)
    public BookId() {}

    // Constructor with fields
    public BookId(String isbn, Long authorId) {
        this.isbn = isbn;
        this.authorId = authorId;
    }

    // Getters & Setters

    // Must override equals() and hashCode()
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BookId bookId = (BookId) o;
        return isbn.equals(bookId.isbn) && authorId.equals(bookId.authorId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(isbn, authorId);
    }
}
```

### **Step 2: Use `@EmbeddedId` in Entity**
```java
import javax.persistence.*;

@Entity
@Table(name = "books")
public class Book {
    @EmbeddedId
    private BookId id; // Composite key

    private String title;
    private Double price;

    // Constructors, Getters, Setters
}
```

### **How to Use**
```java
// Insert a record
Book book = new Book();
book.setId(new BookId("978-1234567890", 1L));
book.setTitle("JPA Mastery");
book.setPrice(29.99);
bookRepository.save(book);

// Find by composite key
Book found = bookRepository.findById(new BookId("978-1234567890", 1L)).orElse(null);
```

---

## **Key Differences**
| Feature | `@IdClass` | `@Embeddable` + `@EmbeddedId` |
|---------|-----------|-------------------------------|
| **Structure** | Separate key class, fields duplicated in entity | Single embedded object |
| **Access** | Direct field access (`studentId`, `courseId`) | Access via embedded object (`book.getId().getIsbn()`) |
| **Usage** | Legacy systems | Modern, cleaner approach |
| **Flexibility** | Works well with JPA 1.0 | Better for complex keys |

---

## **Which One to Choose?**
- **Use `@IdClass`** if:
  - Working with legacy code.
  - Prefer direct field access.
- **Use `@Embeddable` + `@EmbeddedId`** if:
  - Want cleaner encapsulation.
  - Composite key is complex (e.g., nested keys).

Both approaches ensure **uniqueness** and **proper caching** (via `equals()` and `hashCode()`).  
