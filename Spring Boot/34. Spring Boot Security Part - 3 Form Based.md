# **Form Login Authentication in Spring Security - Detailed Explanation**

## **1. Introduction**
Form Login Authentication is a **stateful** authentication method where the server maintains the user's authentication state (session). 

### **Key Points:**
- **Stateful**: Server stores session data.
- **Default in Spring Boot Security** (not JWT).
- Requires **username & password** only once; subsequent requests use a **session ID**.
- Uses **default endpoints**: `/login` (login), `/logout` (logout).

---

## **2. How Form Login Works**
### **Step 1: User Logs In (First Request)**
1. User sends credentials (`/login` endpoint).
2. Server validates credentials.
3. If valid, server:
   - Creates an **HTTP Session** (stores session ID, expiry time, etc.).
   - Stores **Security Context** (authentication details) in the session.
   - Sends back **session ID** in **response cookie** (e.g., `JSESSIONID`).

### **Step 2: Subsequent Requests**
1. User sends request with **session ID** (in cookies).
2. Server checks:
   - If session exists & is valid → Processes request.
   - If session is invalid/expired → Redirects to `/login`.

---

## **3. Session Management**
### **Where is Session Stored?**
- **In-memory (default)**: Fast but not scalable (single server only).
- **Database (recommended for distributed systems)**:
  - Use `spring-session-jdbc` dependency.
  - Tables: `spring_session`, `spring_session_attributes`.
  - Stores session ID, creation time, expiry, and security context.

### **Session Expiry**
- Default: **30 minutes** (configurable in `application.properties`):
  ```properties
  server.servlet.session.timeout=1m  # 1 minute
  ```
- **Inactivity-based expiry**: If no request is made within the timeout, the session expires.

---

## **4. Flow Diagram (Step-by-Step)**
### **Login Flow**
1. **User hits `/login`** → Provides username & password.
2. **Spring Security Filter Chain**:
   - `UsernamePasswordAuthenticationFilter` creates an `Authentication` object.
   - `AuthenticationManager` validates credentials.
   - If valid:
     - Updates `Authentication` object (sets `authenticated=true`, adds roles).
     - Stores it in `SecurityContext`.
     - `SecurityContextRepository` saves it in **HTTP Session**.
3. **Response**: Session ID sent in cookie.

### **Subsequent Requests Flow**
1. **User sends request with `JSESSIONID`**.
2. **Filter Chain**:
   - `SecurityContextHolderFilter` fetches session from DB/memory.
   - Retrieves `SecurityContext` (authentication data).
   - `AuthorizationFilter` checks if user has required roles.
3. If authorized → Request proceeds to controller.

---

## **5. Configuration**
### **Default Behavior**
- No code needed! Spring Boot auto-configures:
  - `/login` endpoint (default form).
  - Session management.
  - CSRF protection (enabled by default).

### **Custom Configuration**
If you need:
- Custom login/logout URLs.
- Public APIs (no authentication).
- Role-based access.

**Example:**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()  // Public API
                .requestMatchers("/users/**").hasRole("USER")  // Requires USER role
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/custom-login")  // Custom login page
                .defaultSuccessUrl("/home")
            )
            .logout(logout -> logout
                .logoutUrl("/custom-logout")  // Custom logout
            )
            .sessionManagement(session -> session
                .maximumSessions(1)  // Only 1 session per user
                .maxSessionsPreventsLogin(true)  // Block new logins if limit reached
            );
        return http.build();
    }
}
```

---

## **6. Role-Based Authorization**
- By default, **no restrictions** (only checks authentication).
- Use `.hasRole()`, `.hasAnyRole()` to restrict access:
  ```java
  .requestMatchers("/admin/**").hasRole("ADMIN")
  .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
  ```

### **How Roles are Checked?**
1. **Authentication object** (from session) contains user roles.
2. **AuthorizationFilter** compares roles with required roles.
3. If mismatch → **403 Forbidden**.

---

## **7. Disadvantages of Form Login**
1. **CSRF Vulnerable** (though enabled by default).
2. **Session Hijacking Risk** (session ID can be stolen).
3. **Scalability Issues**:
   - Session storage (DB load in distributed systems).
   - Session management overhead.
4. **Not Stateless** (unlike JWT).

---

## **8. Key Takeaways**
- **Form Login = Stateful** (server stores session).
- **Default in Spring Security** (not JWT).
- **Session stored in memory/DB** (use DB for scalability).
- **Role-based auth** must be manually configured.
- **Not ideal for microservices** (use JWT/OAuth instead).

---

## **9. Demo Recap**
1. **Login** → Creates session (stored in DB).
2. **Access `/users`** → Checks session & roles.
3. **Logout** → Invalidates session.

---

### **Next Steps**
- Try implementing **dynamic user creation** (from DB).
- Experiment with **session timeout**.
- Compare with **JWT** (stateless auth).

---

<br/>
<br/>

# **Form Login Authentication - Complete Spring Boot Project**

Below is a complete Spring Boot project implementing Form Login Authentication with proper comments explaining each part. This includes:
- User registration & dynamic user creation
- Session management (DB storage)
- Role-based authorization
- Custom login/logout
- Security configurations

## **1. Project Structure**
```
src/
├── main/
│   ├── java/
│   │   └── com/
│   │       └── example/
│   │           └── demo/
│   │               ├── config/
│   │               │   ├── SecurityConfig.java      # Security Configuration
│   │               │   └── UserDetailsServiceImpl.java # Custom UserDetailsService
│   │               ├── controller/
│   │               │   ├── AuthController.java      # Login/Logout endpoints
│   │               │   └── UserController.java      # User endpoints
│   │               ├── model/
│   │               │   └── User.java                # User Entity
│   │               ├── repository/
│   │               │   └── UserRepository.java      # User Repository (JPA)
│   │               └── DemoApplication.java         # Main Application
│   └── resources/
│       ├── static/                                  # Frontend (if needed)
│       ├── templates/                               # Thymeleaf (if needed)
│       ├── application.properties                   # DB & Session Config
│       └── data.sql                                 # Initial Data (optional)
```

---

## **2. `pom.xml` (Dependencies)**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project>
    <dependencies>
        <!-- Spring Boot Starter Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- Spring Security -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- Spring Data JPA (For User Storage) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- H2 Database (For Testing) -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Spring Session JDBC (Store Session in DB) -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-jdbc</artifactId>
        </dependency>

        <!-- Lombok (Optional) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```

---

## **3. `application.properties`**
```properties
# Database Configuration (H2 in-memory)
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# H2 Console (Access at http://localhost:8080/h2-console)
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# Session Management (Store in DB)
spring.session.store-type=jdbc
spring.session.jdbc.initialize-schema=always  # Auto-create session tables
server.servlet.session.timeout=5m             # Session expires after 5 mins

# JPA (Create tables automatically)
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

---

## **4. `User.java` (Entity)**
```java
package com.example.demo.model;

import jakarta.persistence.*;
import lombok.Data;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;

@Data
@Entity
@Table(name = "users")
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    private String role; // "ROLE_USER", "ROLE_ADMIN"

    // Spring Security Methods
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(role));
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}
```

---

## **5. `UserRepository.java` (JPA Repository)**
```java
package com.example.demo.repository;

import com.example.demo.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
```

---

## **6. `UserDetailsServiceImpl.java` (Custom UserDetailsService)**
```java
package com.example.demo.config;

import com.example.demo.model.User;
import com.example.demo.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    public UserDetailsServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        return user; // User implements UserDetails
    }
}
```

---

## **7. `SecurityConfig.java` (Security Configuration)**
```java
package com.example.demo.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()       // Public API
                .requestMatchers("/user/**").hasRole("USER")     // Only USER role
                .requestMatchers("/admin/**").hasRole("ADMIN")   // Only ADMIN role
                .anyRequest().authenticated()                    // All others need auth
            )
            .formLogin(form -> form
                .loginPage("/login")            // Custom login page (if needed)
                .defaultSuccessUrl("/home")     // Redirect after login
                .permitAll()
            )
            .logout(logout -> logout
                .logoutUrl("/logout")           // Custom logout
                .logoutSuccessUrl("/login")     // Redirect after logout
                .permitAll()
            )
            .sessionManagement(session -> session
                .maximumSessions(1)             // Allow only 1 session per user
                .maxSessionsPreventsLogin(true) // Block new logins if limit reached
            );

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(); // Password hashing
    }
}
```

---

## **8. `AuthController.java` (Login/Logout Endpoints)**
```java
package com.example.demo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class AuthController {

    @GetMapping("/login")
    public String loginPage() {
        return "login"; // Thymeleaf/HTML page (if needed)
    }

    @GetMapping("/home")
    public String homePage() {
        return "home"; // Thymeleaf/HTML page (if needed)
    }
}
```

---

## **9. `UserController.java` (User Endpoints)**
```java
package com.example.demo.controller;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/user")
public class UserController {

    @GetMapping("/hello")
    @PreAuthorize("hasRole('USER')") // Alternative to SecurityConfig
    public String userHello() {
        return "Hello, User!";
    }
}

@RestController
@RequestMapping("/admin")
public class AdminController {

    @GetMapping("/hello")
    @PreAuthorize("hasRole('ADMIN')")
    public String adminHello() {
        return "Hello, Admin!";
    }
}
```

---

## **10. `DemoApplication.java` (Main Class)**
```java
package com.example.demo;

import com.example.demo.model.User;
import com.example.demo.repository.UserRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.security.crypto.password.PasswordEncoder;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @Bean
    CommandLineRunner initUsers(UserRepository userRepo, PasswordEncoder encoder) {
        return args -> {
            // Create a USER
            User user = new User();
            user.setUsername("user");
            user.setPassword(encoder.encode("password"));
            user.setRole("ROLE_USER");
            userRepo.save(user);

            // Create an ADMIN
            User admin = new User();
            admin.setUsername("admin");
            admin.setPassword(encoder.encode("admin"));
            admin.setRole("ROLE_ADMIN");
            userRepo.save(admin);
        };
    }
}
```

---

## **11. Testing the Application**
1. **Run the app**: `mvn spring-boot:run`
2. **Access endpoints**:
   - `/public/**` → No auth needed.
   - `/user/hello` → Requires `USER` role (login with `user:password`).
   - `/admin/hello` → Requires `ADMIN` role (login with `admin:admin`).
3. **Check H2 DB**:
   - Open `http://localhost:8080/h2-console`
   - JDBC URL: `jdbc:h2:mem:testdb`
   - See `USERS`, `SPRING_SESSION` tables.

---

## **12. Key Features Demonstrated**
✅ **Form Login Authentication**  
✅ **Session Management (DB Storage)**  
✅ **Role-Based Authorization**  
✅ **Dynamic User Creation**  
✅ **Password Hashing (BCrypt)**  
✅ **CSRF Protection (Enabled by Default)**  

---

### **Next Steps**
1. **Extend with Thymeleaf/HTML** (for custom login pages).
2. **Add JWT Authentication** (stateless alternative).
3. **Implement OAuth2** (Google/Facebook login).

---