# **Spring RestClient: The Modern Synchronous HTTP Client**

#### **1. The "Why": Moving Beyond RestTemplate**

Spring's `RestTemplate` served us well for years, but it had significant flaws:
*   **API Bloat:** A confusing number of overloaded methods (`getForObject`, `getForEntity`, `postForLocation`, etc.) made code hard to read and remember.
*   **Deprecation:** While not fully removed, `RestTemplate` is now in "maintenance mode." Spring actively recommends using its modern successors for new applications.
*   **Legacy Foundation:** It was built on older HTTP client libraries that lack support for modern protocols like HTTP/2.

**Enter RestClient:** Introduced in **Spring Framework 6** and **Spring Boot 3**, `RestClient` is the new, modern synchronous HTTP client.
*   **Synchronous & Blocking:** The client thread waits for the server's response before proceeding. This is ideal for traditional, thread-per-request servlet applications and is the direct replacement for `RestTemplate`.
*   **Fluent API:** Its greatest strength. It uses a clean, method-chaining style that is intuitive and self-documenting.
*   **Modern & Powerful:** Built on Java's new `HttpClient` (from `java.net.http`), which supports HTTP/1.1 and HTTP/2 out of the box.

---

#### **2. The Heart of RestClient: The Fluent API**

A **Fluent API** is an object-oriented design pattern that relies on **method chaining** to create a readable, flowing interface. Each method returns an object that provides the context for the next logical step.

**How it Works:**
Imagine the process of making an HTTP request:
1.  You need to choose a **method** (GET, POST).
2.  You need to specify a **URL**.
3.  You might want to add **headers**.
4.  For POST/PUT, you need to provide a **body**.
5.  Finally, you need to **execute** the request and decide how to **handle the response**.

The `RestClient` API mirrors this exact flow. Each step in the chain returns a new object that only has methods relevant to the *next possible steps*. This design inherently guides you and prevents errors.

**Example Flow:**
`restClient.**get()**` -> (returns an object that lets you set the URI)
`.**uri("...")**` -> (returns an object that lets you set headers)
`.**header("Auth", "token")**` -> (returns the same type, so you can add more headers or execute)
`.**retrieve()**` -> (executes the request and returns an object for handling the response)
`.**body(Product.class)**`; (extracts the response body)

**Key Benefit:** You don't memorize methods; you follow the logical chain. The API design enforces correctness.

---

#### **3. Practical Code Examples**

**First, Create a RestClient Instance:**
You can create a default instance or use the builder for customization (base URLs, default headers, interceptors).

```java
import org.springframework.web.client.RestClient;

// Simple creation
RestClient simpleClient = RestClient.create();

// Builder for custom configuration (Recommended)
RestClient restClient = RestClient.builder()
        .baseUrl("https://api.example.com") // Set a base URL for all requests
        .defaultHeader("Authorization", "Bearer my-token") // Set a default header
        .defaultStatusHandler( // Set a default error handler
            status -> status.is4xxClientError(),
            (request, response) -> { throw new CustomClientException(); }
        )
        // .requestInterceptor(new MyInterceptor()) // Add an interceptor
        .build();
```

**Example 1: GET Request**
This is the most common use case. The chain is very straightforward.

```java
// Order Service (port 8081) calls Product Service (port 8082)
@RestController
public class OrderController {

    private final RestClient restClient;

    // Inject your configured RestClient bean
    public OrderController(RestClient restClient) {
        this.restClient = restClient;
    }

    @GetMapping("/orders/{id}")
    public String getOrderDetails(@PathVariable String id) {

        // The Fluent Chain in action:
        String productDetails = restClient.get()
                .uri("http://localhost:8082/products/" + id) // Set the endpoint
                .retrieve() // Execute the request and get response wrapper
                .body(String.class); // Map the full response body to a String

        return "Order details: " + productDetails;
    }
}
```

**Example 2: POST Request with a JSON Body**
Notice how the chain adapts to include steps for setting the request body and content type.

```java
// Create an object to send
Product newProduct = new Product("100", "New Product", 49.99);

Product createdProduct = restClient.post()
        .uri("/products") // Uses the baseURL from the builder
        .contentType(MediaType.APPLICATION_JSON) // Set the Content-Type header
        .body(newProduct) // Set the request body object (will be converted to JSON)
        .retrieve()
        .body(Product.class); // Map the response JSON back to a Product object
```

**Example 3: Advanced Error Handling with `.onStatus()`**
This is a major improvement over `RestTemplate`. You can declaratively handle specific HTTP status codes.

```java
try {
    Product product = restClient.get()
            .uri("/products/{id}", "invalid-id")
            .retrieve()
            // Handle 404 (Not Found) specifically
            .onStatus(
                status -> status.value() == 404,
                (request, response) -> {
                    throw new ProductNotFoundException("Product not found!");
                }
            )
            // Handle any other 4xx error
            .onStatus(
                status -> status.is4xxClientError(),
                (request, response) -> {
                    throw new InvalidRequestException("Client error: " + response.getStatusText());
                }
            )
            // Handle 5xx server errors
            .onStatus(
                status -> status.is5xxServerError(),
                (request, response) -> {
                    throw new ServiceUnavailableException("Server is down!");
                }
            )
            .body(Product.class); // This only happens if no error status was triggered

} catch (ProductNotFoundException e) {
    // Handle the custom exception
}
```

**Example 4: Using `.exchange()` for Full Control**
For cases where you need access to the response headers or status code, use `.exchange()`. You are responsible for reading the response.

```java
ResponseEntity<Product> responseEntity = restClient.get()
        .uri("/products/{id}", id)
        .accept(MediaType.APPLICATION_JSON)
        .exchange((request, response) -> {
            // This lambda gives you full access to the ClientHttpResponse

            // 1. Check status code manually
            if (response.getStatusCode().is2xxSuccessful()) {
                // 2. Convert the response body stream to an object
                Product product = objectMapper.readValue(response.getBody(), Product.class);

                // 3. Build a ResponseEntity with body, status, and headers
                return ResponseEntity.ok()
                        .headers(response.getHeaders())
                        .body(product);
            } else {
                // 4. Handle non-2xx responses
                throw new CustomException("Request failed with status: " + response.getStatusCode());
            }
        });
```

---

#### **4. Adding Custom Interceptors**

Interceptors are powerful tools for cross-cutting concerns like logging, authentication, and metrics. They can inspect and modify the outgoing request.

**Step 1: Implement the Interceptor Interface**
```java
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import java.io.IOException;

public class AuthInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
            ClientHttpRequestExecution execution) throws IOException {

        // 1. Modify the request before it is sent
        request.getHeaders().add("Authorization", "Bearer " + getAuthToken());

        // 2. (Optional) Log the request details
        System.out.println("Sending request to: " + request.getURI());

        // 3. Execute the request and proceed with the chain
        ClientHttpResponse response = execution.execute(request, body);

        // 4. (Optional) Modify or log the response
        System.out.println("Received status: " + response.getStatusCode());

        return response;
    }

    private String getAuthToken() {
        // ... logic to get a valid token
        return "secret-token";
    }
}
```

**Step 2: Configure RestClient with the Interceptor**
```java
@Bean
public RestClient restClient() {
    return RestClient.builder()
            .baseUrl("https://api.example.com")
            .requestInterceptor(new AuthInterceptor()) // Add your interceptor
            .requestInterceptor(new LoggingInterceptor()) // You can add multiple
            .build();
}
```

---

#### **Summary & Key Points**

*   **Use RestClient for all new synchronous HTTP communication** in Spring Boot 3+ applications. It is the official successor to `RestTemplate`.
*   **Embrace the Fluent API.** Let the method chain guide your code. It results in more readable and maintainable code.
*   **Leverage Declarative Error Handling.** Use `.onStatus()` to cleanly centralize your HTTP error logic.
*   **Customize with Builders and Interceptors.** The `RestClient.builder()` is your friend for setting up common configuration and adding powerful features like interceptors.
*   **It's Synchronous.** Remember the calling thread will block. For non-blocking, asynchronous calls, you would use `WebClient` instead.

<br/>
<br/>

# **Understanding Interceptors: The Gatekeepers of HTTP Requests**

An interceptor is a powerful mechanism that allows you to **intercept** an outgoing HTTP request and/or the incoming response. You can inspect, modify, and enhance the request/response before it continues its journey. Think of them as a chain of filters or middleware for your HTTP calls.

**Why Use Interceptors? (Real-World Use Cases)**
1.  **Authentication & Authorization:** Automatically add API keys, JWT tokens, or OAuth2 headers to every request.
2.  **Logging & Auditing:** Log detailed information about every request and response for debugging and monitoring.
3.  **Metrics & Tracing:** Add unique trace IDs (e.g., for Sleuth/Zipkin) to correlate logs across microservices and record metrics like request duration.
4.  **Request/Response Transformation:** Modify the request body or headers before sending, or modify the response before it's processed by your code.
5.  **Retry Mechanisms:** Implement logic to retry failed requests based on specific response status codes.

---

### **Deep Dive: The `ClientHttpRequestInterceptor` Interface**

To create an interceptor, you implement this interface. It has a single method:

```java
@FunctionalInterface
public interface ClientHttpRequestInterceptor {
    ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException;
}
```

*   **`HttpRequest request`:** The request object that you can modify (e.g., add headers).
*   **`byte[] body`:** The raw body of the request. You can read or modify it.
*   **`ClientHttpRequestExecution execution`:** The crucial object that represents the rest of the execution chain. You **must** call `execution.execute(request, body)` to proceed. This is where the actual HTTP call happens.
*   **Returns `ClientHttpResponse`:** You can return the response as-is, wrap it, or even throw an exception based on the response.

---

### **Real-Time Example: E-Commerce Microservice Communication**

**Scenario:**
Imagine an **Order Service** needs to call a **Product Service** to get product details before creating an order. The Product Service requires authentication via a JWT token and we want to log all inter-service communication.

We'll create two interceptors:
1.  **`AuthInterceptor`:** Adds an Authorization header with a JWT.
2.  **`LoggingInterceptor`:** Logs the request and response details.

#### **Step 1: Create the Interceptors**

**1. AuthInterceptor.java**
This interceptor is responsible for fetching a JWT (from a config, vault, or identity service) and adding it to the request.

```java
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.stereotype.Component;
import java.io.IOException;

@Component // Make it a Spring Bean so it can be injected
public class AuthInterceptor implements ClientHttpRequestInterceptor {

    // This could be fetched from a configuration service, a secret vault, etc.
    // For simplicity, we hardcode it here.
    private final String jwtToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        // 1. MODIFY THE REQUEST: Add the Authorization header
        request.getHeaders().add("Authorization", "Bearer " + jwtToken);

        // 2. PROCEED with the execution chain
        // This is where the actual HTTP call to the Product Service is made.
        // The request now has the auth header.
        ClientHttpResponse response = execution.execute(request, body);

        // 3. (Optional) You could modify the response here if needed.
        // For example, refresh the token if you get a 401 Unauthorized.
        if (response.getStatusCode().isSameCodeAs(HttpStatus.UNAUTHORIZED)) {
            System.out.println("Auth failed! Need to refresh token.");
            // Logic to refresh token would go here, then potentially retry the request.
        }
        return response;
    }
}
```

**2. LoggingInterceptor.java**
This interceptor logs the details of the request and the response for auditing and debugging.

```java
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.stereotype.Component;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

@Component
public class LoggingInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {

        // 1. LOG THE REQUEST
        logRequestDetails(request, body);

        // 2. Record the start time to calculate duration
        long startTime = System.currentTimeMillis();

        // 3. PROCEED with the execution (the actual HTTP call)
        ClientHttpResponse response = execution.execute(request, body);

        // 4. Calculate duration
        long duration = System.currentTimeMillis() - startTime;

        // 5. LOG THE RESPONSE
        logResponseDetails(response, duration);

        return response;
    }

    private void logRequestDetails(HttpRequest request, byte[] body) {
        System.out.println("=== RESTCLIENT REQUEST START ===");
        System.out.println("URI         : " + request.getURI());
        System.out.println("Method      : " + request.getMethod());
        System.out.println("Headers     : " + request.getHeaders());
        if (body.length > 0) {
            System.out.println("Request Body: " + new String(body, StandardCharsets.UTF_8));
        }
        System.out.println("=== RESTCLIENT REQUEST END ===");
    }

    private void logResponseDetails(ClientHttpResponse response, long duration) throws IOException {
        System.out.println("=== RESTCLIENT RESPONSE START ===");
        System.out.println("Status Code : " + response.getStatusCode());
        System.out.println("Status Text : " + response.getStatusText());
        System.out.println("Headers     : " + response.getHeaders());
        System.out.println("Duration    : " + duration + "ms");
        System.out.println("=== RESTCLIENT RESPONSE END ===");
    }
}
```

#### **Step 2: Configure RestClient with the Interceptors**

Now, we create a `@Configuration` class to build the `RestClient` bean and register our interceptors. The order of interception is the order in which they are added to the builder.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestClient;

@Configuration
public class RestClientConfig {

    private final AuthInterceptor authInterceptor;
    private final LoggingInterceptor loggingInterceptor;

    // Inject the interceptor beans we created
    public RestClientConfig(AuthInterceptor authInterceptor, LoggingInterceptor loggingInterceptor) {
        this.authInterceptor = authInterceptor;
        this.loggingInterceptor = loggingInterceptor;
    }

    @Bean
    public RestClient productServiceRestClient() {
        return RestClient.builder()
                .baseUrl("http://localhost:8082") // Base URL for Product Service
                // The order of interception is the order they are added.
                .requestInterceptor(loggingInterceptor) // 1st: Log the original request
                .requestInterceptor(authInterceptor)    // 2nd: Add auth to the request
                // .requestInterceptor(/* another one */) // You can add more
                .build();
    }
}
```

#### **Step 3: Use the Configured RestClient in your Service**

Finally, we inject and use the pre-configured `RestClient` in our Order Service.

```java
import org.springframework.stereotype.Service;

@Service
public class OrderService {

    private final RestClient productServiceRestClient;

    // Inject the RestClient bean configured in RestClientConfig
    public OrderService(RestClient productServiceRestClient) {
        this.productServiceRestClient = productServiceRestClient;
    }

    public Product getProductById(String productId) {
        // Notice how the RestClient is clean and simple.
        // All the complexity of auth and logging is hidden in the interceptors!
        Product product = productServiceRestClient.get()
                .uri("/api/products/{id}", productId) // Relative to baseUrl
                .retrieve()
                .body(Product.class);

        // ... logic to create an order using the product ...
        return product;
    }
}
```

---

### **Execution Flow & Console Output**

When `orderService.getProductById("123")` is called, this is what happens:

1.  The `RestClient` prepares a GET request to `http://localhost:8082/api/products/123`.
2.  The request first goes to the **`LoggingInterceptor`**, which logs the original request.
3.  The request then goes to the **`AuthInterceptor`**, which adds the `Authorization: Bearer ...` header.
4.  The `execution.execute()` call inside `AuthInterceptor` finally sends the request to the Product Service.
5.  The response comes back and is received by the `AuthInterceptor`, which checks for a `401` and then returns it.
6.  The response travels back to the **`LoggingInterceptor`**, which logs all the response details and the duration.
7.  The response is finally returned to the `OrderService`, which converts the JSON body to a `Product` object.

**Console Output:**
```
=== RESTCLIENT REQUEST START ===
URI         : http://localhost:8082/api/products/123
Method      : GET
Headers     : [Accept:"application/json"]
Request Body:
=== RESTCLIENT REQUEST END ===

=== RESTCLIENT RESPONSE START ===
Status Code : 200 OK
Status Text : OK
Headers     : [Content-Type:"application/json", X-Request-ID:"a1b2c3d4"]
Duration    : 145ms
=== RESTCLIENT RESPONSE END ===
```

This example shows how interceptors help you keep your business logic clean and separate cross-cutting concerns, making your code more modular, testable, and maintainable.

<br/>
<br/>

## Here is a comprehensive guide covering all the essential methods of Spring's `RestClient` with small, practical examples.

### **1. RestClient Creation Methods**

**a) `RestClient.create()`**
Creates a vanilla `RestClient` with default settings.
```java
RestClient client = RestClient.create();
String result = client.get()
        .uri("https://api.example.com/data")
        .retrieve()
        .body(String.class);
```

**b) `RestClient.builder()`**
The preferred way to create a customized client.
```java
RestClient client = RestClient.builder()
    .baseUrl("https://api.example.com") // Base for all requests
    .defaultHeader("Api-Key", "12345")  // Default header
    .defaultStatusHandler(              // Default error handling
        httpStatusCode -> httpStatusCode.is4xxClientError(),
        (request, response) -> { throw new RuntimeException("Client Error: " + response.getStatusCode()); }
    )
    .build();
```

---

### **2. HTTP Method Specifiers**

These are the starting points for building a request.

**a) `.get()`**
```java
String response = client.get()
        .uri("/users/1")
        .retrieve()
        .body(String.class);
```

**b) `.post()`**
```java
User newUser = new User("John Doe");
User createdUser = client.post()
        .uri("/users")
        .body(newUser)
        .retrieve()
        .body(User.class);
```

**c) `.put()`**
```java
User updatedUser = new User("Jane Doe");
client.put()
        .uri("/users/1")
        .body(updatedUser)
        .retrieve() // Often returns Void for PUT
        .toBodilessEntity(); // Use when no response body is expected
```

**d) `.patch()`**
```java
Map<String, String> updateFields = Map.of("name", "New Name");
client.patch()
        .uri("/users/1")
        .body(updateFields)
        .retrieve()
        .toBodilessEntity();
```

**e) `.delete()`**
```java
client.delete()
        .uri("/users/1")
        .retrieve()
        .toBodilessEntity();
```

**f) `.head()`**
```java
HttpHeaders headers = client.head()
        .uri("/users/1")
        .retrieve()
        .toBodilessEntity()
        .getHeaders(); // Get headers from the response
```

**g) `.options()`**
```java
HttpHeaders allowedMethods = client.options()
        .uri("/users/1")
        .retrieve()
        .toBodilessEntity()
        .getHeaders();
```

---

### **3. URI Definition Methods (`.uri()`)**

**a) Simple String URI**
```java
.uri("https://api.example.com/users/1")
```

**b) URI with Path Variables**
```java
.uri("/users/{id}/posts/{postId}", 1, 50)
// Becomes: /users/1/posts/50
```

**c) URI with Map of Variables**
```java
Map<String, Object> params = Map.of("userId", 1, "postId", 50);
.uri("/users/{userId}/posts/{postId}", params)
```

**d) Using `UriBuilder` (Flexible)**
```java
.uri(uriBuilder -> uriBuilder
        .path("/users/{id}")
        .queryParam("sort", "name")
        .queryParam("filter", "active")
        .build(1))
// Becomes: /users/1?sort=name&filter=active
```

---

### **4. Request Configuration Methods**

**a) `.header()` / `.headers()`**
```java
client.get()
    .uri("/data")
    .header("Authorization", "Bearer token123")
    .header("X-Custom-Header", "value")
    .headers(headers -> headers.setBasicAuth("user", "pass")) // Lambda style
    .retrieve()
    .body(String.class);
```

**b) `.accept()`**
```java
client.get()
    .uri("/data")
    .accept(MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML)
    .retrieve()
    .body(String.class);
```

**c) `.contentType()`**
```java
client.post()
    .uri("/users")
    .contentType(MediaType.APPLICATION_JSON)
    .body(newUser)
    .retrieve()
    .body(User.class);
```

**d) `.body()` (for Request Body)**
```java
// With Object (auto-converted to JSON)
client.post()
    .uri("/users")
    .body(new User("Alice")) // Most common

// With String
.body("{\"name\": \"Alice\"}")

// With HttpEntity
.body(new HttpEntity<>(new User("Alice"), headers))

// With Publisher (for reactive streams)
.body(Mono.just(new User("Alice")), User.class)
```

**e) `.cookie()`**
```java
client.get()
    .uri("/profile")
    .cookie("sessionId", "abc123")
    .cookie("theme", "dark")
    .retrieve()
    .body(String.class);
```

---

### **5. Execution & Response Handling Methods**

**a) `.retrieve()` (Simple & Common)**
The high-level, most commonly used method.
```java
// Get response body directly
String body = client.get().uri("/data").retrieve().body(String.class);

// Get as ResponseEntity for full control
ResponseEntity<String> entity = client.get()
        .uri("/data")
        .retrieve()
        .toEntity(String.class); // Includes body, status, headers

// Get just the headers (for HEAD requests)
HttpHeaders headers = client.head()
        .uri("/data")
        .retrieve()
        .toBodilessEntity() // Returns ResponseEntity<Void>
        .getHeaders();
```

**b) `.exchange()` (Full Control)**
Gives you raw access to the `ClientHttpResponse`. You are responsible for reading and closing the response.
```java
User user = client.get()
    .uri("/users/1")
    .accept(MediaType.APPLICATION_JSON)
    .exchange((request, response) -> {
        if (response.getStatusCode().is2xxSuccessful()) {
            // Manually convert the response body
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(response.getBody(), User.class);
        } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {
            throw new UserNotFoundException();
        } else {
            throw new RuntimeException("Request failed");
        }
    });
```

---

### **6. Response Handling & Error Methods (after `.retrieve()`)**

**a) `.body(Class<T> responseType)`**
Extracts and converts the response body.
```java
User user = client.get().uri("/users/1").retrieve().body(User.class);
```

**b) `.toEntity(Class<T> responseType)`**
Gets the full `ResponseEntity` (body, status, headers).
```java
ResponseEntity<User> response = client.get()
        .uri("/users/1")
        .retrieve()
        .toEntity(User.class);

User user = response.getBody();
HttpStatus status = response.getStatusCode();
HttpHeaders headers = response.getHeaders();
```

**c) `.toBodilessEntity()`**
For when you expect no response body (e.g., DELETE, HEAD).
```java
ResponseEntity<Void> response = client.delete()
        .uri("/users/1")
        .retrieve()
        .toBodilessEntity();

// Check if delete was successful
if (response.getStatusCode().is2xxSuccessful()) {
    System.out.println("Delete successful");
}
```

**d) `.onStatus()` (Declarative Error Handling)**
The modern way to handle errors. Define specific actions for specific HTTP status codes.
```java
User user = client.get()
    .uri("/users/invalid-id")
    .retrieve()
    .onStatus(
        status -> status == HttpStatus.NOT_FOUND, // Predicate
        (request, response) -> { // Error handler
            throw new UserNotFoundException("User not found with the provided ID");
        }
    )
    .onStatus(
        HttpStatus::is5xxServerError, // Method reference for predicate
        (request, response) -> {
            throw new ServiceUnavailableException("Product service is down: " + response.getStatusText());
        }
    )
    .body(User.class); // This only runs if no error status was triggered
```

**e) Default Error Handler (in Builder)**
Define a global error handler for all requests made by this client.
```java
RestClient client = RestClient.builder()
    .baseUrl("https://api.example.com")
    .defaultStatusHandler(
        HttpStatus::is4xxClientError,
        (request, response) -> {
            throw new CustomClientErrorException(response.getStatusCode());
        }
    )
    .build();
```

---

### **Complete Example Putting It All Together**

```java
// 1. CREATE a customized client
RestClient client = RestClient.builder()
    .baseUrl("https://jsonplaceholder.typicode.com")
    .defaultHeader("User-Agent", "MyApp/1.0")
    .build();

try {
    // 2. MAKE a GET request with path variables and error handling
    Post post = client.get()
            .uri("/posts/{id}", 1) // Path variable
            .accept(MediaType.APPLICATION_JSON)
            .retrieve()
            .onStatus(HttpStatus::is4xxClientError, (req, res) -> {
                throw new PostNotFoundException("Post not found!");
            })
            .body(Post.class); // Map response to Object

    System.out.println("Fetched Post: " + post.getTitle());

    // 3. MAKE a POST request with a body
    Post newPost = new Post("New Title", "New Body", 1);
    Post createdPost = client.post()
            .uri("/posts")
            .contentType(MediaType.APPLICATION_JSON)
            .body(newPost)
            .retrieve()
            .body(Post.class);

    System.out.println("Created Post ID: " + createdPost.getId());

} catch (PostNotFoundException e) {
    System.err.println("Error: " + e.getMessage());
}
```