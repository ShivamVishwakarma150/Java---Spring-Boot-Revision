# **Spring RestClient: The Modern Synchronous HTTP Client**

#### **1. The "Why": Moving Beyond RestTemplate**

Spring's `RestTemplate` served us well for years, but it had significant flaws:
*   **API Bloat:** A confusing number of overloaded methods (`getForObject`, `getForEntity`, `postForLocation`, etc.) made code hard to read and remember.
*   **Deprecation:** While not fully removed, `RestTemplate` is now in "maintenance mode." Spring actively recommends using its modern successors for new applications.
*   **Legacy Foundation:** It was built on older HTTP client libraries that lack support for modern protocols like HTTP/2.

**Enter RestClient:** Introduced in **Spring Framework 6** and **Spring Boot 3**, `RestClient` is the new, modern synchronous HTTP client.
*   **Synchronous & Blocking:** The client thread waits for the server's response before proceeding. This is ideal for traditional, thread-per-request servlet applications and is the direct replacement for `RestTemplate`.
*   **Fluent API:** Its greatest strength. It uses a clean, method-chaining style that is intuitive and self-documenting.
*   **Modern & Powerful:** Built on Java's new `HttpClient` (from `java.net.http`), which supports HTTP/1.1 and HTTP/2 out of the box.

---

#### **2. The Heart of RestClient: The Fluent API**

A **Fluent API** is an object-oriented design pattern that relies on **method chaining** to create a readable, flowing interface. Each method returns an object that provides the context for the next logical step.

**How it Works:**
Imagine the process of making an HTTP request:
1.  You need to choose a **method** (GET, POST).
2.  You need to specify a **URL**.
3.  You might want to add **headers**.
4.  For POST/PUT, you need to provide a **body**.
5.  Finally, you need to **execute** the request and decide how to **handle the response**.

The `RestClient` API mirrors this exact flow. Each step in the chain returns a new object that only has methods relevant to the *next possible steps*. This design inherently guides you and prevents errors.

**Example Flow:**
`restClient.**get()**` -> (returns an object that lets you set the URI)
`.**uri("...")**` -> (returns an object that lets you set headers)
`.**header("Auth", "token")**` -> (returns the same type, so you can add more headers or execute)
`.**retrieve()**` -> (executes the request and returns an object for handling the response)
`.**body(Product.class)**`; (extracts the response body)

**Key Benefit:** You don't memorize methods; you follow the logical chain. The API design enforces correctness.

---

#### **3. Practical Code Examples**

**First, Create a RestClient Instance:**
You can create a default instance or use the builder for customization (base URLs, default headers, interceptors).

```java
import org.springframework.web.client.RestClient;

// Simple creation
RestClient simpleClient = RestClient.create();

// Builder for custom configuration (Recommended)
RestClient restClient = RestClient.builder()
        .baseUrl("https://api.example.com") // Set a base URL for all requests
        .defaultHeader("Authorization", "Bearer my-token") // Set a default header
        .defaultStatusHandler( // Set a default error handler
            status -> status.is4xxClientError(),
            (request, response) -> { throw new CustomClientException(); }
        )
        // .requestInterceptor(new MyInterceptor()) // Add an interceptor
        .build();
```

**Example 1: GET Request**
This is the most common use case. The chain is very straightforward.

```java
// Order Service (port 8081) calls Product Service (port 8082)
@RestController
public class OrderController {

    private final RestClient restClient;

    // Inject your configured RestClient bean
    public OrderController(RestClient restClient) {
        this.restClient = restClient;
    }

    @GetMapping("/orders/{id}")
    public String getOrderDetails(@PathVariable String id) {

        // The Fluent Chain in action:
        String productDetails = restClient.get()
                .uri("http://localhost:8082/products/" + id) // Set the endpoint
                .retrieve() // Execute the request and get response wrapper
                .body(String.class); // Map the full response body to a String

        return "Order details: " + productDetails;
    }
}
```

**Example 2: POST Request with a JSON Body**
Notice how the chain adapts to include steps for setting the request body and content type.

```java
// Create an object to send
Product newProduct = new Product("100", "New Product", 49.99);

Product createdProduct = restClient.post()
        .uri("/products") // Uses the baseURL from the builder
        .contentType(MediaType.APPLICATION_JSON) // Set the Content-Type header
        .body(newProduct) // Set the request body object (will be converted to JSON)
        .retrieve()
        .body(Product.class); // Map the response JSON back to a Product object
```

**Example 3: Advanced Error Handling with `.onStatus()`**
This is a major improvement over `RestTemplate`. You can declaratively handle specific HTTP status codes.

```java
try {
    Product product = restClient.get()
            .uri("/products/{id}", "invalid-id")
            .retrieve()
            // Handle 404 (Not Found) specifically
            .onStatus(
                status -> status.value() == 404,
                (request, response) -> {
                    throw new ProductNotFoundException("Product not found!");
                }
            )
            // Handle any other 4xx error
            .onStatus(
                status -> status.is4xxClientError(),
                (request, response) -> {
                    throw new InvalidRequestException("Client error: " + response.getStatusText());
                }
            )
            // Handle 5xx server errors
            .onStatus(
                status -> status.is5xxServerError(),
                (request, response) -> {
                    throw new ServiceUnavailableException("Server is down!");
                }
            )
            .body(Product.class); // This only happens if no error status was triggered

} catch (ProductNotFoundException e) {
    // Handle the custom exception
}
```

**Example 4: Using `.exchange()` for Full Control**
For cases where you need access to the response headers or status code, use `.exchange()`. You are responsible for reading the response.

```java
ResponseEntity<Product> responseEntity = restClient.get()
        .uri("/products/{id}", id)
        .accept(MediaType.APPLICATION_JSON)
        .exchange((request, response) -> {
            // This lambda gives you full access to the ClientHttpResponse

            // 1. Check status code manually
            if (response.getStatusCode().is2xxSuccessful()) {
                // 2. Convert the response body stream to an object
                Product product = objectMapper.readValue(response.getBody(), Product.class);

                // 3. Build a ResponseEntity with body, status, and headers
                return ResponseEntity.ok()
                        .headers(response.getHeaders())
                        .body(product);
            } else {
                // 4. Handle non-2xx responses
                throw new CustomException("Request failed with status: " + response.getStatusCode());
            }
        });
```

---

#### **4. Adding Custom Interceptors**

Interceptors are powerful tools for cross-cutting concerns like logging, authentication, and metrics. They can inspect and modify the outgoing request.

**Step 1: Implement the Interceptor Interface**
```java
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import java.io.IOException;

public class AuthInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
            ClientHttpRequestExecution execution) throws IOException {

        // 1. Modify the request before it is sent
        request.getHeaders().add("Authorization", "Bearer " + getAuthToken());

        // 2. (Optional) Log the request details
        System.out.println("Sending request to: " + request.getURI());

        // 3. Execute the request and proceed with the chain
        ClientHttpResponse response = execution.execute(request, body);

        // 4. (Optional) Modify or log the response
        System.out.println("Received status: " + response.getStatusCode());

        return response;
    }

    private String getAuthToken() {
        // ... logic to get a valid token
        return "secret-token";
    }
}
```

**Step 2: Configure RestClient with the Interceptor**
```java
@Bean
public RestClient restClient() {
    return RestClient.builder()
            .baseUrl("https://api.example.com")
            .requestInterceptor(new AuthInterceptor()) // Add your interceptor
            .requestInterceptor(new LoggingInterceptor()) // You can add multiple
            .build();
}
```

---

#### **Summary & Key Points**

*   **Use RestClient for all new synchronous HTTP communication** in Spring Boot 3+ applications. It is the official successor to `RestTemplate`.
*   **Embrace the Fluent API.** Let the method chain guide your code. It results in more readable and maintainable code.
*   **Leverage Declarative Error Handling.** Use `.onStatus()` to cleanly centralize your HTTP error logic.
*   **Customize with Builders and Interceptors.** The `RestClient.builder()` is your friend for setting up common configuration and adding powerful features like interceptors.
*   **It's Synchronous.** Remember the calling thread will block. For non-blocking, asynchronous calls, you would use `WebClient` instead.