# HATEOAS in Spring Boot

#### 1. What is HATEOAS?

*   **Full Form:** **H**ypermedia **A**s **T**he **E**ngine **O**f **A**pplication **S**tate.
*   **Core Idea:** It's a constraint of REST architecture where a client interacts with a network application entirely through hypermedia (links) provided dynamically by the server. The server doesn't just send data; it sends data *and* the possible next actions.
*   **The "Weird Name" Explained:** Think of it as the server guiding the client through the application's workflow. The "state" of the application (e.g., a user is `unverified`) determines what "engine" (actions/links) are available to move it to the next state (e.g., `verified`).

#### 2. The Big Misconception: "Is HATEOAS Dead?"

*   **Myth:** "Companies don't use it, it's complex, avoid it."
*   **Reality:** It is actively used in large-scale, mature APIs (e.g., GitHub, PayPal, Amazon) where guiding a client through a complex workflow is more important than raw speed. The key is **not to overuse it**.

#### 3. Why Use HATEOAS? The Two Pillars

HATEOAS serves two primary purposes:

1.  **Loose Coupling:**
    *   **Problem (Tight Coupling):** The client has hardcoded logic to build URIs and decide what API to call next based on the response data. This makes the client brittle—any change on the server (e.g., changing a URI or the logic for determining the next step) breaks all clients.
    *   **Solution (Loose Coupling):** The server tells the client exactly what to do next via links. The client just follows the instructions. The server can change its internal structure and URIs, but as long as the "relation" (e.g., `verify`) remains the same, the client doesn't break.

2.  **API Discoverability:**
    *   The API response becomes self-documenting for its immediate next steps. The client doesn't need to memorize a vast API map or constantly refer to external documentation. It can "discover" the API's capabilities on the fly.

---

### The Crucial Example: User Verification Workflow

This example perfectly illustrates the "why."

#### Scenario:
A `POST /users` request successfully creates a new user with an `unverified` status. The user can be verified via SMS or Email, each requiring a `start` and `finish` step.

#### Without HATEOAS (Tight Coupling Hell)

**Server Response to `POST /users`:**
```json
{
  "id": 123,
  "name": "Shreyansh",
  "verifyStatus": "UNVERIFIED",
  "verifyType": "SMS", // Server logic dictates SMS for this user
  "smsVerifyState": "NOT_STARTED" // Server knows SMS hasn't started
}
```

**Client-Side Logic (Pseudocode):**
```java
// Client has to understand the server's business rules!
Response response = post("/users", userData);

if (response.verifyStatus == "UNVERIFIED") {
  if (response.verifyType == "SMS") {
    if (response.smsVerifyState == "NOT_STARTED") {
      // I know I must call this specific API next
      post("/api/user/" + response.id + "/sms-verify/start");
    } else if (response.smsVerifyState == "STARTED") {
      // I know I must call this other specific API next
      post("/api/user/" + response.id + "/sms-verify/finish", code);
    }
  } else if (response.verifyType == "EMAIL") {
    // ... duplicate logic for email ...
  }
}
// ... and more logic for GET, DELETE, etc.
```
**❌ Problems:** The client is full of business logic. It's tightly coupled to the server's data structure and workflow. Changing the verification process requires updating all clients.

#### With HATEOAS (Loose Coupling Nirvana)

**Server Response to `POST /users`:**
```json
{
  "id": 123,
  "name": "Shreyansh",
  "verifyStatus": "UNVERIFIED",
  "_links": {
    "self": {
      "href": "http://api.example.com/users/123",
      "type": "GET"
    },
    "delete": {
      "href": "http://api.example.com/users/123",
      "type": "DELETE"
    },
    "verify": {
      "href": "http://api.example.com/users/123/sms-verify/start",
      "type": "POST"
    }
  }
}
```

**Client-Side Logic (Pseudocode):**
```java
// Client is dumb and happy. It just follows instructions.
Response response = post("/users", userData);

// Is the user unverified? If so, there should be a "verify" link.
if (response.verifyStatus == "UNVERIFIED") {
  // Just find the link with relation "verify" and call it!
  // Client doesn't care if it's SMS, Email, or carrier pigeon.
  Link verifyLink = response.getLink("verify");
  post(verifyLink.getHref()); // Follows the server's instruction
}
```
**✅ Advantages:** The client is simple and robust. All the complex business logic ("what is the next step?") resides on the server. The server can change the verification flow from SMS to Email without the client ever knowing.

---

### The Golden Rule: When (Not) to Use HATEOAS

*   **DO USE HATEOAS:** For guiding a client through a **stateful workflow** (e.g., order processing: `created` -> `paid` -> `shipped` -> `delivered`). This is where it shines for loose coupling.
*   **DO NOT USE HATEOAS:** For adding **every possible link** to a resource. For example, on a `GET /users/123` response, adding links to `getAllUsers`, `createUser`, `getUserReports`, etc., is overkill. It bloats the response and adds unnecessary server-side complexity.
*   **SUMMARY:** Use it **judiciously** to reduce client-side complexity for core workflows, not for general API navigation.

---

### How to Implement in Spring Boot

#### 1. Add Dependency (`pom.xml`)
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
```

#### 2. Model Your Response Entity
Extend Spring's `RepresentationModel` to easily add links.
```java
import org.springframework.hateoas.RepresentationModel;

public class UserResponse extends RepresentationModel<UserResponse> {
    private Long id;
    private String name;
    private VerifyStatus verifyStatus; // enum: UNVERIFIED, VERIFIED

    // Constructors, Getters, and Setters
    public UserResponse(Long id, String name, VerifyStatus verifyStatus) {
        this.id = id;
        this.name = name;
        this.verifyStatus = verifyStatus;
    }
    // ... getters and setters ...
}
```

#### 3. Controller: Building Links Dynamically
Use `WebMvcLinkBuilder` or `Link.of()` to create links based on your business logic.

```java
import org.springframework.hateoas.Link;
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@RestController
@RequestMapping("/api/users")
public class UserController {

    @PostMapping
    public ResponseEntity<UserResponse> addUser(@RequestBody User user) {
        // 1. Save user logic (pseudo)
        User savedUser = userService.save(user);
        UserResponse response = new UserResponse(
            savedUser.getId(),
            savedUser.getName(),
            VerifyStatus.UNVERIFIED
        );

        // 2. **HATEOAS: Add links based on business logic**
        // Always add a self link
        Link selfLink = linkTo(methodOn(UserController.class).getUser(savedUser.getId())).withSelfRel();
        response.add(selfLink);

        // Add a delete link
        Link deleteLink = linkTo(methodOn(UserController.class).deleteUser(savedUser.getId())).withRel("delete");
        response.add(deleteLink);

        // Conditional link: Only add verify link if user is UNVERIFIED
        if (response.getVerifyStatus() == VerifyStatus.UNVERIFIED) {
            // Server decides the next step (e.g., SMS)
            Link verifyLink = Link.of(
                linkTo(UserController.class).slash(savedUser.getId()).slash("sms-verify/start").withSelfRel().getHref(), // Builds URI
                "verify" // Relation name
            ).withType("POST"); // HTTP Method

            // Alternatively using WebMvcLinkBuilder more directly:
            // Link verifyLink = WebMvcLinkBuilder.linkTo(methodOn(VerificationController.class).startSmsVerification(savedUser.getId())).withRel("verify").withType("POST");

            response.add(verifyLink);
        }
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}")
    public UserResponse getUser(@PathVariable Long id) { ... }

    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id) { ... }
}
```

#### 4. Resulting JSON Response
The `POST /api/users` call would return:
```json
{
  "id": 123,
  "name": "Shreyansh",
  "verifyStatus": "UNVERIFIED",
  "_links": {
    "self": {
      "href": "http://localhost:8080/api/users/123"
    },
    "delete": {
      "href": "http://localhost:8080/api/users/123"
    },
    "verify": {
      "href": "http://localhost:8080/api/users/123/sms-verify/start",
      "type": "POST"
    }
  }
}
```

### Summary

| Aspect | Without HATEOAS | With HATEOAS |
| :--- | :--- | :--- |
| **Coupling** | **Tight.** Client contains server logic. | **Loose.** Client just follows links. |
| **Client Logic** | Complex, knows URIs and workflows. | Simple, just parses responses and follows `_links`. |
| **Server Evolution** | Difficult. Changes break clients. | Easier. URIs and workflows can change behind stable relations. |
| **Use Case** | Simple CRUD APIs, where clients know the fixed flow. | Complex, stateful workflows (e.g., e-commerce, verification). |
| **Payload Size** | Smaller. | **Potentially larger.** Use wisely to avoid bloat. |

**Final Verdict:** HATEOAS is a powerful tool for building robust, evolvable APIs when applied correctly to workflow-driven problems. Don't dismiss it based on myths—understand its purpose and use it to eliminate complex, brittle client-side logic.

<br/>
<br/>

## Practical Example: E-Commerce Order API

**Scenario:** A client application needs to guide a user through the lifecycle of an order: creating it, paying for it, and checking its status. The server dictates the possible actions at each step.

#### 1. The Order States & Possible Actions

We'll define a simple state machine for an order:

| State | Description | Possible Next Actions |
| :--- | :--- | :--- |
| **DRAFT** | Cart is being built. | `place_order` (POST) |
| **PLACED** | Order is created, payment pending. | `pay` (POST), `cancel` (DELETE) |
| **PAID** | Payment is successful. | `cancel` (DELETE)*, `track` (GET) |
| **SHIPPED** | Order has been dispatched. | `track` (GET) |
| **CANCELLED** | Order was cancelled. | `create_new` (GET) |
| **DELIVERED** | Order is complete. | `rate` (POST), `create_new` (GET) |

*_Cancellation may not be allowed after a certain point, which the server determines._

---

#### 2. Implementation

**Step 1: Add the HATEOAS dependency (`pom.xml`)**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
```

**Step 2: Define the Order Model (Resource)**
We extend `RepresentationModel` to inherit the ability to add links.

```java
import org.springframework.hateoas.RepresentationModel;

public class Order extends RepresentationModel<Order> {
    private Long id;
    private String productName;
    private Integer quantity;
    private Double price;
    private OrderStatus status; // Enum: DRAFT, PLACED, PAID, etc.

    // Constructors, Getters, and Setters
    public Order(Long id, String productName, Integer quantity, Double price, OrderStatus status) {
        this.id = id;
        this.productName = productName;
        this.quantity = quantity;
        this.price = price;
        this.status = status;
    }
    // ... getters and setters ...
}
```

**Step 3: Create the Controller with Dynamic Link Logic**
This is the core. The `getOrder` method will return different links based on the order's current status.

```java
import org.springframework.hateoas.Link;
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @Autowired
    private OrderService orderService;

    // Get a specific order
    @GetMapping("/{id}")
    public ResponseEntity<Order> getOrder(@PathVariable Long id) {
        Order order = orderService.findById(id)
                .orElseThrow(() -> new OrderNotFoundException(id));

        // Always add a self link
        order.add(linkTo(methodOn(OrderController.class).getOrder(id)).withSelfRel());

        // **DYNAMIC LINKING: Add links based on the order's state**
        switch (order.getStatus()) {
            case DRAFT:
                // From DRAFT, you can only place the order
                Link placeOrderLink = linkTo(methodOn(OrderController.class).placeOrder(id))
                        .withRel("place_order") // Relation name
                        .withType("POST"); // HTTP Method
                order.add(placeOrderLink);
                break;

            case PLACED:
                // From PLACED, you can pay or cancel
                order.add(linkTo(methodOn(PaymentController.class).createPayment(id)).withRel("pay").withType("POST"));
                order.add(linkTo(methodOn(OrderController.class).cancelOrder(id)).withRel("cancel").withType("DELETE"));
                break;

            case PAID:
                // From PAID, you can track it. Cancellation might have a time limit.
                order.add(linkTo(methodOn(ShippingController.class).getTrackingInfo(id)).withRel("track").withType("GET"));
                if (orderService.isCancellationAllowed(id)) {
                    order.add(linkTo(methodOn(OrderController.class).cancelOrder(id)).withRel("cancel").withType("DELETE"));
                }
                break;

            case SHIPPED:
                order.add(linkTo(methodOn(ShippingController.class).getTrackingInfo(id)).withRel("track").withType("GET"));
                break;

            case CANCELLED:
            case DELIVERED:
                // Final states: suggest creating a new order
                order.add(linkTo(methodOn(ProductController.class).getAllProducts()).withRel("create_new").withType("GET"));
                // If delivered, you can also rate it
                if (order.getStatus() == OrderStatus.DELIVERED) {
                    order.add(linkTo(methodOn(ReviewController.class).createReview(id)).withRel("rate").withType("POST"));
                }
                break;
        }
        return ResponseEntity.ok(order);
    }

    // Other API endpoints (their implementation is simplified)
    @PostMapping("/{id}/place")
    public ResponseEntity<Order> placeOrder(@PathVariable Long id) {
        Order placedOrder = orderService.placeOrder(id);
        // Return the updated order, which will now have PLACED status and new links
        return ResponseEntity.created(linkTo(methodOn(OrderController.class).getOrder(id)).toUri()).body(placedOrder);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> cancelOrder(@PathVariable Long id) {
        orderService.cancelOrder(id);
        return ResponseEntity.noContent().build();
    }
}
```

---

#### 3. Practical Client-Side Experience

Let's see what the client receives at each step and how simple its logic becomes.

**1. Client retrieves a `DRAFT` order (`GET /api/orders/101`):**
```json
{
  "id": 101,
  "productName": "Spring Boot Course",
  "quantity": 1,
  "price": 49.99,
  "status": "DRAFT",
  "_links": {
    "self": {
      "href": "http://localhost:8080/api/orders/101"
    },
    "place_order": {
      "href": "http://localhost:8080/api/orders/101/place",
      "type": "POST"
    }
  }
}
```
**Client Logic:** "I see a `place_order` link. I will show the user a 'Place Order' button which, when clicked, triggers a POST request to the provided URL."

**2. After placing the order, its status is now `PLACED` (`GET /api/orders/101`):**
```json
{
  "id": 101,
  "status": "PLACED",
  "...": "...",
  "_links": {
    "self": { "href": "..." },
    "pay": {
      "href": "http://localhost:8080/api/payments/order/101",
      "type": "POST"
    },
    "cancel": {
      "href": "http://localhost:8080/api/orders/101",
      "type": "DELETE"
    }
  }
}
```
**Client Logic:** "I see `pay` and `cancel` links. I will show a 'Pay Now' button (POST) and a 'Cancel Order' button (DELETE)."

**3. After payment, status is `PAID` (`GET /api/orders/101`):**
```json
{
  "id": 101,
  "status": "PAID",
  "...": "...",
  "_links": {
    "self": { "href": "..." },
    "track": {
      "href": "http://localhost:8080/api/shipping/101/tracking",
      "type": "GET"
    }
    // The 'cancel' link is gone because the server's business logic (`isCancellationAllowed`) returned false.
  }
}
```
**Client Logic:** "The `pay` link is gone. I see a `track` link. I will remove the payment button and show a 'Track Your Package' button."

---

### Why This is Powerful & Practical

1.  **Server is the Source of Truth:** The server encapsulates all business rules (e.g., "can this order be cancelled?"). The client doesn't need to know these rules; it just obeys the links.
2.  **Evolvable API:** You can change the URI for payment from `/api/payments/order/{id}` to `/api/checkout/{id}`. As long as the relation is still named `pay`, all existing clients will continue to work without any updates.
3.  **Simplified Client Code:** The client code is reduced to a simple loop:
    ```java
    Response response = getOrder(id);
    displayData(response);
    // Look at the links in response._links
    displayButtonsForLinks(response._links); // Dynamically create UI buttons
    ```
4.  **Clear User Experience:** The UI naturally guides the user through the next logical steps in the process, preventing them from attempting invalid actions (e.g., trying to pay for a cancelled order).

This is the practical superpower of HATEOAS: it turns your API from a static data source into a dynamic application engine that drives the client experience.