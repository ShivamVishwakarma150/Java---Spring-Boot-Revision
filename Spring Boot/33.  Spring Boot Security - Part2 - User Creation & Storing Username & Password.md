# Spring Boot Security - User Creation Process

## Introduction to User Creation in Spring Security

Before implementing authentication methods like form login, basic auth, JWT, or OAuth, we need to understand how to properly create users in Spring Security. User creation is the foundational step that enables subsequent authentication and authorization.

## Default Behavior with Spring Security Dependency

When you add the Spring Security dependency:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

Spring Boot automatically:
1. Creates a default user with username "user"
2. Generates a random password that appears in the logs
3. Uses an in-memory user details manager

Key points:
- Each server restart generates a new random password
- This is for development/testing only
- Not suitable for production

## Approaches to User Creation

### 1. Using application.properties (Development Only)

Configure in `application.properties`:

```properties
spring.security.user.name=my_username
spring.security.user.password=my_password
spring.security.user.roles=ADMIN
```

How it works:
- Internally uses reflection to set SecurityProperties values
- Overrides default username/password
- Still creates just one user
- Not recommended for production

### 2. Custom InMemoryUserDetailsManager (Better for Testing)

Create a configuration class:

```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user1 = User.builder()
            .username("my_username1")
            .password("noop1234") // noop means no encoding
            .roles("USER")
            .build();
            
        UserDetails user2 = User.builder()
            .username("my_username2")
            .password("{bcrypt}$2a$10$N9qo8uLOickgx2ZMRZoMy...") // bcrypt encoded
            .roles("ADMIN")
            .build();
            
        return new InMemoryUserDetailsManager(user1, user2);
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

Password Storage Formats:
- `noop{plain_password}` - No encoding (plain text)
- `{bcrypt}hashed_password` - BCrypt hashing
- `{sha256}hashed_password` - SHA-256 hashing

Authentication Flow:
1. User provides plain credentials
2. System fetches stored credentials
3. DelegatingPasswordEncoder checks the prefix ({noop}, {bcrypt}, etc.)
4. Uses appropriate encoder to verify
5. If match, authentication succeeds

### 3. Database Storage (Production Recommended)

#### Entity Class

```java
@Entity
@Table(name = "user_auth")
public class UserAuthEntity implements UserDetails {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    private String password;
    private String roles;
    
    // UserDetails interface methods
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Arrays.stream(roles.split(","))
            .map(SimpleGrantedAuthority::new)
            .collect(Collectors.toList());
    }
    
    @Override
    public boolean isAccountNonExpired() { return true; }
    
    @Override
    public boolean isAccountNonLocked() { return true; }
    
    @Override
    public boolean isCredentialsNonExpired() { return true; }
    
    @Override
    public boolean isEnabled() { return true; }
    
    // getters and setters
}
```

#### Repository

```java
public interface UserAuthRepository extends JpaRepository<UserAuthEntity, Long> {
    UserAuthEntity findByUsername(String username);
}
```

#### Custom UserDetailsService

```java
@Service
public class UserAuthService implements UserDetailsService {
    
    private final UserAuthRepository repository;
    
    public UserAuthService(UserAuthRepository repository) {
        this.repository = repository;
    }
    
    @Override
    public UserDetails loadUserByUsername(String username) 
        throws UsernameNotFoundException {
        return repository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
    }
    
    public UserAuthEntity save(UserAuthEntity user) {
        return repository.save(user);
    }
}
```

#### Security Configuration

```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/register").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(withDefaults());
            
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

#### Registration Controller

```java
@RestController
@RequestMapping("/auth")
public class AuthController {
    
    private final UserAuthService service;
    private final PasswordEncoder encoder;
    
    public AuthController(UserAuthService service, PasswordEncoder encoder) {
        this.service = service;
        this.encoder = encoder;
    }
    
    @PostMapping("/register")
    public String register(@RequestBody UserAuthEntity user) {
        user.setPassword(encoder.encode(user.getPassword()));
        service.save(user);
        return "User registered successfully";
    }
}
```

## Key Production Considerations

1. **Password Hashing**: Always hash passwords before storage (BCrypt recommended)
2. **Dynamic User Creation**: Allow user registration through secured APIs
3. **Open Registration Endpoint**: Permit unauthenticated access to registration API
4. **UserDetails Implementation**: Properly implement all security-related methods
5. **Additional Security**: Consider account locking, expiration policies, etc.

## Authentication Flow with Database

1. User attempts to authenticate (via form, basic auth, etc.)
2. Spring Security calls `loadUserByUsername()` from your `UserDetailsService`
3. Your service fetches user from database using repository
4. PasswordEncoder verifies provided password against stored hash
5. If valid, authentication succeeds; otherwise fails

This approach provides a secure, scalable foundation for user management in production Spring Boot applications.