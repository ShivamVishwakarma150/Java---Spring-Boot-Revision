# Transaction Isolation Levels Explained

The image provides an overview of transaction isolation levels in database systems, particularly in the context of Spring's `@Transactional` annotation. Let me explain this in detail:

## What is Transaction Isolation?

Transaction isolation determines how changes made by one transaction are visible to other concurrent transactions. It's crucial for maintaining data integrity while allowing multiple transactions to occur simultaneously.

## The Four Isolation Levels

The table shows four standard isolation levels with their characteristics:

1. **READ_UNCOMMITTED**
   - **Dirty Read Possible**: Yes
   - **Non-Repeatable Read Possible**: Yes
   - **Phantom Read Possible**: Yes
   - This is the lowest isolation level where transactions can see uncommitted changes from other transactions (dirty reads).

2. **READ_COMMITTED**
   - **Dirty Read Possible**: No
   - **Non-Repeatable Read Possible**: Yes
   - **Phantom Read Possible**: Yes
   - Prevents dirty reads but allows non-repeatable reads and phantom reads. A transaction only sees committed changes.

3. **REPEATABLE_READ** (Note: There's a typo in the image - it says "REPEATABLE_COMMITTED")
   - **Dirty Read Possible**: No
   - **Non-Repeatable Read Possible**: No
   - **Phantom Read Possible**: Yes
   - Guarantees that if a transaction reads the same row twice, it will get the same value each time (no non-repeatable reads), but phantom reads are still possible.

4. **SERIALIZABLE**
   - **Dirty Read Possible**: No
   - **Non-Repeatable Read Possible**: No
   - **Phantom Read Possible**: No
   - The highest isolation level that emulates serial transaction execution, preventing all three phenomena.

## Concurrency Phenomena

1. **Dirty Read**: Reading uncommitted data from another transaction that might later be rolled back.
2. **Non-Repeatable Read**: Getting different values when reading the same row multiple times within a transaction because another transaction modified it.
3. **Phantom Read**: Seeing new rows that appeared since the initial read when requerying with the same criteria.

## Practical Usage

The code example shows how to specify isolation in Spring:
```java
@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED)
public void updateUser() {
    //some operations here
}
```

- `READ_COMMITTED` is a common default in many databases as it provides a good balance between consistency and performance.
- Higher isolation levels provide more consistency but reduce concurrency and performance.
- Lower isolation levels improve performance but may lead to data anomalies.

The choice of isolation level depends on your application's requirements for consistency versus performance.

<br/>
<br/>

# Dirty Read Problem in Database Transactions

The image explains the concept of dirty reads in database transactions, including a practical example with a timeline. Let's break this down in detail:

## Default Isolation Levels

The image first mentions that:
- The default isolation level depends on the database being used
- Most relational databases use **READ_COMMITTED** as the default isolation level
- However, this can vary between different database systems

This is important because the dirty read problem only occurs at isolation levels below READ_COMMITTED (primarily at READ_UNCOMMITTED).

## What is a Dirty Read?

A dirty read occurs when:
1. **Transaction A** reads uncommitted data from **Transaction B**
2. **Transaction B** then rolls back its changes
3. **Transaction A** now has data that never truly existed in the database (since it was rolled back)

This is called "dirty" because the data was never properly committed to the database.

## Illustrated Example

The timeline table shows a concrete example:

| Time | Transaction A | Transaction B | DB Status |
|------|---------------|---------------|------------|
| T1   | BEGIN_TRANSACTION | BEGIN_TRANSACTION | Id: 123 Status: free |
| T2   | | Update Row id:123 Status = booked | Id: 123 Status: booked (Not Committed yet) |
| T3   | Read Row id:123 (Got status = booked) | | Id: 123 Status: booked (Still not commited) |
| T4   | | Rollback | Id: 123 Status: Free (Changes undone) |

### Step-by-Step Explanation:

1. **T1**: Both transactions begin
   - Initial state: Row with id 123 has status "free"

2. **T2**: Transaction B updates the status to "booked" but doesn't commit yet
   - The change exists in Transaction B's context but isn't permanent

3. **T3**: Transaction A reads the row and sees status "booked"
   - This is the dirty read - reading uncommitted data
   - Transaction A now operates under the assumption that id 123 is booked

4. **T4**: Transaction B rolls back
   - The "booked" status never actually existed in the database
   - Transaction A was working with invalid data

## Consequences of Dirty Reads

Dirty reads can cause several problems:
- **Inconsistent decisions**: Transaction A might make decisions based on false data
- **Data integrity issues**: Subsequent operations might be invalid because they relied on phantom data
- **Application errors**: The application might behave incorrectly due to seeing temporary state

## Prevention

Dirty reads are prevented by using:
1. **READ_COMMITTED** isolation level or higher
   - Ensures a transaction only sees committed data
2. **Proper transaction management**
   - Keeping transactions short
   - Avoiding unnecessary reads of data that other transactions might modify

## Real-world Analogy

Imagine two people booking the last hotel room:
1. Person B starts booking (status changes to "booked" temporarily)
2. Person A sees it as booked and chooses another hotel
3. Person B's payment fails and booking is cancelled
4. Now the room is actually available, but Person A has already made other plans

This is why proper isolation levels are crucial for data integrity.

<br/>
<br/>

# **Non-Repeatable Read Problem in Database Transactions**

The image explains the **Non-Repeatable Read** problem, a concurrency issue that occurs when a transaction reads the same row multiple times but gets different values due to another committed transaction modifying the data in between.

---

## **What is a Non-Repeatable Read?**
A **Non-Repeatable Read** occurs when:
1. **Transaction A** reads a row.
2. **Transaction B** modifies (and commits) that same row.
3. **Transaction A** reads the same row again and gets a different value, even though it hasn't modified the data itself.

This violates the principle that a transaction should see a **consistent snapshot** of the database throughout its execution.

---

## **Example from the Image**
The table illustrates the scenario:

| **Transaction A** | **Database State** |
|-------------------|-------------------|
| `BEGIN_TRANSACTION` | `ID: 1, Status: Free` |
| `Read Row ID:1` → Gets `Status: Free` | `ID: 1, Status: Free` |
| *(Another transaction updates and commits the row)* | `ID: 1, Status: Booked` |
| `Read Row ID:1` → Now gets `Status: Booked` | `ID: 1, Status: Booked` |

### **Step-by-Step Breakdown:**
1. **T1:** Transaction A starts and reads `ID:1` → `Status: Free`.
2. **T2:** Meanwhile, **another transaction (B)** updates `ID:1` to `Status: Booked` and **commits**.
3. **T3:** Transaction A reads `ID:1` again → Now sees `Status: Booked` instead of `Free`.
4. **Result:** Transaction A got **two different values** for the same row within the same transaction.

---

## **Why is This a Problem?**
- **Inconsistent data:** A transaction should operate on a stable view of the database.
- **Business logic errors:** If a transaction makes decisions based on the first read, but the second read changes, it could lead to incorrect behavior.
- **Example:**  
  - A booking system checks if a seat is free (`SELECT` → `Free`).  
  - Before booking, it checks again (`SELECT` → now `Booked`).  
  - The system might incorrectly assume the seat was already taken, even though it was free initially.

---

## **How to Prevent Non-Repeatable Reads?**
This problem occurs under **READ_COMMITTED** isolation. To prevent it, use:
1. **REPEATABLE_READ Isolation**  
   - Guarantees that if a row is read twice in the same transaction, it will return the same value.
   - Implemented via **snapshot isolation** or **row-level locking** (prevents modifications until the transaction ends).

2. **SERIALIZABLE Isolation**  
   - The strongest isolation level, preventing all concurrency anomalies (dirty reads, non-repeatable reads, and phantom reads).

---

## **Comparison with Dirty Read**
| **Issue** | **Dirty Read** | **Non-Repeatable Read** |
|-----------|---------------|------------------------|
| **Definition** | Reading **uncommitted** changes from another transaction. | Reading **committed** changes from another transaction. |
| **Occurs in Isolation Level** | `READ_UNCOMMITTED` | `READ_COMMITTED` (but not in `REPEATABLE_READ` or higher) |
| **Solution** | Use `READ_COMMITTED` or higher. | Use `REPEATABLE_READ` or higher. |

---

## **Real-World Analogy**
- Imagine **two people checking a bank balance**:  
  - **Person A** checks balance → **$1000**.  
  - **Person B** withdraws **$500** and commits.  
  - **Person A** checks again → **$500**.  
  - **Problem:** Person A saw **two different balances** in the same session, leading to confusion.

---

## **Conclusion**
- **Non-Repeatable Reads** break transaction consistency by allowing committed changes from other transactions to affect subsequent reads.
- **Fix:** Use `REPEATABLE_READ` or `SERIALIZABLE` isolation levels when consistency is critical.
- **Trade-off:** Higher isolation improves consistency but may reduce concurrency and performance.  

This issue is particularly important in financial systems, booking applications, and anywhere data integrity is crucial.

<br/>
<br/>

# **Phantom Read Problem in Database Transactions**

The image illustrates the **Phantom Read** phenomenon, a subtle but important concurrency issue in database systems. Let me explain this concept thoroughly with additional insights.

## **What is a Phantom Read?**

A phantom read occurs when:
1. A transaction executes a query multiple times
2. Between executions, another transaction **inserts or deletes** rows that match the query criteria
3. The same query returns **different sets of rows** in the same transaction

Unlike non-repeatable reads (which affect existing rows), phantom reads involve **new rows appearing** or **existing rows disappearing** between reads.

## **Detailed Breakdown of the Example**

The timeline demonstrates this clearly:

| Step | Transaction A | Database State |
|------|--------------|----------------|
| T1   | `BEGIN_TRANSACTION` | `ID:1 (Free)`, `ID:3 (Booked)` |
| T2   | `SELECT * WHERE ID>0 AND ID<5` → Returns 2 rows (ID:1, ID:3) | Unchanged |
| T3   | *(Another transaction inserts and commits ID:2)* | `ID:1 (Free)`, **`ID:2 (Free)`**, `ID:3 (Booked)` |
| T4   | Same `SELECT` now returns 3 rows (ID:1, ID:2, ID:3) | Unchanged |
| T5   | `COMMIT` | |

### **Key Observations:**
- At T2: Query returns IDs 1 and 3
- At T4: Same query suddenly returns IDs 1, 2, and 3
- The "phantom" row (ID:2) appeared due to another committed transaction

## **Why Phantom Reads Are Problematic**

1. **Consistency Violations**  
   - Transactions expect a stable view of data
   - Sudden appearance/disappearance of rows breaks this expectation

2. **Business Logic Errors**  
   - Example: Seat reservation system checking availability
     ```sql
     -- First check: 2 available seats (IDs 1,3)
     -- Second check: 3 available seats (IDs 1,2,3)
     ```
   - May lead to double-booking or incorrect capacity calculations

3. **Statistical Operations**  
   - Reports running aggregate queries (COUNT, SUM) get inconsistent results

## **How Phantom Reads Differ From Other Issues**

| Problem          | Affects                | Example                          |
|------------------|------------------------|----------------------------------|
| Dirty Read       | Uncommitted data       | Seeing uncommitted "Booked" status |
| Non-Repeatable   | Existing row values    | Status changes from Free→Booked   |
| Phantom Read     | Result set composition | New rows appear in query results  |

## **Prevention Mechanisms**

### **Isolation Level Solutions**
1. **REPEATABLE_READ (Standard Prevention)**  
   - Most databases prevent non-repeatable reads but allow phantom reads
   - MySQL/InnoDB actually prevents phantoms via **gap locking**

2. **SERIALIZABLE (Absolute Prevention)**  
   - Locks entire ranges to prevent inserts
   - Highest isolation, lowest concurrency

### **Technical Implementations**
- **Snapshot Isolation**: Maintains a consistent view for reads
- **Predicate Locking**: Locks search conditions (e.g., `ID>0 AND ID<5`)
- **Materialized Views**: Pre-computed results avoid live query issues

## **Real-World Impact Example**

**Inventory Management System:**
1. Transaction A checks low-stock items (`SELECT...WHERE quantity<10`)
2. Transaction B adds new low-stock item and commits
3. Transaction A rechecks and sees new item
4. Result: Purchase order quantities become incorrect

## **Best Practices**

1. **Choose Appropriate Isolation**  
   - Use `REPEATABLE_READ` for most cases needing consistency
   - Reserve `SERIALIZABLE` for critical financial operations

2. **Optimize Transaction Design**  
   - Keep transactions short
   - Avoid repeated queries where possible

3. **Application-Level Solutions**  
   - Version checks
   - Pessimistic locking when necessary

## **Conclusion**

Phantom reads represent a sophisticated challenge in database concurrency control. While they don't affect all applications, systems requiring absolute consistency (financial systems, inventory management) must implement proper isolation strategies. Understanding this phenomenon helps developers choose the right balance between consistency and performance for their specific use case.


<br/>
<br/>

# **Database Locking Types and Isolation Levels Explained**

The image presents two key concepts in database concurrency control: **locking types** and **isolation levels**. Let's examine both in detail.

## **Part 1: Database Locking Types**

### **What is Database Locking?**
Locking is a mechanism that prevents concurrent transactions from interfering with each other by controlling access to database resources (typically rows or tables).

### **Lock Types**

| Lock Type | Also Known As | Allowed Concurrent Operations | Blocked Operations |
|-----------|--------------|-------------------------------|--------------------|
| **Shared Lock (S)** | READ LOCK | Other transactions can acquire **shared locks** (for reads) | **Exclusive locks** (writes) are blocked |
| **Exclusive Lock (X)** | WRITE LOCK | **No other locks** (shared or exclusive) are allowed | All other locks are blocked |

#### **Key Rules:**
1. **Shared Lock (S)**
   - Multiple transactions can hold **shared locks** on the same row simultaneously.
   - Used for `SELECT` operations (read-only).
   - **Blocks** exclusive locks (prevents writes while reads are happening).

2. **Exclusive Lock (X)**
   - Only **one transaction** can hold an exclusive lock on a row.
   - Used for `INSERT`, `UPDATE`, `DELETE` (write operations).
   - **Blocks both shared and exclusive locks** (no reads or writes allowed while locked).

### **Lock Compatibility Table**

| Current Lock | Another Transaction Requests **Shared Lock** | Another Transaction Requests **Exclusive Lock** |
|-------------|--------------------------------|----------------------------------|
| **Shared Lock (S)** | ✅ **Allowed** (multiple reads) | ❌ **Blocked** (no writes during reads) |
| **Exclusive Lock (X)** | ❌ **Blocked** (no reads during writes) | ❌ **Blocked** (no concurrent writes) |

### **When Are Locks Applied?**
- **Implicit Locks**: Databases automatically apply locks based on isolation level.
- **Explicit Locks**: Developers can manually lock rows (e.g., `SELECT ... FOR UPDATE`).

---

## **Part 2: Isolation Levels and Concurrency Problems**

The image also revisits isolation levels and their impact on three concurrency problems:

| Isolation Level | Dirty Read | Non-Repeatable Read | Phantom Read |
|----------------|------------|---------------------|--------------|
| **READ_UNCOMMITTED** | ✅ Yes | ✅ Yes | ✅ Yes |
| **READ_COMMITTED** | ❌ No | ✅ Yes | ✅ Yes |
| **REPEATABLE_READ** (Note: Typo in image) | ❌ No | ❌ No | ✅ Yes |
| **SERIALIZABLE** | ❌ No | ❌ No | ❌ No |

### **How Locking Relates to Isolation Levels**
1. **READ_UNCOMMITTED**  
   - No locks for reads → Dirty reads possible.
   - Minimal performance impact, but risky.

2. **READ_COMMITTED**  
   - Uses **shared locks** for reads (prevents dirty reads).  
   - Releases locks after read → Non-repeatable reads possible.

3. **REPEATABLE_READ**  
   - Holds **shared locks** until transaction ends → Prevents non-repeatable reads.  
   - Does not lock **new rows** → Phantom reads still possible.

4. **SERIALIZABLE**  
   - Uses **strictest locking** (range locks for queries).  
   - Prevents all three anomalies but reduces concurrency.

---

## **Practical Implications**

### **When to Use Which Lock?**
- **Shared Locks (S)**:  
  - Use when you need **consistent reads** (e.g., generating reports).  
  - Example: `SELECT * FROM orders WHERE status='pending' LOCK IN SHARE MODE` (MySQL).

- **Exclusive Locks (X)**:  
  - Use for **write operations** that must be atomic.  
  - Example: `SELECT * FROM accounts WHERE user_id=123 FOR UPDATE` (locks row for update).

### **When to Choose Which Isolation Level?**
| Isolation Level | Use Case | Trade-off |
|----------------|---------|-----------|
| **READ_UNCOMMITTED** | Analytics (speed over accuracy) | Risk dirty reads |
| **READ_COMMITTED** | Most OLTP applications (default in many DBs) | Non-repeatable reads possible |
| **REPEATABLE_READ** | Financial transactions (consistency needed) | Phantom reads still possible |
| **SERIALIZABLE** | Critical operations (e.g., banking transfers) | High latency, low concurrency |

---

## **Conclusion**
- **Locking** ensures data integrity by controlling access.
  - **Shared Locks (S)** = Read-only, allow concurrent reads.
  - **Exclusive Locks (X)** = Read-write, block all other operations.
- **Isolation Levels** determine how locks are used to prevent anomalies:
  - Higher isolation = Fewer anomalies but lower performance.
  - Lower isolation = Better performance but riskier.

**Recommendation:**  
- Default to **READ_COMMITTED** for most applications.  
- Use **REPEATABLE_READ** or **SERIALIZABLE** only when strict consistency is required.  
- Explicit locks (`FOR UPDATE`) can supplement isolation levels when needed.

<br/>
<br/>

# **Database Isolation Levels and Locking Strategies Explained**

This image provides a clear breakdown of how different isolation levels implement locking mechanisms to control concurrent database access. Let's examine each level in detail.

## **1. READ UNCOMMITTED (Lowest Isolation)**
### **Locking Strategy**
- **Read Operations**: No locks acquired
- **Write Operations**: No locks acquired

### **Behavior & Implications**
- Transactions can see uncommitted changes from other transactions (**dirty reads**)
- Offers maximum concurrency but minimum consistency
- **Use Case**: Rarely used in production; only for approximate analytics where accuracy isn't critical

### **Example Scenario**
```sql
-- Transaction A
UPDATE accounts SET balance = 500 WHERE id = 1; -- Not committed yet

-- Transaction B (READ UNCOMMITTED)
SELECT balance FROM accounts WHERE id = 1; -- Sees 500 (dirty read)
```

## **2. READ COMMITTED (Common Default)**
### **Locking Strategy**
- **Read Operations**:
  - Acquires **shared lock** during read
  - Releases lock immediately after read completes
- **Write Operations**:
  - Acquires **exclusive lock**
  - Holds lock until transaction ends (commit/rollback)

### **Behavior & Implications**
- Prevents dirty reads (only sees committed data)
- Allows **non-repeatable reads** (same row may change between reads)
- Allows **phantom reads** (new rows may appear)
- **Use Case**: Default for PostgreSQL, Oracle, SQL Server

### **Example Scenario**
```sql
-- Transaction A
SELECT * FROM products WHERE stock > 0; -- Gets 10 items (shared lock released)

-- Transaction B inserts a new product and commits

-- Transaction A repeats same query -- Now gets 11 items (phantom read)
```

## **3. REPEATABLE READ**
### **Locking Strategy**
- **Read Operations**:
  - Acquires **shared lock**
  - Holds lock until transaction ends
- **Write Operations**:
  - Acquires **exclusive lock**
  - Holds lock until transaction ends

### **Behavior & Implications**
- Prevents dirty reads and non-repeatable reads
- May still allow phantom reads (in some databases)
- MySQL/InnoDB implements additional **gap locking** to prevent phantoms
- **Use Case**: Financial systems where read consistency matters

### **Example Scenario**
```sql
-- Transaction A
BEGIN TRANSACTION;
SELECT * FROM accounts WHERE user_id = 1; -- Locks row (shared lock held)

-- Transaction B tries to update same account:
UPDATE accounts SET balance = 1000 WHERE user_id = 1; -- Blocked until Transaction A commits
```

## **4. SERIALIZABLE (Highest Isolation)**
### **Locking Strategy**
- All locks from REPEATABLE READ +
- Additional **range/predicate locks** on query conditions
- All locks held until transaction ends

### **Behavior & Implications**
- Prevents all three phenomena: dirty reads, non-repeatable reads, and phantom reads
- Essentially serializes transaction execution
- Significant performance impact
- **Use Case**: Critical operations like banking transfers

### **Example Scenario**
```sql
-- Transaction A
SELECT * FROM seats WHERE theater_id = 5 AND status = 'available' FOR UPDATE; -- Locks entire range

-- Transaction B tries to insert a new available seat in theater 5 -- Blocked!
```

## **Locking Mechanism Comparison**

| Isolation Level | Read Lock Duration | Write Lock Duration | Additional Locks |
|----------------|-------------------|---------------------|------------------|
| READ UNCOMMITTED | None | None | None |
| READ COMMITTED | During read only | Transaction end | None |
| REPEATABLE READ | Transaction end | Transaction end | None (except MySQL gap locks) |
| SERIALIZABLE | Transaction end | Transaction end | Range/predicate locks |

## **Practical Recommendations**
1. **Default Choice**: READ COMMITTED for most applications
2. **Consistency-Critical**: REPEATABLE READ for financial data
3. **Absolute Integrity**: SERIALIZABLE for reservation systems
4. **Performance-Critical**: Consider optimistic concurrency control instead

## **Database-Specific Notes**
- **MySQL/InnoDB**: REPEATABLE READ actually prevents phantom reads via gap locking
- **PostgreSQL**: SERIALIZABLE uses snapshot isolation rather than strict locking
- **Oracle**: READ COMMITTED is default with multi-version concurrency control

Understanding these locking strategies helps developers choose the right balance between data consistency and system performance for their specific application needs.
