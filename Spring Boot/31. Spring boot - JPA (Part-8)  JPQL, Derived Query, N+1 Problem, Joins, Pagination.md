# **Spring Boot JPA: Custom Queries with Derived Queries, JPQL, and Named Queries**

## **1. Introduction**
In JPA, we use repository interfaces (`JpaRepository`) to interact with the database. While built-in methods like `save()`, `findById()`, and `delete()` are sufficient for basic CRUD operations, sometimes we need **custom queries** for complex operations.

## **2. Derived Query Methods**
Derived queries allow JPA to **automatically generate queries** from method names following a **naming convention**.

### **Key Points:**
- Used for **read (SELECT)** and **delete (DELETE)** operations.
- Follows a **strict naming pattern** for JPA to parse the method into a query.
- **Not suitable** for complex joins or multi-table operations.

### **Naming Convention Structure:**
```
[Prefix][Entity][By][Field][Condition][And/Or][Field][Condition]...
```
- **Prefix:** `find`, `read`, `get`, `query`, `search`, `stream`, `count`, `exists`, `delete`, `remove`.
- **Entity:** Optional (e.g., `UserDetails`).
- **By:** Mandatory separator before field conditions.
- **Field:** Entity field name (CamelCase).
- **Condition:** `Equals`, `Like`, `Between`, `GreaterThan`, etc.

### **Examples:**
#### **(1) Basic Find Query**
```java
public interface UserRepository extends JpaRepository<UserDetails, Long> {
    List<UserDetails> findByName(String name);
}
```
**Generated Query:**
```sql
SELECT * FROM user_details WHERE name = ?;
```

#### **(2) Multiple Conditions (AND/OR)**
```java
List<UserDetails> findByNameAndPhone(String name, String phone);
```
**Generated Query:**
```sql
SELECT * FROM user_details WHERE name = ? AND phone = ?;
```

#### **(3) Using `IN` Clause**
```java
List<UserDetails> findByNameIn(List<String> names);
```
**Generated Query:**
```sql
SELECT * FROM user_details WHERE name IN (?);
```

#### **(4) Delete Operation**
```java
@Transactional
void deleteByName(String name);
```
**Generated Query:**
```sql
DELETE FROM user_details WHERE name = ?;
```

### **Pagination & Sorting**
- **`Pageable`:** Used for pagination (page number, size).
- **`Sort`:** Used for sorting (ascending/descending).

#### **Example:**
```java
Page<UserDetails> findByNameStartingWith(String prefix, Pageable pageable);
```
**Service Layer Usage:**
```java
Pageable pageable = PageRequest.of(0, 5, Sort.by("name").descending());
Page<UserDetails> users = userRepository.findByNameStartingWith("A", pageable);
```

---

## **3. JPQL (Java Persistence Query Language)**
JPQL is similar to SQL but works with **entity objects** instead of database tables.

### **Key Features:**
- **Database-independent** (works with any DB).
- Uses **entity names & fields** (not table/column names).
- Supports **joins**, **subqueries**, and **aggregate functions**.

### **Basic JPQL Example**
```java
@Query("SELECT u FROM UserDetails u WHERE u.name = :name")
List<UserDetails> findUsersByName(@Param("name") String name);
```
**Generated SQL:**
```sql
SELECT * FROM user_details WHERE name = ?;
```

### **JPQL with Joins (1-to-1)**
```java
@Query("SELECT u FROM UserDetails u JOIN u.userAddress a WHERE u.name = :name")
List<UserDetails> findUserWithAddress(@Param("name") String name);
```
**Generated SQL:**
```sql
SELECT * FROM user_details u JOIN user_address a ON u.id = a.user_id WHERE u.name = ?;
```

### **Returning Custom DTO (Not Entire Entity)**
```java
@Query("SELECT new com.example.dto.UserDTO(u.name, a.country) FROM UserDetails u JOIN u.userAddress a WHERE u.name = :name")
List<UserDTO> findUserAndCountry(@Param("name") String name);
```

### **N+1 Problem & Solution**
#### **Problem:**
- When fetching **multiple parents with children**, JPA executes:
   - **1 query** to fetch parents.
   - **N queries** to fetch children (one per parent).
- **Example:** Fetching 10 users → 1 query for users + 10 queries for addresses.

#### **Solution 1: `JOIN FETCH`**
```java
@Query("SELECT u FROM UserDetails u JOIN FETCH u.addressList WHERE u.name = :name")
List<UserDetails> findUsersWithAddresses(@Param("name") String name);
```
- **Fetches parent + children in a single query.**

#### **Solution 2: `@BatchSize`**
```java
@Entity
@BatchSize(size = 10)
public class UserDetails {
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Address> addressList;
}
```
- **Reduces queries by fetching children in batches.**

#### **Solution 3: `@EntityGraph`**
```java
@EntityGraph(attributePaths = {"addressList"})
List<UserDetails> findByName(String name);
```
- **Forces eager loading in derived queries.**

---

## **4. Modifying Queries (UPDATE/DELETE)**
- By default, `@Query` expects a **SELECT** query.
- For **UPDATE/DELETE**, use `@Modifying`.

### **Example:**
```java
@Modifying
@Transactional
@Query("DELETE FROM UserDetails u WHERE u.name = :name")
int deleteByName(@Param("name") String name);
```

### **Handling Persistence Context (`flushAutomatically`, `clearAutomatically`)**
```java
@Modifying(flushAutomatically = true, clearAutomatically = true)
@Transactional
@Query("UPDATE UserDetails u SET u.name = :newName WHERE u.name = :oldName")
int updateName(@Param("oldName") String oldName, @Param("newName") String newName);
```
- **`flushAutomatically`:** Syncs changes with DB immediately.
- **`clearAutomatically`:** Clears persistence context to avoid stale data.

---

## **5. Named Queries (`@NamedQuery`)**
- **Reusable queries** defined at the **entity level**.
- Avoids query duplication.

### **Example:**
#### **(1) Define Named Query on Entity**
```java
@Entity
@NamedQuery(name = "UserDetails.findByName", 
            query = "SELECT u FROM UserDetails u WHERE u.name = :name")
public class UserDetails { ... }
```

#### **(2) Use Named Query in Repository**
```java
@Query(name = "UserDetails.findByName")
List<UserDetails> findUsersByName(@Param("name") String name);
```

---

## **6. Summary**
| Feature | Use Case | Example |
|---------|----------|---------|
| **Derived Query** | Simple queries (find, delete) | `findByNameAndPhone()` |
| **JPQL** | Complex queries (joins, custom DTOs) | `@Query("SELECT u FROM User...")` |
| **Named Query** | Reusable queries | `@NamedQuery` on entity |
| **@Modifying** | UPDATE/DELETE queries | `@Modifying @Query("DELETE...")` |
| **Pagination** | `Pageable` & `Sort` | `findAll(Pageable pageable)` |

---

## **7. Next Steps**
- **Criteria API** (Dynamic queries).
- **Specification API** (Advanced filtering).
- **Native SQL Queries** (DB-specific queries).

<br/>
<br/>

# **Derived Query Methods in Spring Data JPA**

Derived query methods allow Spring Data JPA to **automatically generate database queries** based on **method names** following a specific naming convention. These methods eliminate the need to write SQL/JPQL queries manually.

---

## **1. How Derived Queries Work**
- Spring Data JPA **parses the method name** and converts it into a query.
- The method name must follow a **strict naming pattern**.
- Works for **SELECT**, **DELETE**, and **COUNT** operations (not for INSERT/UPDATE).

---

## **2. Naming Convention**
The method name is structured as:

```
[Prefix][Entity][By][Field][Condition][And/Or][Field][Condition]...
```

### **Key Components:**
| Part | Description | Example |
|------|-------------|---------|
| **Prefix** | Defines the operation (`find`, `get`, `read`, `query`, `delete`, `count`, `exists`) | `findBy`, `deleteBy` |
| **Entity** (Optional) | Name of the entity (if not specified, inferred from repository type) | `User` |
| **By** | Separator before field conditions | `By` |
| **Field** | Entity attribute name (CamelCase) | `name`, `email` |
| **Condition** | Comparison operator (`Equals`, `Like`, `Between`, `GreaterThan`, etc.) | `Like`, `Between` |

---

## **3. Examples of Derived Queries**
### **Entity Example**
```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    private String email;
    private int age;
    private LocalDate joinDate;
}
```

### **Repository Interface**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    // Derived query methods go here
}
```

---

### **(1) Basic Queries**
#### **Find by Exact Match**
```java
User findByName(String name);
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE name = ?;
```

#### **Find by Multiple Fields (AND Condition)**
```java
User findByNameAndEmail(String name, String email);
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE name = ? AND email = ?;
```

#### **Find by OR Condition**
```java
List<User> findByNameOrEmail(String name, String email);
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE name = ? OR email = ?;
```

---

### **(2) Comparison Operators**
#### **Greater Than (`GreaterThan`)**
```java
List<User> findByAgeGreaterThan(int age);
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE age > ?;
```

#### **Between (`Between`)**
```java
List<User> findByAgeBetween(int startAge, int endAge);
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE age BETWEEN ? AND ?;
```

#### **Like (`Like`)**
```java
List<User> findByNameLike(String pattern);
```
**Usage:**
```java
List<User> users = userRepository.findByNameLike("%John%"); // Finds names containing "John"
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE name LIKE ?;
```

---

### **(3) Null Checks**
#### **Find Non-Null Fields (`IsNotNull`)**
```java
List<User> findByEmailIsNotNull();
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE email IS NOT NULL;
```

#### **Find Null Fields (`IsNull`)**
```java
List<User> findByEmailIsNull();
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE email IS NULL;
```

---

### **(4) Sorting & Pagination**
#### **Sorting (`OrderBy`)**
```java
List<User> findByNameOrderByAgeAsc(String name);
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE name = ? ORDER BY age ASC;
```

#### **Pagination (`Pageable`)**
```java
Page<User> findByName(String name, Pageable pageable);
```
**Usage:**
```java
Pageable pageable = PageRequest.of(0, 5, Sort.by("age").descending());
Page<User> users = userRepository.findByName("John", pageable);
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE name = ? ORDER BY age DESC LIMIT 5 OFFSET 0;
```

---

### **(5) Delete Operations**
```java
@Transactional
void deleteByEmail(String email);
```
**Generated SQL:**
```sql
DELETE FROM user WHERE email = ?;
```

---

### **(6) Count & Exists Queries**
#### **Count Records (`countBy`)**
```java
long countByName(String name);
```
**Generated SQL:**
```sql
SELECT COUNT(*) FROM user WHERE name = ?;
```

#### **Check if Record Exists (`existsBy`)**
```java
boolean existsByEmail(String email);
```
**Generated SQL:**
```sql
SELECT CASE WHEN COUNT(*) > 0 THEN true ELSE false END FROM user WHERE email = ?;
```

---

## **4. Limitations of Derived Queries**
1. **Cannot handle complex joins** (use JPQL or `@Query` instead).
2. **No support for `GROUP BY` or `HAVING`**.
3. **Method names can get very long** for complex conditions.

---

## **5. When to Use Derived Queries?**
✅ **Simple queries** (single/multiple conditions).  
✅ **Quick prototyping** (avoids writing SQL).  
✅ **Read operations** (SELECT, COUNT, EXISTS).  

❌ **Avoid for complex queries** (use JPQL/Native SQL).  
❌ **Not for INSERT/UPDATE operations** (use `save()` or `@Modifying`).  

---

## **6. Summary Table**
| Query Type | Example | Generated SQL |
|------------|---------|---------------|
| **Find by single field** | `findByName(String name)` | `SELECT * FROM user WHERE name = ?` |
| **Find by multiple fields (AND)** | `findByNameAndEmail(name, email)` | `SELECT * FROM user WHERE name = ? AND email = ?` |
| **Find with `OR` condition** | `findByNameOrEmail(name, email)` | `SELECT * FROM user WHERE name = ? OR email = ?` |
| **Find with `GreaterThan`** | `findByAgeGreaterThan(age)` | `SELECT * FROM user WHERE age > ?` |
| **Find with `Like`** | `findByNameLike("%John%")` | `SELECT * FROM user WHERE name LIKE ?` |
| **Delete operation** | `deleteByEmail(email)` | `DELETE FROM user WHERE email = ?` |
| **Count records** | `countByName(name)` | `SELECT COUNT(*) FROM user WHERE name = ?` |
| **Pagination** | `findByName(name, Pageable)` | `SELECT * FROM user WHERE name = ? LIMIT ? OFFSET ?` |

---

## **7. Conclusion**
- Derived queries **reduce boilerplate code** by auto-generating SQL from method names.
- Best suited for **simple queries**.
- For **complex queries**, use **JPQL (`@Query`)** or **Native SQL**.

<br/>
<br/>

# **JPQL (Java Persistence Query Language) - Complete Guide**

JPQL is a powerful query language for JPA that allows you to write **database-agnostic queries** using **entity objects** instead of raw SQL tables.

---

## **1. What is JPQL?**
- **Object-oriented query language** (similar to SQL but works with entities).
- **Database-independent** (same query works for MySQL, PostgreSQL, etc.).
- Uses **entity names & attributes** (not table/column names).
- Supports **joins, subqueries, aggregation, and pagination**.

---

## **2. JPQL vs SQL**
| Feature | JPQL | SQL |
|---------|------|-----|
| **Works with** | Entity objects | Database tables |
| **Syntax** | `SELECT u FROM User u` | `SELECT * FROM users` |
| **Portability** | Works across databases | Database-specific |
| **Case Sensitivity** | Entity/attribute names are case-sensitive | Column names depend on DB |

---

## **3. Basic JPQL Syntax**
### **SELECT Queries**
```java
@Query("SELECT u FROM User u WHERE u.age > 25")
List<User> findUsersAbove25();
```
**Generated SQL:**
```sql
SELECT * FROM user WHERE age > 25;
```

### **SELECT with Parameters**
```java
@Query("SELECT u FROM User u WHERE u.name = :name AND u.age > :age")
List<User> findUsersByNameAndAge(@Param("name") String name, @Param("age") int age);
```
**Usage:**
```java
List<User> users = userRepository.findUsersByNameAndAge("John", 25);
```

---

## **4. JPQL Joins**
### **(1) **Implicit Join (Dot Notation)**
```java
@Query("SELECT u FROM User u WHERE u.address.city = 'New York'")
List<User> findUsersInNewYork();
```
**Generated SQL:**
```sql
SELECT u.* FROM user u JOIN address a ON u.address_id = a.id WHERE a.city = 'New York';
```

### **(2) **Explicit Join (`JOIN` Keyword)**
```java
@Query("SELECT u FROM User u JOIN u.address a WHERE a.country = 'USA'")
List<User> findUsersInUSA();
```

### **(3) **Left Join (`LEFT JOIN`)**
```java
@Query("SELECT u FROM User u LEFT JOIN u.orders o WHERE o.status = 'PENDING'")
List<User> findUsersWithPendingOrders();
```

---

## **5. JPQL for Custom DTO Projections**
Instead of returning full entities, fetch **specific fields** into a DTO.

### **DTO Class**
```java
public class UserDTO {
    private String name;
    private String email;
    // Constructor, Getters, Setters
}
```

### **JPQL Query**
```java
@Query("SELECT NEW com.example.dto.UserDTO(u.name, u.email) FROM User u WHERE u.age > 18")
List<UserDTO> findAdultUsers();
```
**Note:**  
- Requires a **constructor** in `UserDTO` matching the selected fields.

---

## **6. Aggregation & Grouping**
### **(1) Count Records**
```java
@Query("SELECT COUNT(u) FROM User u WHERE u.active = true")
long countActiveUsers();
```

### **(2) Group By**
```java
@Query("SELECT u.department, COUNT(u) FROM User u GROUP BY u.department")
List<Object[]> countUsersByDepartment();
```
**Returns:** `["HR", 5], ["IT", 10]`

### **(3) Max/Min/Avg**
```java
@Query("SELECT MAX(u.salary) FROM User u")
double findMaxSalary();
```

---

## **7. Pagination & Sorting**
### **Pagination (`Pageable`)**
```java
@Query("SELECT u FROM User u WHERE u.age > 20")
Page<User> findAdultUsers(Pageable pageable);
```
**Usage:**
```java
Pageable pageable = PageRequest.of(0, 10, Sort.by("name").ascending());
Page<User> users = userRepository.findAdultUsers(pageable);
```

### **Sorting (`ORDER BY`)**
```java
@Query("SELECT u FROM User u ORDER BY u.joinDate DESC")
List<User> findUsersSortedByJoinDate();
```

---

## **8. Update & Delete Queries**
### **Update Query (`@Modifying`)**
```java
@Modifying
@Transactional
@Query("UPDATE User u SET u.status = 'INACTIVE' WHERE u.lastLogin < :date")
int deactivateInactiveUsers(@Param("date") LocalDate date);
```

### **Delete Query**
```java
@Modifying
@Transactional
@Query("DELETE FROM User u WHERE u.age < 18")
int deleteUnderageUsers();
```

**Note:**  
- Must use `@Modifying` for **UPDATE/DELETE** queries.
- Requires `@Transactional` (at **service layer**).

---

## **9. Named Queries (`@NamedQuery`)**
Define reusable queries at the **entity level**.

### **Entity-Level Definition**
```java
@Entity
@NamedQuery(
    name = "User.findByStatus",
    query = "SELECT u FROM User u WHERE u.status = :status"
)
public class User { ... }
```

### **Repository Usage**
```java
@Query(name = "User.findByStatus")
List<User> findByStatus(@Param("status") String status);
```

---

## **10. Dynamic Queries with `JPA Criteria API`**
For **dynamic filtering**, use `CriteriaBuilder`:
```java
public List<User> findUsers(String name, Integer age) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> query = cb.createQuery(User.class);
    Root<User> user = query.from(User.class);
    
    List<Predicate> predicates = new ArrayList<>();
    if (name != null) predicates.add(cb.equal(user.get("name"), name));
    if (age != null) predicates.add(cb.gt(user.get("age"), age));
    
    query.where(predicates.toArray(new Predicate[0]));
    return entityManager.createQuery(query).getResultList();
}
```

---

## **11. Summary**
| Feature | JPQL Example |
|---------|--------------|
| **Basic Query** | `SELECT u FROM User u` |
| **Parameterized Query** | `WHERE u.name = :name` |
| **Join** | `JOIN u.address a` |
| **DTO Projection** | `SELECT NEW DTO(u.name, u.email)` |
| **Aggregation** | `SELECT COUNT(u), AVG(u.salary)` |
| **Pagination** | `Page<User> findAll(Pageable pageable)` |
| **Update/Delete** | `@Modifying @Query("UPDATE...")` |
| **Named Query** | `@NamedQuery(name="...", query="...")` |

---

## **12. When to Use JPQL?**
✅ **Complex queries** (joins, subqueries).  
✅ **Database-independent** applications.  
✅ **Custom DTO projections**.  
✅ **Bulk updates/deletes**.  

❌ **Avoid for simple queries** (use **derived methods** instead).  
❌ **Not for database-specific features** (use **native SQL**).  

---

## **13. Best Practices**
1. **Use `@Param`** for named parameters.
2. **Prefer DTO projections** for read-only queries.
3. **Use `JOIN FETCH`** to avoid **N+1 queries**.
4. **Always test queries** (some JPQL features vary by JPA provider).

<br/>
<br/>

# **Modifying Queries (UPDATE/DELETE) in Spring Data JPA**

Modifying queries allow you to execute **bulk updates and deletes** directly in the database without fetching entities first. Unlike standard `save()` or `delete()` methods, these queries **bypass the JPA persistence context** for better performance.

---

## **1. Why Use Modifying Queries?**
✅ **Faster bulk operations** (avises loading entities into memory).  
✅ **Reduces database roundtrips** (single query execution).  
✅ **Supports JPQL and native SQL**.  

❌ **Does not trigger JPA events** (`@PreUpdate`, `@PreRemove`).  
❌ **Bypasses 1st-level cache** (may lead to stale data).  

---

## **2. Key Annotations**
| Annotation | Purpose |
|------------|---------|
| `@Modifying` | Marks method as **UPDATE/DELETE** (not SELECT). |
| `@Transactional` | Ensures query runs in a transaction (required). |
| `@Query` | Defines JPQL/native SQL for the operation. |

---

## **3. Update Queries**
### **Basic JPQL Update**
```java
@Modifying
@Transactional
@Query("UPDATE User u SET u.status = 'INACTIVE' WHERE u.lastLogin < :cutoffDate")
int deactivateInactiveUsers(@Param("cutoffDate") LocalDate cutoffDate);
```
**How it works:**
1. **`@Modifying`** → Tells Spring this is an **UPDATE/DELETE**.
2. **`@Transactional`** → Runs in a transaction (auto-rollback on failure).
3. **Returns `int`** → Number of affected rows.

**Generated SQL:**
```sql
UPDATE user SET status = 'INACTIVE' WHERE last_login < '2023-01-01';
```

### **Update with Parameters**
```java
@Modifying
@Transactional
@Query("UPDATE User u SET u.password = :newPassword WHERE u.id = :userId")
int updatePassword(@Param("userId") Long id, @Param("newPassword") String newPassword);
```

---

## **4. Delete Queries**
### **Basic JPQL Delete**
```java
@Modifying
@Transactional
@Query("DELETE FROM User u WHERE u.status = 'BANNED'")
int deleteBannedUsers();
```
**Generated SQL:**
```sql
DELETE FROM user WHERE status = 'BANNED';
```

### **Delete with Join**
```java
@Modifying
@Transactional
@Query("DELETE FROM User u WHERE u.id IN (SELECT o.user.id FROM Order o WHERE o.paid = false)")
int deleteUsersWithUnpaidOrders();
```

---

## **5. Handling Persistence Context**
### **Problem: Stale Data**
- Modifying queries **do not sync** with the JPA cache.
- Example:
  ```java
  User user = userRepository.findById(1L).get();  // Cached in persistence context
  userRepository.updateStatus(1L, "INACTIVE");   // Bypasses cache
  System.out.println(user.getStatus());          // Still shows old value!
  ```

### **Solution: `clearAutomatically`**
```java
@Modifying(clearAutomatically = true)
@Transactional
@Query("UPDATE User u SET u.status = 'INACTIVE' WHERE u.id = :id")
void updateStatus(@Param("id") Long id);
```
- **`clearAutomatically = true`** → Clears persistence context after query.

### **Solution: `flushAutomatically`**
```java
@Modifying(flushAutomatically = true)
@Transactional
@Query("UPDATE User u SET u.name = :name WHERE u.id = :id")
void updateName(@Param("id") Long id, @Param("name") String name);
```
- **`flushAutomatically = true`** → Flushes pending changes before query.

---

## **6. Native SQL Modifying Queries**
For database-specific syntax (e.g., MySQL `ON DUPLICATE KEY UPDATE`):
```java
@Modifying
@Transactional
@Query(
    value = "INSERT INTO user (id, name) VALUES (:id, :name) ON DUPLICATE KEY UPDATE name = :name",
    nativeQuery = true
)
void upsertUser(@Param("id") Long id, @Param("name") String name);
```

---

## **7. Best Practices**
1. **Always use `@Transactional`** (service layer preferred).
2. **Prefer `clearAutomatically`** to avoid stale cache issues.
3. **Return `int`** to verify affected rows.
4. **Avoid for small updates** (use `save()` for individual entities).
5. **Test thoroughly** (modifying queries bypass JPA lifecycle events).

---

## **8. Complete Example**
### **Repository**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    @Modifying(clearAutomatically = true)
    @Transactional
    @Query("UPDATE User u SET u.email = :email WHERE u.id = :id")
    int updateEmail(@Param("id") Long id, @Param("email") String email);

    @Modifying
    @Transactional
    @Query("DELETE FROM User u WHERE u.createdAt < :date")
    int deleteOldUsers(@Param("date") LocalDate date);
}
```

### **Service Layer**
```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;

    @Transactional
    public void bulkDeactivateUsers(LocalDate cutoffDate) {
        int updated = userRepository.deactivateInactiveUsers(cutoffDate);
        log.info("Deactivated {} users", updated);
    }
}
```

---

## **9. Summary**
| Feature | Example | Notes |
|---------|---------|-------|
| **Update** | `@Query("UPDATE User SET status=...")` | Returns affected row count. |
| **Delete** | `@Query("DELETE FROM User WHERE...")` | Use `@Transactional`. |
| **Clear Cache** | `@Modifying(clearAutomatically=true)` | Avoids stale entities. |
| **Native SQL** | `@Query(nativeQuery=true)` | For DB-specific syntax. |

Modifying queries are powerful for **bulk operations** but require careful handling of the persistence context. Use them when performance outweighs the need for JPA caching. 🚀