# **Spring Boot Annotations: Handler Mapping & Request Handling**

### **1. Introduction & Context**

*   **Dispatcher Servlet:** The heart of Spring MVC. It receives all incoming HTTP requests.
*   **Handler Mapping:** The `DispatcherServlet` uses this mechanism to figure out which **Controller** (and specifically which method inside that controller) is responsible for handling a specific incoming request (e.g., `GET /fetch-user`).
*   **Today's Goal:** To understand the annotations that mark classes as controllers and map specific requests to their methods.

---

### **2. `@Controller` vs. `@RestController`**

#### **Purpose**
Both annotations indicate to Spring Boot that the class is a **controller** and is capable of handling incoming HTTP requests. Spring Boot scans and keeps a list of all such classes.

#### **Key Difference**
*   **`@Controller`:** 
    *   **Origin:** Part of the Spring MVC framework, typically used for web applications that return a **view** (e.g., a JSP, Thymeleaf template) to be rendered in the browser.
    *   **Return Value Behavior:** By default, the return value of a method is interpreted as the **name of a view** to render.
    *   **Example:** Returning `"hello"` would make Spring Boot look for a view file like `hello.jsp` to render.

*   **`@RestController`:** 
    *   **Origin:** A convenience annotation introduced in Spring 4, specifically for building **RESTful web services**.
    *   **What it is:** It's a combination of `@Controller` + `@ResponseBody` on **every method** in the class.
    *   **Return Value Behavior:** The return value of every method is written directly to the **HTTP response body**. It is **not** considered a view name. It's treated as the data to be sent back (e.g., JSON, XML).
    *   **Why it's preferred for APIs:** It's more convenient as you don't have to annotate every single method with `@ResponseBody`.

#### **`@ResponseBody` (The Bridge)**
*   **Purpose:** Tells Spring Boot that the method's return value should be bound to the body of the web response. It should **not** be interpreted as a view name.
*   **Usage:** Essential on methods in a `@Controller` class if you want to return data instead of a view.

| Annotation | Best For | Return Value Behavior |
| :--- | :--- | :--- |
| `@Controller` | Traditional web apps with UI views | View name (by default) |
| `@RestController` | REST APIs (JSON/XML responses) | HTTP Response Body (direct data) |
| `@ResponseBody` | Methods inside `@Controller` that return data | HTTP Response Body |

---

### **3. Request Mapping Annotations (`@RequestMapping`, `@GetMapping`, etc.)**

#### **Purpose**
These annotations are used to **map a specific HTTP request (URL + Method)** to a particular **controller method** that will process it.

#### **`@RequestMapping`**
*   The most generic mapping annotation.
*   **Attributes:**
    *   `value` or `path`: (Aliases for each other) Define the URL path of the API (e.g., `"/fetch-user"`).
    *   `method`: Defines the HTTP method (e.g., `RequestMethod.GET`, `RequestMethod.POST`).
*   **Example:**
    ```java
    @RequestMapping(path = "/fetch-user", method = RequestMethod.GET)
    public String getUser() { ... }
    ```

#### **Composed Annotations (`@GetMapping`, `@PostMapping`, etc.)**
*   **Purpose:** These are shorthand versions of `@RequestMapping` with the `method` attribute pre-defined. They improve **readability** and reduce boilerplate code.
*   **Examples:**
    *   `@GetMapping("/users")` = `@RequestMapping(path="/users", method=RequestMethod.GET)`
    *   `@PostMapping("/users")`
    *   `@PutMapping("/users/{id}")`
    *   `@DeleteMapping("/users/{id}")`

#### **Class-Level `@RequestMapping`**
*   **Purpose:** To define a **common base path** for all handler methods within a controller. This promotes clean and organized URL structures.
*   **How it works:** The path at the class level is **prepended** to the paths defined on the methods.
*   **Example:**
    ```java
    @RestController
    @RequestMapping("/api") // Base path for all methods in this class
    public class UserApiController {
        
        @GetMapping("/users") // Final URL: /api/users
        public List<User> getUsers() { ... }
        
        @PostMapping("/users") // Final URL: /api/users
        public User createUser() { ... }
    }
    ```

---

### **4. `@RequestParam`**

#### **Purpose**
Used to extract **query parameters** from the URL and bind them to method parameters.
*   **Query Parameters** appear after the `?` in a URL (e.g., `/api/users?firstName=Shreyansh&age=28`).

#### **Key Attributes**
*   `value` / `name`: The name of the query parameter to bind to.
*   `required`: (Default: `true`) Specifies if the parameter is mandatory. If `true` and the parameter is missing, Spring will throw an exception.
*   `defaultValue`: A default value to use if the request parameter is not provided or is empty.

#### **Example & Behavior**
```java
@GetMapping("/fetch-user")
public String getUserDetails(
        @RequestParam(value = "firstName") String firstName, // Mandatory
        @RequestParam(name = "lastName", required = false) String lastName // Optional
) {
    return "Fetch user details of " + firstName + " and " + lastName;
}
```
*   Calling `GET /fetch-user?firstName=Shreyansh` returns: `"Fetch user details of Shreyansh and null"`
*   Calling `GET /fetch-user` (without `firstName`) results in an error because `firstName` is required.

#### **Type Conversion**
Spring automatically converts the String-based query parameter values to the specified method parameter type (e.g., `String` -> `Integer`, `String` -> `Boolean`).

---

### **5. `@PathVariable`**

#### **Purpose**
Used to extract values from the **URI template path** (not the query string) and bind them to method parameters.
*   **Path Parameters** are parts of the URL path itself (e.g., `/api/users/123` where `123` is the user ID).

#### **How to Use**
1.  Define the variable placeholders in the mapping's path using curly braces `{}`.
2.  Use `@PathVariable` to bind the placeholder value to a method parameter.

#### **Example**
```java
@GetMapping("/users/{userId}") // {userId} is a path variable
public String getUserById(@PathVariable("userId") String id) {
    return "User ID is: " + id;
}
```
*   A request to `GET /api/users/abc123` would bind `"abc123"` to the `id` parameter.

---

### **6. `@RequestBody`**

#### **Purpose**
Used to bind the **body of the HTTP request** (typically JSON or XML) to a method parameter object.

#### **How it Works**
*   When a client sends JSON data, Spring uses libraries like **Jackson** to automatically **deserialize** (convert) the JSON into a Java object.
*   The field names in the JSON must match the field names in the Java object (or use annotations like `@JsonProperty` to map them).

#### **Example**
**Java Class (User):**
```java
public class User {
    @JsonProperty("user_name") // Maps JSON's "user_name" to this field
    private String username;
    
    private String email; // Maps to JSON's "email"
    // ... getters and setters
}
```
**Controller Method:**
```java
@PostMapping("/users")
public String createUser(@RequestBody User newUser) {
    // Spring automatically creates a User object from the request body JSON
    return "User " + newUser.getUsername() + " created!";
}
```
**HTTP Request (Body):**
```json
{
    "user_name": "shreyansh",
    "email": "shreyansh@example.com"
}
```

---

### **7. `ResponseEntity`**

#### **Purpose**
`ResponseEntity` represents the **entire HTTP response**, giving you full control over:
*   **Status Code** (e.g., 200 OK, 404 Not Found)
*   **Headers**
*   **Body**

This is more powerful than just returning a plain object (which only sets the body and a default 200 OK status).

#### **Comparison**
*   **Returning a `String` in a `@RestController`:** Internally, Spring wraps it in a `ResponseEntity` with a status of `200 OK` and the string as the body.
*   **Using `ResponseEntity` explicitly:** You have fine-grained control over all parts of the response.

#### **Example**
```java
@GetMapping("/custom-response")
public ResponseEntity<String> getCustomResponse() {
    HttpHeaders headers = new HttpHeaders();
    headers.add("Custom-Header", "HelloWorld");
    
    // Build the response: body, headers, status code
    return ResponseEntity
            .status(HttpStatus.OK) // HTTP 200
            .headers(headers)
            .body("This is the response body");
}
```

***

### **Summary Table of Annotations**

| Annotation | Purpose | Example Usage |
| :--- | :--- | :--- |
| **`@Controller`** | Marks class as a MVC controller (view-based) | `@Controller class UserController` |
| **`@RestController`** | Marks class as a REST controller (data-based) | `@RestController class UserApiController` |
| **`@RequestMapping`** | Maps requests to methods (generic) | `@RequestMapping(path="/users", method=GET)` |
| **`@GetMapping`** | Maps **GET** requests to methods | `@GetMapping("/users/{id}")` |
| **`@RequestParam`** | Binds **query parameters** (`?name=value`) | `@RequestParam("id") String userId` |
| **`@PathVariable`** | Binds values from the **URL path** | `@PathVariable("id") String userId` |
| **`@RequestBody`** | Binds the **HTTP request body** (JSON/XML) to an object | `@RequestBody User user` |
| **`ResponseEntity`** | Represents the entire HTTP response (status, headers, body) | `return ResponseEntity.ok(user);` |

These annotations are the fundamental building blocks for creating robust and well-defined REST APIs and web applications in Spring Boot.