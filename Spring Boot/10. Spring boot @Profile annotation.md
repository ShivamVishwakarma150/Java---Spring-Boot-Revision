# **Mastering Spring Boot Profiles with `@Profile` Annotation**  
**A Complete Guide to Environment-Specific Configuration**

---

## **1. Introduction to Spring Profiles**
Spring Profiles allow you to define **environment-specific configurations** (dev, QA, prod) in your application.  

### **Core Problems Solved:**
- Different database credentials per environment  
- Unique API endpoints for dev vs production  
- Environment-specific timeouts and throttling  
- Selective bean creation based on deployment  

---

## **2. Profile Implementation: Step-by-Step**

### **Step 1: Create Profile-Specific Property Files**
```
application.properties          # Default
application-dev.properties      # Development
application-qa.properties       # QA/Staging  
application-prod.properties     # Production
```

**Example (`application-dev.properties`):**
```properties
db.username=dev_user
db.password=dev_pass
api.timeout=1000ms
```

**Example (`application-prod.properties`):**
```properties
db.username=prod_user
db.password=prod_pass  
api.timeout=50ms
```

### **Step 2: Activate a Profile**
#### **Option A: In `application.properties`**
```properties
spring.profiles.active=dev
```

#### **Option B: At Runtime (Command Line)**
```bash
mvn spring-boot:run -Dspring-boot.run.profiles=prod
```

#### **Option C: Via `pom.xml` (Maven Profiles)**
```xml
<profiles>
    <profile>
        <id>dev</id>
        <properties>
            <spring.profiles.active>dev</spring.profiles.active>
        </properties>
    </profile>
    <profile>
        <id>prod</id>
        <properties>
            <spring.profiles.active>prod</spring.profiles.active>  
        </properties>
    </profile>
</profiles>
```
Run with:  
```bash
mvn spring-boot:run -Pprod
```

---

## **3. `@Profile` Annotation Deep Dive**
Conditionally create beans **only when specific profiles are active**.

### **Syntax:**
```java
@Profile("profile_name")
```

### **Example: Environment-Specific Beans**
```java
@Repository
@Profile("dev")
public class MockUserRepository implements UserRepository {
    // In-memory DB for development
}

@Repository  
@Profile("prod")
public class JpaUserRepository implements UserRepository {
    // Real PostgreSQL DB for production
}
```

### **Key Behaviors:**
1. **Profile Matching** (Exact string comparison)  
   - `@Profile("dev")` ‚Üí Only loads if `dev` is active  
2. **Multiple Profiles** (OR condition)  
   ```java
   @Profile({"dev", "staging"})  // Loads for dev OR staging
   ```
3. **Negation** (Exclude profiles)  
   ```java
   @Profile("!prod")  // Loads for all profiles EXCEPT prod
   ```

---

## **4. Profile Hierarchy & Property Resolution**
Spring merges properties with this priority:  
1. **Profile-specific** (`application-{profile}.properties`)  
2. **Default** (`application.properties`)  

**Example Flow:**  
1. If `spring.profiles.active=qa`:  
   - Checks `application-qa.properties` first  
   - Falls back to `application.properties` for missing keys  

---

## **5. Real-World Use Cases**

### **1. Multi-Cloud Configurations**
```java
@Configuration
@Profile("aws")
public class AwsConfig { /* AWS-specific beans */ }

@Configuration
@Profile("azure")  
public class AzureConfig { /* Azure-specific beans */ }
```

### **2. Feature Flags**
```java
@Service
@Profile("beta")
public class NewFeatureService { /* Experimental features */ }
```

### **3. Circuit Breaker Configuration**
```java
@Configuration
@Profile("!prod")  // Disable in production
public class CircuitBreakerConfig { /* Dev/QA settings */ }
```

### **4. Logging Strategies**
```java
@Bean
@Profile("dev")
public LogService consoleLogger() { /* Local logging */ }

@Bean  
@Profile("prod")
public LogService elkLogger() { /* Production ELK stack */ }
```

---

## **6. Best Practices**
‚úÖ **Use for Environments** (dev/qa/prod) ‚Äì Not for application-specific logic  
‚úÖ **Combine with `@Conditional`** for complex conditions  
‚úÖ **Document Active Profiles** in `README.md`  
‚úÖ **Test Profile-Specific Beans** in isolation  

‚ùå **Avoid Profile Misuse**  
```java
@Profile("app1")  // WRONG: Profiles are for environments, not apps
public class App1Service { ... }
```
*(Use `@ConditionalOnProperty` instead for app-specific beans)*

---

## **7. Comparison: `@Profile` vs `@ConditionalOnProperty`**
| Feature                | `@Profile`                          | `@ConditionalOnProperty`            |
|------------------------|-------------------------------------|-------------------------------------|
| **Purpose**            | Environment separation              | Generic conditional bean creation   |
| **Activation**         | Profile strings (`dev`, `prod`)     | Property values (`feature.enabled`) |
| **Best For**           | Environment-specific configs        | Feature flags, toggles             |
| **Flexibility**        | Limited to profiles                 | Any property condition             |

---

## **8. Pro Tips**
1. **Debug Active Profiles**:  
   ```java
   @PostConstruct
   public void checkProfiles() {
       System.out.println("Active profiles: " + Arrays.toString(env.getActiveProfiles()));
   }
   ```
2. **Default Profile Fallback**:  
   ```properties
   spring.profiles.default=dev
   ```
3. **Profile-Specific Logging**:  
   ```properties
   # application-dev.properties
   logging.level.root=DEBUG
   ```

---

## **Conclusion**
Spring Profiles (`@Profile`) are essential for:  
üîπ **Managing environment-specific configurations**  
üîπ **Reducing deployment-time errors**  
üîπ **Optimizing resource usage** per environment  

Use them wisely to keep your codebase **clean and maintainable** across all environments!  
