# üìò Spring 7 ‚Äì JdbcClient


## 1. üöÄ Introduction to JdbcClient

* **What it is**:

  * New API introduced in **Spring Framework 6.1+ (bundled in Spring 7 roadmap)**.
  * Alternative to `JdbcTemplate` ‚Üí reduces boilerplate, modern & fluent API.
  * Uses Java 8+ features (lambdas, method references).

* **Why**:

  * Simplifies SQL execution.
  * Clearer syntax, less code.
  * Easier binding of parameters.

---

## 2. üîë Basic Setup

* **Bean Configuration**:

  ```java
  @Configuration
  public class JdbcConfig {
      @Bean
      JdbcClient jdbcClient(DataSource dataSource) {
          return JdbcClient.create(dataSource);
      }
  }
  ```
* Inject `JdbcClient` in your repository/service directly.

---

## 3. üõ†Ô∏è CRUD Operations (Hands-on)

### ‚û°Ô∏è Create

```java
jdbcClient.sql("INSERT INTO seats(id, status) VALUES(:id, :status)")
          .param("id", 1)
          .param("status", "AVAILABLE")
          .update();
```

### ‚û°Ô∏è Read

```java
Seat seat = jdbcClient.sql("SELECT * FROM seats WHERE id=:id")
                      .param("id", 1)
                      .query(Seat.class)
                      .single();
```

### ‚û°Ô∏è Update

```java
jdbcClient.sql("UPDATE seats SET status=:status WHERE id=:id")
          .param("id", "BOOKED")
          .param("id", 1)
          .update();
```

### ‚û°Ô∏è Delete

```java
jdbcClient.sql("DELETE FROM seats WHERE id=:id")
          .param("id", 1)
          .update();
```

---

## 4. üîÑ Binding & Mapping Variants

* **Positional binding**:

  ```java
  jdbcClient.sql("SELECT * FROM seats WHERE id = ?")
            .param(1)
            .query(Seat.class)
            .single();
  ```
* **Named binding** (preferred):

  ```java
  jdbcClient.sql("SELECT * FROM seats WHERE id=:id")
            .param("id", 1)
            .query(Seat.class)
            .single();
  ```
* **Custom mapping**:

  ```java
  Seat seat = jdbcClient.sql("SELECT * FROM seats WHERE id=:id")
                        .param("id", 1)
                        .query((rs, rowNum) ->
                            new Seat(rs.getInt("id"), rs.getString("status")))
                        .single();
  ```

---

## 5. ‚ö° Transactions & Error Handling

* **Transaction Management**:

  ```java
  @Service
  public class BookingService {
      @Transactional
      public void bookSeat(int id) {
          Seat seat = repo.findByIdForUpdate(id);
          if (seat.isBooked()) {
              throw new RuntimeException("Already booked!");
          }
          repo.updateStatus(id, "BOOKED");
      }
  }
  ```

* **Spring 7 updates for `@Transactional`**:

  * Works with **record classes**.
  * Better detection for reactive + imperative mixing.
  * Clearer rollback-on-error semantics.

---

## 6. üîí Seat Row Locking

* **Why needed**:
  In booking systems (like flights/trains), multiple users might select the same seat at the same time.
  We prevent **double booking** by locking rows.

* **SQL**:

  ```sql
  SELECT * FROM seats WHERE id = :id FOR UPDATE
  ```

  * Locks row until transaction ends.
  * Ensures only one transaction can book the seat.

* **Spring Usage**:

  ```java
  public Seat findByIdForUpdate(int id) {
      return jdbcClient.sql("SELECT * FROM seats WHERE id=:id FOR UPDATE")
                       .param("id", id)
                       .query(Seat.class)
                       .single();
  }
  ```

---

## 7. üéØ Advanced / Edge Cases

* **Batch Inserts**:

  * JdbcClient has `.update()` loop for small sets.
  * For heavy loads ‚Üí `JdbcTemplate.batchUpdate()` or `SimpleJdbcInsert`.
  * Measure performance!

* **Dynamic IN clause**:

  ```java
  List<Integer> ids = List.of(1,2,3);
  String inClause = ids.stream().map(i -> "?").collect(Collectors.joining(","));
  jdbcClient.sql("SELECT * FROM seats WHERE id IN (" + inClause + ")")
            .params(ids)
            .query(Seat.class)
            .list();
  ```

* **Stored Procedures**:

  * For heavy logic ‚Üí use `SimpleJdbcCall`.
  * Example:

    ```java
    SimpleJdbcCall call = new SimpleJdbcCall(dataSource)
                              .withProcedureName("book_seat");
    Map<String, Object> out = call.execute(Map.of("seat_id", 1));
    ```

---

## 8. üîÑ Migrating from JdbcTemplate

* Replace:

  ```java
  jdbcTemplate.queryForObject(
      "SELECT * FROM seats WHERE id=?",
      new BeanPropertyRowMapper<>(Seat.class),
      id);
  ```
* With:

  ```java
  jdbcClient.sql("SELECT * FROM seats WHERE id=:id")
            .param("id", id)
            .query(Seat.class)
            .single();
  ```

üëâ Code becomes shorter, cleaner, type-safe.

---

## 9. üìä Mini Project (Flight Seat Booking System)

### Features Learned:

* **Controller** ‚Üí REST API `/flights/book/:seatId`
* **Service** ‚Üí `@Transactional` ensures atomic booking.
* **Repository** ‚Üí JdbcClient queries (CRUD + row lock).
* **Database** ‚Üí `FOR UPDATE` prevents double booking.
* **Error Handling** ‚Üí Exception rollback ‚Üí consistent state.

---

## 10. üìù Key Takeaways

* `JdbcClient` = modern, clean alternative to `JdbcTemplate`.
* Reduces boilerplate, supports named/positional params.
* Integrates naturally with `@Transactional`.
* Row locking (`FOR UPDATE`) is crucial for concurrency.
* For edge cases (batch, stored procs, IN clause) ‚Üí JdbcTemplate/other APIs still useful.
* Migration path is straightforward: replace long JdbcTemplate calls with short fluent JdbcClient calls.


<br/>
<br/>



# ‚úàÔ∏è Mini Project: Airline Seat Booking System

**Tech Stack**: Spring Boot 3 / Spring 7, JdbcClient, Transaction Management

---

## üîπ Features Covered

1. **CRUD** ‚Üí Create flight, List flights, List seats.
2. **Row Locking** ‚Üí Prevent two users from booking the same seat.
3. **Transactions** ‚Üí Either seat booking succeeds or rolls back.
4. **Error Handling** ‚Üí If seat is already booked, we show an error.

---

## 1Ô∏è‚É£ Database Schema

```sql
CREATE TABLE flight (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE seat (
    id BIGINT PRIMARY KEY,
    flight_id BIGINT,
    seat_no VARCHAR(10),
    booked BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (flight_id) REFERENCES flight(id)
);
```

* **Flight table** ‚Üí Stores flights (e.g., Indigo 6E-101).
* **Seat table** ‚Üí Stores seats (e.g., 1A, 1B) mapped to flights, with a `booked` flag.

---

## 2Ô∏è‚É£ Domain Model (Records)

We use Java 16+ `record` for immutability + less boilerplate.

```java
public record Flight(Long id, String name) {}
public record Seat(Long id, Long flightId, String seatNo, boolean booked) {}
```

---

## 3Ô∏è‚É£ Repository Layer

We use **Spring‚Äôs JdbcClient** (introduced in Spring 6) for clean SQL + mapping.

### Flight Repository

```java
@Repository
public class FlightRepository {

    private final JdbcClient client;

    public FlightRepository(JdbcClient client) {
        this.client = client;
    }

    public void addFlight(Flight flight) {
        client.sql("INSERT INTO flight(id, name) VALUES(:id, :name)")
              .param("id", flight.id())
              .param("name", flight.name())
              .update();
    }

    public List<Flight> listFlights() {
        return client.sql("SELECT * FROM flight")
                     .query(Flight.class)
                     .list();
    }
}
```

* **addFlight()** ‚Üí Inserts a new flight.
* **listFlights()** ‚Üí Fetches all flights.

---

### Seat Repository

```java
@Repository
public class SeatRepository {

    private final JdbcClient client;

    public SeatRepository(JdbcClient client) {
        this.client = client;
    }

    public List<Seat> listSeats(Long flightId) {
        return client.sql("SELECT * FROM seat WHERE flight_id = :fid")
                     .param("fid", flightId)
                     .query(Seat.class)
                     .list();
    }

    public Seat findSeatForUpdate(Long seatId) {
        return client.sql("SELECT * FROM seat WHERE id = :id FOR UPDATE")
                     .param("id", seatId)
                     .query(Seat.class)
                     .single();
    }

    public void markBooked(Long seatId) {
        client.sql("UPDATE seat SET booked = TRUE WHERE id = :id")
              .param("id", seatId)
              .update();
    }
}
```

* **listSeats()** ‚Üí Get seats for a flight.
* **findSeatForUpdate()** ‚Üí Fetch seat **with row lock** (this prevents race conditions).
* **markBooked()** ‚Üí Marks seat as booked.

---

## 4Ô∏è‚É£ Service Layer

This is where **business logic + transactions** live.

```java
@Service
public class BookingService {

    private final SeatRepository seatRepo;

    public BookingService(SeatRepository seatRepo) {
        this.seatRepo = seatRepo;
    }

    @Transactional
    public void bookSeat(Long seatId) {
        Seat seat = seatRepo.findSeatForUpdate(seatId);

        if (seat.booked()) {
            throw new RuntimeException("Seat already booked!");
        }

        seatRepo.markBooked(seatId);
        System.out.println("‚úÖ Seat booked: " + seat.seatNo());
    }
}
```

* `@Transactional` ensures **all-or-nothing**:

  * If seat is free ‚Üí booking commits.
  * If seat already booked ‚Üí throws error ‚Üí transaction rolls back.
* `FOR UPDATE` row lock ensures two users cannot grab the same seat simultaneously.

---

## 5Ô∏è‚É£ Controller Layer (REST API)

Exposes REST endpoints to test.

```java
@RestController
@RequestMapping("/flights")
public class FlightController {

    private final FlightRepository flightRepo;
    private final SeatRepository seatRepo;
    private final BookingService bookingService;

    public FlightController(FlightRepository flightRepo, SeatRepository seatRepo, BookingService bookingService) {
        this.flightRepo = flightRepo;
        this.seatRepo = seatRepo;
        this.bookingService = bookingService;
    }

    @PostMapping
    public void addFlight(@RequestBody Flight flight) {
        flightRepo.addFlight(flight);
    }

    @GetMapping
    public List<Flight> listFlights() {
        return flightRepo.listFlights();
    }

    @GetMapping("/{fid}/seats")
    public List<Seat> listSeats(@PathVariable Long fid) {
        return seatRepo.listSeats(fid);
    }

    @PostMapping("/book/{seatId}")
    public String bookSeat(@PathVariable Long seatId) {
        try {
            bookingService.bookSeat(seatId);
            return "‚úÖ Seat booked successfully!";
        } catch (RuntimeException e) {
            return "‚ùå " + e.getMessage();
        }
    }
}
```

* `POST /flights` ‚Üí Add flight.
* `GET /flights` ‚Üí List flights.
* `GET /flights/{fid}/seats` ‚Üí List all seats of a flight.
* `POST /flights/book/{seatId}` ‚Üí Try booking seat.

---

## 6Ô∏è‚É£ Quick Testing

1. Start app.
2. Add a flight:

```http
POST /flights
{
  "id": 101,
  "name": "Indigo 6E-101"
}
```

3. Insert seats in DB:

```sql
INSERT INTO seat(id, flight_id, seat_no) VALUES (1, 101, '1A');
INSERT INTO seat(id, flight_id, seat_no) VALUES (2, 101, '1B');
```

4. List seats:

```
GET /flights/101/seats
```

5. Book seat:

```
POST /flights/book/1
```

üëâ First request ‚Üí ‚úÖ booked.
üëâ Second request ‚Üí ‚ùå ‚ÄúSeat already booked!‚Äù.

---

## üîë Key Learnings

* **JdbcClient**: Clean SQL + automatic mapping into records.
* **Row Lock (`FOR UPDATE`)**: Prevents double booking in concurrency.
* **Transactions (`@Transactional`)**: Ensures commit/rollback safety.
* **Error Handling**: System gracefully rejects already booked seats.

---

‚ö° In just \~60 minutes, you touch:

* Spring Boot REST API
* JdbcClient
* Transactions
* Concurrency control with row lock
* Error handling

This is an **end-to-end system** you can show in **resume, LinkedIn, or interview** üöÄ.

