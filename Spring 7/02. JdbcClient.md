# üìò Spring 7 ‚Äì JdbcClient


## 1. üöÄ Introduction to JdbcClient

* **What it is**:

  * New API introduced in **Spring Framework 6.1+ (bundled in Spring 7 roadmap)**.
  * Alternative to `JdbcTemplate` ‚Üí reduces boilerplate, modern & fluent API.
  * Uses Java 8+ features (lambdas, method references).

* **Why**:

  * Simplifies SQL execution.
  * Clearer syntax, less code.
  * Easier binding of parameters.

---

## 2. üîë Basic Setup

* **Bean Configuration**:

  ```java
  @Configuration
  public class JdbcConfig {
      @Bean
      JdbcClient jdbcClient(DataSource dataSource) {
          return JdbcClient.create(dataSource);
      }
  }
  ```
* Inject `JdbcClient` in your repository/service directly.

---

## 3. üõ†Ô∏è CRUD Operations (Hands-on)

### ‚û°Ô∏è Create

```java
jdbcClient.sql("INSERT INTO seats(id, status) VALUES(:id, :status)")
          .param("id", 1)
          .param("status", "AVAILABLE")
          .update();
```

### ‚û°Ô∏è Read

```java
Seat seat = jdbcClient.sql("SELECT * FROM seats WHERE id=:id")
                      .param("id", 1)
                      .query(Seat.class)
                      .single();
```

### ‚û°Ô∏è Update

```java
jdbcClient.sql("UPDATE seats SET status=:status WHERE id=:id")
          .param("id", "BOOKED")
          .param("id", 1)
          .update();
```

### ‚û°Ô∏è Delete

```java
jdbcClient.sql("DELETE FROM seats WHERE id=:id")
          .param("id", 1)
          .update();
```

---

## 4. üîÑ Binding & Mapping Variants

* **Positional binding**:

  ```java
  jdbcClient.sql("SELECT * FROM seats WHERE id = ?")
            .param(1)
            .query(Seat.class)
            .single();
  ```
* **Named binding** (preferred):

  ```java
  jdbcClient.sql("SELECT * FROM seats WHERE id=:id")
            .param("id", 1)
            .query(Seat.class)
            .single();
  ```
* **Custom mapping**:

  ```java
  Seat seat = jdbcClient.sql("SELECT * FROM seats WHERE id=:id")
                        .param("id", 1)
                        .query((rs, rowNum) ->
                            new Seat(rs.getInt("id"), rs.getString("status")))
                        .single();
  ```

---

## 5. ‚ö° Transactions & Error Handling

* **Transaction Management**:

  ```java
  @Service
  public class BookingService {
      @Transactional
      public void bookSeat(int id) {
          Seat seat = repo.findByIdForUpdate(id);
          if (seat.isBooked()) {
              throw new RuntimeException("Already booked!");
          }
          repo.updateStatus(id, "BOOKED");
      }
  }
  ```

* **Spring 7 updates for `@Transactional`**:

  * Works with **record classes**.
  * Better detection for reactive + imperative mixing.
  * Clearer rollback-on-error semantics.

---

## 6. üîí Seat Row Locking

* **Why needed**:
  In booking systems (like flights/trains), multiple users might select the same seat at the same time.
  We prevent **double booking** by locking rows.

* **SQL**:

  ```sql
  SELECT * FROM seats WHERE id = :id FOR UPDATE
  ```

  * Locks row until transaction ends.
  * Ensures only one transaction can book the seat.

* **Spring Usage**:

  ```java
  public Seat findByIdForUpdate(int id) {
      return jdbcClient.sql("SELECT * FROM seats WHERE id=:id FOR UPDATE")
                       .param("id", id)
                       .query(Seat.class)
                       .single();
  }
  ```

---

## 7. üéØ Advanced / Edge Cases

* **Batch Inserts**:

  * JdbcClient has `.update()` loop for small sets.
  * For heavy loads ‚Üí `JdbcTemplate.batchUpdate()` or `SimpleJdbcInsert`.
  * Measure performance!

* **Dynamic IN clause**:

  ```java
  List<Integer> ids = List.of(1,2,3);
  String inClause = ids.stream().map(i -> "?").collect(Collectors.joining(","));
  jdbcClient.sql("SELECT * FROM seats WHERE id IN (" + inClause + ")")
            .params(ids)
            .query(Seat.class)
            .list();
  ```

* **Stored Procedures**:

  * For heavy logic ‚Üí use `SimpleJdbcCall`.
  * Example:

    ```java
    SimpleJdbcCall call = new SimpleJdbcCall(dataSource)
                              .withProcedureName("book_seat");
    Map<String, Object> out = call.execute(Map.of("seat_id", 1));
    ```

---

## 8. üîÑ Migrating from JdbcTemplate

* Replace:

  ```java
  jdbcTemplate.queryForObject(
      "SELECT * FROM seats WHERE id=?",
      new BeanPropertyRowMapper<>(Seat.class),
      id);
  ```
* With:

  ```java
  jdbcClient.sql("SELECT * FROM seats WHERE id=:id")
            .param("id", id)
            .query(Seat.class)
            .single();
  ```

üëâ Code becomes shorter, cleaner, type-safe.

---

## 9. üìä Mini Project (Flight Seat Booking System)

### Features Learned:

* **Controller** ‚Üí REST API `/flights/book/:seatId`
* **Service** ‚Üí `@Transactional` ensures atomic booking.
* **Repository** ‚Üí JdbcClient queries (CRUD + row lock).
* **Database** ‚Üí `FOR UPDATE` prevents double booking.
* **Error Handling** ‚Üí Exception rollback ‚Üí consistent state.

---

## 10. üìù Key Takeaways

* `JdbcClient` = modern, clean alternative to `JdbcTemplate`.
* Reduces boilerplate, supports named/positional params.
* Integrates naturally with `@Transactional`.
* Row locking (`FOR UPDATE`) is crucial for concurrency.
* For edge cases (batch, stored procs, IN clause) ‚Üí JdbcTemplate/other APIs still useful.
* Migration path is straightforward: replace long JdbcTemplate calls with short fluent JdbcClient calls.
