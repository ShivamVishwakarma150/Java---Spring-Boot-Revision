# ğŸ“˜ Day Recap â€“ JMS Deep Dive (Spring 7 Focus)

---

## 1ï¸âƒ£ What is JMS?

* **JMS (Java Message Service)** is a Java API for asynchronous messaging.
* Provides reliable communication between distributed systems using **queues** (point-to-point) and **topics** (pub-sub).

ğŸ‘‰ Think of JMS like a **message post office**:

* Producer = sends message (like dropping a letter)
* Consumer = receives message (like opening mailbox)
* Broker (ActiveMQ/Artemis) = the post office itself

---

## 2ï¸âƒ£ JmsTemplate vs JmsClient

### Old Way â†’ `JmsTemplate`

```java
jmsTemplate.convertAndSend("orderQueue", "Beer Order ğŸº");
```

* Verbose, boilerplate-heavy.
* Harder to chain multiple settings.

---

### New Way â†’ `JmsClient` (Spring 7+)

* **Fluent API** (method chaining) â†’ cleaner, declarative.

```java
JmsClient.create(factory)
         .to("orderQueue")
         .send("Beer Order ğŸº");
```

* **Fluent style** = "talking in sentences" â†’ easy to read, easy to maintain.
* Allows chaining â†’ `.to().send().withQoS()...`

---

## 3ï¸âƒ£ Per-message QoS (Quality of Service)

ğŸ‘‰ Apply delivery settings per message instead of global.
Examples:

```java
// Non-persistent message
client.to("orderQueue")
      .withDeliveryMode(DeliveryMode.NON_PERSISTENT)
      .send("Non-critical update");

// High-priority message
client.to("orderQueue")
      .withPriority(9)
      .send("ğŸš¨ High priority alert");

// Message expires in 5 seconds
client.to("orderQueue")
      .withTimeToLive(Duration.ofSeconds(5))
      .send("Temporary notification");
```

ğŸ“Œ Benefits: Fine-grained control on **durability, priority, expiration**.

---

## 4ï¸âƒ£ Async Consumption with `@JmsListener`

ğŸ‘‰ Instead of manually polling, use `@JmsListener` to auto-consume messages.

```java
@JmsListener(destination = "orderQueue")
public void consume(String msg) {
    System.out.println("ğŸ“¥ Received: " + msg);
}
```

* Works asynchronously.
* Most common way to handle JMS messages in Spring.

---

## 5ï¸âƒ£ Message Conversion (Text / JSON / Object)

Spring helps in automatically converting message payloads:

```java
// Text message
client.to("orderQueue").send("Hello");

// JSON message
client.convertAndSend("orderQueue", new Order("Beer", 2));

// Object message (Serializable)
Order order = new Order("Whiskey", 1);
client.convertAndSend("orderQueue", order);
```

ğŸ‘‰ `convertAndSend()` automatically serializes payload to JSON/Object.
ğŸ‘‰ `send()` just pushes raw string/text.

---

## 6ï¸âƒ£ `MessagePostProcessor` (Last-moment tweaks)

Used to set headers / properties **just before sending**.

Example:

```java
client.to("orderQueue").send("Beer Order ğŸº", msg -> {
    msg.setJMSCorrelationID("order-123");
    msg.setJMSPriority(8);
    msg.setLongProperty("AMQ_SCHEDULED_DELAY", 5000); // 5 sec delay
    return msg;
});
```

ğŸ‘‰ Common uses:

* Correlation ID (tracking request-response)
* Priority
* Expiration
* DeliveryMode
* Custom properties (`tenantId`, `type`)

---

## 7ï¸âƒ£ Error Handling + Retry

### Default Behavior

* If listener throws an exception â†’ transaction rollback â†’ message redelivered.

```java
@JmsListener(destination = "orderQueue")
public void consume(String msg) {
    if(msg.contains("Beer")) {
        throw new RuntimeException("ğŸº Not allowed now");
    }
    System.out.println("âœ… Processed: " + msg);
}
```

---

### Configurable Retry (Broker Level â€“ ActiveMQ Example)

```java
RedeliveryPolicy policy = factory.getRedeliveryPolicy();
policy.setMaximumRedeliveries(3);
policy.setInitialRedeliveryDelay(1000);
policy.setBackOffMultiplier(2);
policy.setUseExponentialBackOff(true);
```

ğŸ“Œ Retries with **1s â†’ 2s â†’ 4s** delay, max 3 attempts.

---

### Spring Retry (`@Retryable`)

```java
@JmsListener(destination = "orderQueue")
@Retryable(
    value = RuntimeException.class,
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000, multiplier = 2)
)
public void consume(String msg) {
    if(msg.contains("Beer")) {
        throw new RuntimeException("Retry please");
    }
    System.out.println("âœ… Consumed: " + msg);
}
```

ğŸ‘‰ Business logic retry at application level.

---

### Dead Letter Queue (DLQ)

* Final resting place for failed messages.
* Default in ActiveMQ = `ActiveMQ.DLQ`

---

### Custom ErrorHandler

```java
factory.setErrorHandler(t -> {
    System.err.println("âŒ Error in listener: " + t.getMessage());
});
```

---

# ğŸ¯ Quick Summary

* **JmsClient** = new Fluent API (replaces JmsTemplate).
* **Per-message QoS** = set priority, TTL, durability per message.
* **@JmsListener** = async consumption, most common style.
* **MessagePostProcessor** = tweak headers/properties before sending.
* **Error Handling** = retry, exponential backoff, DLQ for poison messages.

ğŸ‘‰ One-liner: *â€œSpring 7 makes JMS messaging cleaner (JmsClient), smarter (QoS, lambdas), and more resilient (retry, DLQ).â€*
