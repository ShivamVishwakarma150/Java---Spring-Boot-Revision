# 📘 Day Recap – JMS Deep Dive (Spring 7 Focus)

---

## 1️⃣ What is JMS?

* **JMS (Java Message Service)** is a Java API for asynchronous messaging.
* Provides reliable communication between distributed systems using **queues** (point-to-point) and **topics** (pub-sub).

👉 Think of JMS like a **message post office**:

* Producer = sends message (like dropping a letter)
* Consumer = receives message (like opening mailbox)
* Broker (ActiveMQ/Artemis) = the post office itself

---

## 2️⃣ JmsTemplate vs JmsClient

### Old Way → `JmsTemplate`

```java
jmsTemplate.convertAndSend("orderQueue", "Beer Order 🍺");
```

* Verbose, boilerplate-heavy.
* Harder to chain multiple settings.

---

### New Way → `JmsClient` (Spring 7+)

* **Fluent API** (method chaining) → cleaner, declarative.

```java
JmsClient.create(factory)
         .to("orderQueue")
         .send("Beer Order 🍺");
```

* **Fluent style** = "talking in sentences" → easy to read, easy to maintain.
* Allows chaining → `.to().send().withQoS()...`

---

## 3️⃣ Per-message QoS (Quality of Service)

👉 Apply delivery settings per message instead of global.
Examples:

```java
// Non-persistent message
client.to("orderQueue")
      .withDeliveryMode(DeliveryMode.NON_PERSISTENT)
      .send("Non-critical update");

// High-priority message
client.to("orderQueue")
      .withPriority(9)
      .send("🚨 High priority alert");

// Message expires in 5 seconds
client.to("orderQueue")
      .withTimeToLive(Duration.ofSeconds(5))
      .send("Temporary notification");
```

📌 Benefits: Fine-grained control on **durability, priority, expiration**.

---

## 4️⃣ Async Consumption with `@JmsListener`

👉 Instead of manually polling, use `@JmsListener` to auto-consume messages.

```java
@JmsListener(destination = "orderQueue")
public void consume(String msg) {
    System.out.println("📥 Received: " + msg);
}
```

* Works asynchronously.
* Most common way to handle JMS messages in Spring.

---

## 5️⃣ Message Conversion (Text / JSON / Object)

Spring helps in automatically converting message payloads:

```java
// Text message
client.to("orderQueue").send("Hello");

// JSON message
client.convertAndSend("orderQueue", new Order("Beer", 2));

// Object message (Serializable)
Order order = new Order("Whiskey", 1);
client.convertAndSend("orderQueue", order);
```

👉 `convertAndSend()` automatically serializes payload to JSON/Object.
👉 `send()` just pushes raw string/text.

---

## 6️⃣ `MessagePostProcessor` (Last-moment tweaks)

Used to set headers / properties **just before sending**.

Example:

```java
client.to("orderQueue").send("Beer Order 🍺", msg -> {
    msg.setJMSCorrelationID("order-123");
    msg.setJMSPriority(8);
    msg.setLongProperty("AMQ_SCHEDULED_DELAY", 5000); // 5 sec delay
    return msg;
});
```

👉 Common uses:

* Correlation ID (tracking request-response)
* Priority
* Expiration
* DeliveryMode
* Custom properties (`tenantId`, `type`)

---

## 7️⃣ Error Handling + Retry

### Default Behavior

* If listener throws an exception → transaction rollback → message redelivered.

```java
@JmsListener(destination = "orderQueue")
public void consume(String msg) {
    if(msg.contains("Beer")) {
        throw new RuntimeException("🍺 Not allowed now");
    }
    System.out.println("✅ Processed: " + msg);
}
```

---

### Configurable Retry (Broker Level – ActiveMQ Example)

```java
RedeliveryPolicy policy = factory.getRedeliveryPolicy();
policy.setMaximumRedeliveries(3);
policy.setInitialRedeliveryDelay(1000);
policy.setBackOffMultiplier(2);
policy.setUseExponentialBackOff(true);
```

📌 Retries with **1s → 2s → 4s** delay, max 3 attempts.

---

### Spring Retry (`@Retryable`)

```java
@JmsListener(destination = "orderQueue")
@Retryable(
    value = RuntimeException.class,
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000, multiplier = 2)
)
public void consume(String msg) {
    if(msg.contains("Beer")) {
        throw new RuntimeException("Retry please");
    }
    System.out.println("✅ Consumed: " + msg);
}
```

👉 Business logic retry at application level.

---

### Dead Letter Queue (DLQ)

* Final resting place for failed messages.
* Default in ActiveMQ = `ActiveMQ.DLQ`

---

### Custom ErrorHandler

```java
factory.setErrorHandler(t -> {
    System.err.println("❌ Error in listener: " + t.getMessage());
});
```

---

# 🎯 Quick Summary

* **JmsClient** = new Fluent API (replaces JmsTemplate).
* **Per-message QoS** = set priority, TTL, durability per message.
* **@JmsListener** = async consumption, most common style.
* **MessagePostProcessor** = tweak headers/properties before sending.
* **Error Handling** = retry, exponential backoff, DLQ for poison messages.

👉 One-liner: *“Spring 7 makes JMS messaging cleaner (JmsClient), smarter (QoS, lambdas), and more resilient (retry, DLQ).”*
